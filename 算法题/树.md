# 树

## 二叉树的最大路径

## 给定一个二叉树，原地将它展开为链表

## 红黑树/旋转

## 二叉搜索树中第K小的元素

## 一个二叉树，每个节点除了有左右子节点外，还有指向父节点的引用。给出一个节点，返回它在二叉树中中序遍历的下一个节点

## 输出二叉树从左侧看的结果

## 打印二叉树每层最右边的节点 层序遍历

## 二叉树从根到叶子的路径总和是否存在指定的值

## 求二叉树的两个节点的最近共同父节点

## 按层次遍历二叉树

```
void LevelOrder(TreeNode *root){
    std::queue<TreeNode *> q;
    TreeNode *front;
    if (root == NULL)
        return;
    q.push(root);
    while (!q.empty()) {
        front = q.front();
        q.pop();
        if (front->left)
            q.push(front->left);
        if (front->right)
            q.push(front->right);
        printf("%c ", front->data);
    }
}
```

## 求二叉树的深度

## 判定两个元素是否在同一棵树上（两个元素是否相互连接）