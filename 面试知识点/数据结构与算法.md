# 数据结构笔试题

## 数据结构分类

- 逻辑分类：线性结构、非线性结构
- 存储分类：顺序结构、链式结构

### 设计一个可以满足高效率获取第k大和前k个大的元素的数据结构
- 最小堆的数据结构来解决
- 最顶端是最小值，再次遇到比它大的值，就可以入堆，入堆后重新调整堆，将小的值pass掉。
- 这样我们就可以选出最大的前K个数据了。
- 假若我们要找出N个数据中最小的前k个数据，就要用最大堆了。
### 平衡二叉树查找复杂度
- O(log n)
### 红黑树和平衡二叉树

红黑树：
- (1)并不追求“完全平衡”——它只要求部分地达到平衡要求，降低了对旋转的要求，从而提高了性能。红黑树能够以O(log2 n) 的时间复杂度进行搜索、插入、删除操作。
- (2)此外，由于它的设计，任何不平衡都会在三次旋转之内解决。红黑树能够给我们一个比较“便宜”的解决方案。红黑树的算法时间复杂度和AVL相同，但统计性能比AVL树更高。

AVL树：

- 它的左子树和右子树都是AVL树，左子树和右子树的高度差不能超过;
- 查找、插入和删除在平均和最坏情况下都是O(log n),增加和删除可能需要通过一次或多次树旋转来重新平衡这个树;
- 一棵n个结点的AVL树的其高度保持在0(log2(n)),不会超过3/2log2(n+1) 一棵n个结点的AVL树的平均搜索长度保持在0(log2(n)). 一棵n个结点的AVL树删除一个结点做平衡化旋转所需要的时间为0(log2(n)).
### B+树
- B+ 树通常用于数据库和操作系统的文件系统中。NTFS, ReiserFS, NSS, XFS, JFS, ReFS 和BFS等文件系统都在使用B+树作为元数据索引。
- B+ 树的特点是能够保持数据稳定有序，其插入与修改拥有较稳定的对数时间复杂度。B+ 树元素自底向上插入。
### B树和B+树的区别

- B-树：多路搜索树，每个结点存储M/2到M个关键字，非叶子结点存储指向关键字范围的子结点；
- B-树：所有关键字在整颗树中出现，且只出现一次，非叶子结点可以命中；

- B+树：在B-树基础上，为叶子结点增加链表指针，所有关键字都在叶子结点中出现，非叶子结点作为叶子结点的索引；B+树总是到叶子结点才命中；

### 单向链表和双向链表的原理和特点、使用中（增删查）的优缺点
- 单向链表：只有一个指向下一个节点的指针。
- 优点：单向链表增加删除节点简单。遍历时候不会死循环；
- 缺点：只能从头到尾遍历。只能找到后继，无法找到前驱，也就是只能前进。
- 适用于节点的增加删除。

- 双向链表：有两个指针，一个指向前一个节点，一个后一个节点。
- 优点：可以找到前驱和后继，可进可退；
- 缺点：增加删除节点复杂，多需要分配一个指针存储空间。
- 适用于需要双向查找节点值的情况。

### 如何实现一个栈的类和对应的API
- [如何实现一个栈的类和对应的API](https://blog.csdn.net/zyq522376829/article/details/46855225)
- 栈是一种 特殊的线性表，栈仅能在线性表的一端进行操作
- 栈顶(Top)：允许操作的一端
- 栈底(Bottom)：不允许操作的一端

- 创建栈
- 销毁栈
- 清空栈
- 进栈
- 出栈
- 获取栈顶元素
- 获取栈的大小 
### 数据结构了解过吗？hashmap底层是怎么实现的？
答：hashmap的话是数组+链表实现的，通过hash散列化来决定进哪一个数组，如果有的话就“挂”在链表的最后面。

### 哈希表的设计

- 存放的是字典数据类型，即（key，value）的数据，是根据key 去存取value。

### hash表中的冲突

- 开放定址法：依靠数组中的空位解决碰撞冲突
  - 线性探测法：直接检测散列表的下一个位置（即索引值加1），如果仍冲突，继续；
  - 二次探测法：即H + 1^2, H + 2^2, H + 3^2…
  - 伪随机探测
- 再哈希法：使用多个哈希函数，第一个冲突时，使用第二个哈希函数，知道不冲突为止；
- 链地址法：将所有哈希地址相同的关键字，都链接到同一个链表中；

### HashMap底层，扩容机制

- map的底层结构是hmap（即hashmap的缩写），核心元素是一个由若干个桶（bucket，结构为bmap）组成的数组，每个bucket可以存放若干元素（通常是8个），key通过哈希算法被归入不同的bucket中。
- 当超过8个元素需要存入某个bucket时，hmap会使用extra中的overflow来拓展该bucket。
- 随着元素的增加，在一个bucket链中寻找特定的key会变得效率低下，所以在插入的元素个数/bucket个数达到某个阈值（当前设置为6.5，实验得来的值）时，map会进行扩容，
- 扩容完成后，每个hash对应两个bucket（一个新的一个旧的）。oldbucket不会立即被转移到新的bucket下，而是当访问到该bucket时，会调用growWork方法进行迁移，growWork方法会将oldbucket下的元素rehash到新的bucket中。随着访问的进行，所有oldbucket会被逐渐移动到bucket中。

### 问：hashcode一样怎么办？hashcode和equals的区别？
- 通过equals方法判断真正的内容。
1、如果两个对象相等（equals），那么他们一定有相同的哈希值（hash code）。
2、如果两个对象的哈希值相等，那么这两个对象有可能相等也有可能不相等。（需要再通过equals来判断）

## 一致性哈希
- 在解决分布式系统中负载均衡的问题时候可以使用Hash算法让固定的一部分请求落到同一台服务器上，这样每台服务器固定处理一部分请求（并维护这些请求的信息），起到负载均衡的作用。
- 但是普通的余数hash（hash(比如用户id)%服务器机器数）算法伸缩性很差，当新增或者下线服务器机器时候，用户id与服务器的映射关系会大量失效。一致性hash则利用hash环对其进行了改进。

## 排序算法

- 1、算法复杂度与初始状态无关的有：选择排序、堆排序、归并排序、基数排序。

- 2、元素总比较次数与初始状态无关的有：选择排序、基数排序。

- 3、元素总移动次数与初始状态无关的有：归并排序、基数排序。

- 4、冒泡排序、基数排序、插入排序、归并排序、桶排序、二叉树排序等是稳定的

## @排序总结

| 排序类型 | 排序名称 | 平均情况 | 最好情况 | 最坏情况 | 辅助空间 | 稳定性 |
| ------ | ------ | ------ | ------ | ------ | ------ | ------ |
| 插入类 | 直接插入排序 | n^2 | n | n^2 | 1 | 稳定 |
| 插入类 | 希尔排序 | nlogn ~ n^2 | n^1.3 | n^2 | 1 | 不稳定 |
| 选择类 | 简单选择 | n^2 | n^2 | n^2 | 1 | 稳定 |
| 选择类 | 堆排序 | nlogn | nlogn | nlogn | 1 | 不稳定 |
| 交换类 | 冒泡排序 | n^2 | n | n^2 | 1 | 稳定 |
| 交换类 | 快速排序 | nlogn | nlogn | n^2 | logn ~ n | 不稳定 |
| 归并类 | 归并排序 | nlogn | nlogn | nlogn | n | 稳定 |