# 算法题

- [查找排序](#查找排序)

- 二维数组上搜索路径：回溯法（递归）
- 最优解：动态规划、如果存在特殊选择可以考虑贪心
- 位运算：与、或、异或、左移右移

## 查找排序

- 排序：插入排序、冒泡排序、归并排序、快速排序
- 查找：二分查找、顺序查找、哈希表查找、二叉排序树
- 二分查找：在排序或者部分排序的数组中查找一个数字 或者统计数字出现的次数

### 快速排序

- partition算法

## 字符串

### 给出一个非空的字符串，判断这个字符串是否是由它的一个子串进行多次首尾拼接构成的。
例如，"abcabcabc"满足条件，因为它是由"abc"首尾拼接而成的，而"abcab"则不满足条件。 

```
#include <iostream>
using namespace std;
int main()
{
    string str;
    cin>>str;
    int fPos = 0,rPos =1,sLen = 1;
    int len = str.size();
    for(;rPos < len ; rPos++ ){
        if(str[fPos] == str[rPos]){//如果匹配，则fPos++
            fPos++;
        }else{
            sLen =  rPos+1;//如果不匹配，则认为0~rPos之间为子串，其长度为rPos+1
            fPos = 0;
        }
        if(fPos == sLen && rPos != len -1){
            fPos = 0;//如果匹配到当前子串的结尾，则从子串开头匹配。
        }
    }
    if(fPos != sLen ){
        cout<<"false"<<endl;
    }else{
        cout<<str.substr(0,sLen)<<endl;
    }
    return 0;
}
```

### 给出一个正整数n，请给出所有的包含n个'('和n个')'的字符串，使得'('和')'可以完全匹配。
例如：
'(())()'，'()()()' 都是合法的；
'())()('是不合法的。
请按照__字典序__给出所有合法的字符串。 


LeetCode22原题。

思路可以参照：https://blog.csdn.net/zjc_game_coder/article/details/78520742
代码可以参照：http://www.cnblogs.com/grandyang/p/4444160.html

### 给出一个整数n，将n分解为至少两个整数之和，使得这些整数的乘积最大化，输出能够获得的最大的乘积。
例如：
2=1+1，输出1；
10=3+3+4，输出36。 

import java.util.Scanner;
public class Main {
    /*
     * 举例计算11,11=5+6,5*6=30,11=3+4+5,3*4*4=48,11=2+3+3+3,2*3*3*3=54,11=1
     */
    static int p(int num) {
        int maxMul = 1;
        //i表示分解为i个数的加法，这些数相差不超过1.在所有的分解法中选择乘积最大的。
        for (int i = 2; i < num; i++) {
            int rem = num % i;
            int quo = num / i;
            int mul = 1;
            // int j=1;
            for (int j = 1; j <= i - rem; j++)
                mul *= quo;
            for (int j = 1; j <= rem; j++)
                mul *= (quo + 1);
            if (mul > maxMul)
                maxMul = mul;
            else
                return maxMul;
        }
        return maxMul;
    }
    public static void main(String[] args) {
        // TODO Auto-generated method stub
        //int num=2;
        //num=10;
        Scanner scanner=new Scanner(System.in);
        //返回：从输入信息扫描的 int
        int num=scanner.nextInt();
        System.out.println(p( num));
         
    }
}

### 二叉树的最大路径。
### 给定一个二叉树，原地将它展开为链表
### 红黑树/旋转
### 二叉搜索树中第K小的元素
### 一个二叉树，每个节点除了有左右子节点外，还有指向父节点的引用。给出一个节点，返回它在二叉树中中序遍历的下一个节点。 
### 给定一颗二叉树，求其中root的最长路径。所谓路径是指，联通两个结点的最小边数
### 代码：输出二叉树从左侧看的结果
### 二叉树从根到叶子的路径总和是否存在指定的值，很简单的问题。
### 一棵二叉树找到是否有一条路径（从根节点到子节点），节点值的和为N（leetcode原题）
### 求二叉树的两个节点的最近共同父节点
### 按层次遍历二叉树
```
void LevelOrder(TreeNode *root){
    std::queue<TreeNode *> q;
    TreeNode *front;
    if (root == NULL)
        return;
    q.push(root);
    while (!q.empty()) {
        front = q.front();
        q.pop();
        if (front->left)
            q.push(front->left);
        if (front->right)
            q.push(front->right);
        printf("%c ", front->data);
    }
}
```
### 给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值

### 冒泡的实现和优缺点

### 找出一从小到大排序数组中小于0的最大数的索引和大于0的最小数的索引，如果数组没排序怎么找

### 代码 两个str 最大公共子序列和子串
### int 4字节整数的海量数据，如何给出一个数，判断是否在这堆数据里？
### 给定数字字符串，用*分为六部分，每部分0~600，输出所有可能的结果
### 大文本数据（数T），统计每个字符串的频率
### 怎么判断链表有环，怎么找到环入口
### 怎么判断链表是否相交，找到相交点

### 手写求两个链表第一个交叉节点

### 两个升序数组，找出第k小的数字，
 这题没见过，先说了个最笨的方法，要求优化。想了一下，又说了一个用二分优化的，要求再优化，最后他提示了一下，想明白了写了代码

### 查找两个链表的交叉节点

### 千万级别的数据量，实现队列FIFO，如何设计数据结构节省内存空间（数据+链表）


### 如何利用rand(1,8)实现随机生成1-5



### 合并两个有序数组



### 一个数组有1个数字出现了一次,其他数字出现了三次,请问不用map的情况如何找到这个只出现了一次的数（不会）

### 删除一个整数数组中value为50的数字，并且返回最终的长度

### 求数组的中位数。数组由一个升序数组翻转形成，如1 2 3 4 5 6 7可以从5处翻转，形成5 6 7 1 2 3 4，求5 6 7 1 2 3 4的中位数。要求时间复杂度低于O(n)。

### 给一个数组，定义X为某个区间的最小值乘上这个区间内所有元素的和，求最大的X。如数组为3 1 6 4 5，则最大的X=4*（6+4+5）=60

### 一个数组，每个位置的值对应下标。重新排列，要求对应位置上不能有同下标相同的值，即原先a[0]=0，重排后a[0]不可以等于0。输出总共有多少种重新排列的方法。


### 手写快排
### 手写堆排
### 已知出栈序列求所有的入栈序列（这题很有意思，当时只是写了列出所有的可能，后来想到这题和已知入栈序列求所有出栈序列是一样的）

### 合并两个有序链表。递归和非递归的实现。



### 给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。
当时我真的是很慌张！脑子里想的是我会做我会做！可是却是一片空白。深呼吸一下。用递归做了出来。 又问我除了递归怎么做？“那就遍历，每次都比较就行”
“那为什么不用遍历用递归呢？”“递归写起来简单啊！”

### 两个链表相加。{1->2->3} + {1->2->3} = 246. 



### 两个有序链表合并成一个有序
（代码有错，忘了写迭代）

### 一个链表，假设第一个节点我们定为下标为1，第二个为2，那么下标为奇数的结点是升序排序，偶数的结点是降序排序，如何让整个链表有序？（分离链表，合并两个有序链表）

### 假设我们有一个队列，可能存放几千万上亿的数据，我们应该如何设计这个队列？写出来看看？（提问：这个队列是只需要在头尾添加和删除吗？双向队列？答：是的）

### 一个二维矩阵，从左到右是升序，从上到下是降序，找一个数是否存在于矩阵中（类似于二叉查找树）

### 单链表的反转，不用递归的方法。

### 有序数组存在某个值，查找这个值的下标，有则输出，无则输出-1

### 写个二进制转十进制

### 手写“反转链表”算法？（迭代和递归）

### 给你一个数组，数组长度为 n。请找出数组中第k大的数

首先，创建一个长度为K的空数组。从原数组中先挑出K个数进行排序并放到这个空数组中。这一步的时间复杂度是O(Klog(K))。

接着，从剩下的N-K个值中，依次遍历并与上面数组的末尾的数（即里面的最大数）相比较，并插入到合适位置，需要执行(N-K)步。

总平均时间复杂度是O(Klog(K)×(N-K))。

另外，如果采用最大堆或红黑树的方法来调整插入删除K数组，时间复杂度是O(log(K))，总时间复杂度是O(Nlog(K))。

n, A[i] int 范围内

附件条件：不允许改变元素在数组中的位置。

一开始想都没想就先说了用partition的思路，面试官听了之后加了一个附加条件...就完全没思路了，最后问了提示：“给你一个数你能找到是数组的第几大吗？”，才想出来并实现

思路就是在int范围内取中位数，算出其在数组中是第几大元素，与k比较并不断二分

## 两个有序数组找第k大的数

```c++
int find_kth(int A[], int m, int B[], int n, int k) {
    if (m > n) return find_kth(B, n, A, m, k);
    if (m == 0) return B[k - 1];
    if (k == 1) return min(A[0], B[0]);
    int ia = min(k / 2, m), ib = k - ia;
    if (A[ia - 1] < B[ib - 1])
        return find_kth(A + ia, m - ia, B, n, k - ia);
    else if (A[ia - 1] > B[ib - 1])
        return find_kth(A, m, B + ib, n - ib, k - ib);
    else
        return A[ia - 1];
    }
};
```

## 找一堆数字里的中位数

1、如果数组元素的个数是奇数，取数组前(size+1)/2个元素建堆，如果是偶数则取前 size/2 个元素建堆。
2、建完堆之后，此时堆顶的元素是这前 (size-1)/2 个元素中最小的；此时需要将数组中剩余的元素分别和堆顶的元素进行比较：如果小于等于堆顶元素则直接丢弃，如果大于堆顶的元素则需要更新堆顶的元素并重新调整堆的结构，使其保证小顶堆的特性。
3、将剩余的元素全部比较完之后，此时堆顶的元素就是所要求的中位数。
在这里需要提到的是，优先级队列的底层也是通过建堆来实现的。默认是建大堆，此时就要编写一个使其建小堆的仿函数了，其实也就是相当于修改了它的优先级。

```
#include<queue>
#include<vector>
int GetMidNumNoSort2(int *arr, int size){
    assert(arr);
    int len = (size + 1) / 2; //奇数个元素
    struct Compare //建小堆 {
        int operator()(int left, int right) {
            return left > right;
        }
    };
    priority_queue<int, vector<int>, Compare> heap; //先以整个数组的前len个元素建小堆
    for (int i = 0; i < len; i++) {
        heap.push(arr[i]);
    }
    for (int i = len; i < size; i++) {
        if (arr[i] > heap.top()) //比堆顶元素大则更新该小堆
        {
            heap.pop();
            heap.push(arr[i]);
        }
    }
    if (!heap.empty()) {
        return heap.top();
    }
}
```

## 给定一个数组，找出这个数组中每一个数右边的第一个比它大的数

这个题目用栈可以很好的解决；

下面给出例子：9 6 5 7 3 2 1 5 9 10，返回的是 10 7 7 9 5 5 5 9 10 N。

```
#include<iostream>
#include<vector>
#include<stack>

using namespace std;

vector<int> FindRfmax(vector<int> nums){
    int len = nums.size();
    if (len == 0) return nums;
    int i = 0;
    vector<int> res(len);
    stack<int> stk;
    while (i < len){
        if (stk.empty() || nums[stk.top()]>nums[i]){
            stk.push(i++);
        }
        else{
            res[stk.top()] = nums[i];
            stk.pop();
        }
    }
    while (!stk.empty()){
        res[stk.top()] = INT_MIN;
        stk.pop();
    }
    return res;
}

void main()
{
    vector<int> input = { 9, 6, 5, 7, 3, 2, 1, 5, 9, 10 };
    vector<int> output;
    output = FindRfmax(input);
}
```

## 合并k个链表

首先把k个链表的首元素都加入最小堆中，它们会自动排好序。然后我们每次取出最小的那个元素加入我们最终结果的链表中，然后把取出元素的下一个元素再加入堆中，下次仍从堆中取出最小的元素做相同的操作，以此类推，直到堆中没有元素了，此时k个链表也合并为了一个链表，返回首节点即可

```C++
struct cmp {
    bool operator () (ListNode *a, ListNode *b) {
        return a->val > b->val;
    }
};

class Solution {  
public:
    ListNode *mergeKLists(vector<ListNode *> &lists) {  
        priority_queue<ListNode*, vector<ListNode*>, cmp> q;
        for (int i = 0; i < lists.size(); ++i) {//只加入首元素
            if (lists[i])
                q.push(lists[i]);
        }
        ListNode *head = NULL, *pre = NULL, *tmp = NULL;//pre是当前尾结点指针
        while (!q.empty()) {//取首元素最小
            tmp = q.top();
            q.pop();
            if (!pre)//说明是第一个节点
                head = tmp;
            else
                pre->next = tmp;
            pre = tmp;
            if (tmp->next)//如果最小的有下一个元素，则加入堆
                q.push(tmp->next);
        }
        return head;
    }  
};
```

## 按照字典序打印1～N的排序

```
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
int main(void)
{
    int n;
    int i,j;
    char a[1000][1000];
    char t[1000];
    int k = 0;
    scanf("%d",&n);
    for (i = 1; i <= n; i++)
    {
        _itoa(i,a[k],10);  //将数字转换为字符串存入到字符串数组a中
        k++;
    }
    for (i = 0; i < k - 1; i++) //将字符串排序
    {
        for (j = 0; j < k - 1 - i;j++)
            if (strcmp(a[j], a[j + 1]) > 0)
            {
            strcpy(t, a[j]);
            strcpy(a[j], a[j + 1]);
            strcpy(a[j+1], t);
            }
    }
    for (i = 0; i < k; i++)//输出排序后的字符串
        puts(a[i]);
    return 0;
}
```

## 手写LRU

```java
import java.util.LinkedHashMap;
import java.util.Map;

public class LRUCache<K, V> extends LinkedHashMap<K, V> {

    private static final long serialVersionUID = 1L;
    private final int CACHE_SIZE;

    public LRUCache(int cacheSize) { 
        // true 表示让 linkedHashMap按照访问顺序来进行排序，最近访问的放在头部，最老访问的放在尾部。
        super((int) Math.ceil(cacheSize / 0.75) + 1, 0.75f, true);// 这块就是设置一个hashmap的初始大小，同时最后一个true指的是让linkedhashmap按照访问顺序来进行排序，最近访问的放在头，最老访问的就在尾。
        CACHE_SIZE = cacheSize;
    }

    @Override
    protected boolean removeEldestEntry(Map.Entry<K, V> eldest) { 
        // 当map中的数据量大于指定的缓存个数的时候，就自动删除最老的数据。
        // 这个意思就是说当map中的数据量大于指定的缓存个数的时候，就自动删除最老的数据
        return size() > CACHE_SIZE;
    }
}
```
- 数组里搜第k大的数
- 非递归二分查找

- 链表相加
- 30.给我画了个图，写出深度优先遍历跟广度优先遍历
- 8，非递归完成二叉树的先序遍历（差点没写出来。。用的左神教的Morris遍历。。）
- 1、char *s1, const char *s2，删除s1中s2出现过的字符
- 2、删除单项链表中重复的节点 (1 2 2 3 3 9) -> (1 2 3 9)
- 3、求二叉树的深度
- 4、单链表判环
- 5、判断一个数是不是回文数
- 6、求一个数组的最长连续子序列
- 6、有两个链表，怎么求交点？
- 7、一副扑克牌，怎么实现随机打乱？

- 12、假设有一个排好序的数组，数字都是两个两个出现的，只有一个是单独出现的，求这个数（我说了两种方法，一是i = 0, j =1,然后步长为2，当arr[i] != arr[j]时取出i这个地方的数，面试官说不对，然后我说用二分，取中间那个数跟他两边的数进行比较，又说不让用外存，可是我也没用外存啊...然后就懵逼了）
- 5.一致性哈希的性质，算法；
- 6.说说快排，时间复杂度是多少，怎么算的；(tips：设快排复杂度为T(n)，由于一次partition复杂度为O(n)，有   T(n) = 2T(n/2) + O(n))

- 手写单链表反转，
- 设计类似于LRU算法的一个固定cache内存交换算法，要求get,set,delete,高效，重点是数据结构的选用，后来面试官说最好用hash表


- 假设在某一字段a上建立索引，搜索10<《a<100时候，索引是怎么作的？

- 反转链表。
- 找出两个字符串中的公共最长子串。
- 找出一个整数数组中出现次数最多的数。
- 判断一个字符串是不是两个有序的字符串交错组成的。
- 怎么判断链表是否有环。
- 说说动态规划。

- 给定一个数组，如何建立一个最大堆。

- 1,反转链表和两个字符串最大公共子串

- 1,打印二叉树每层最右边的节点 层序遍历

- 4：二叉树深度优先广度优先进行查找？
 1 有序数组排序，二分，复杂度
- 2 常见排序算法，说下快排过程，时间复杂度
- 3 有N个节点的满二叉树的高度。1+logN
- 4. 解决一个问题，判定两个元素是否在同一棵树上（两个元素是否相互连接）
- 5 单元点最短路的方法，时间复杂度



- 22 范围1到1000的数，原本有1000个，互不重复，现多出来1个重复的数，怎么找到他，统计次数，太慢，求和相减。
- 23 N个糖果，每次只能取1个到6个，不能不取，你先取，请问是否有必胜策略，怎么取。刚开始说不太记得了，面试官提示了几个例子，找出规律不能为7的倍数，每次取到只剩7的倍数个糖果即可。

- 3 一个矩阵，从左上角到右下角，每个位置有一个权值。可以上下左右走，到达右下角的路径权值最小怎么走。
先说了一下dfs递归实现。面试官说要优化。
说了一下用迪杰斯特拉的思路，说可以。
- 4 四辆小车，每辆车加满油可以走一公里，问怎么能让一辆小车走最远。说了好几种方案，面试官引导我优化了一下，但是还是不满意，最后他说跳过。

算法题目一道：栈思想，处理字符串

手写代码 回形矩阵

最大连续数字串

o(n)时间，1个变量实现洗牌

不用变量交换两个整型有什么方式，实现一下。

写一个优化版本的快排

### 设计一个可以满足高效率获取第k大和前k个大的元素的数据结构

- 最小堆的数据结构来解决
- 最顶端是最小值，再次遇到比它大的值，就可以入堆，入堆后重新调整堆，将小的值pass掉。
- 这样我们就可以选出最大的前K个数据了。
- 假若我们要找出N个数据中最小的前k个数据，就要用最大堆了。