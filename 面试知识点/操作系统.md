# 操作系统笔试题


多进程通信、同步方式
死锁应该怎么调试
- 多线程通信和同步机制：加锁、信号量、条件变量

- 14 CPU的执行方式

- 线程死锁。
- 进程的通信方式。

- 9，什么情况下会发生死锁，解决策略有哪些？

- 7.用户态和内核态
- 协程的概念
- 线程之间的同步，我说可以用加锁实现
- 16.cpu调优，io调优，内存调优
- 17.讲讲内部碎片，外部碎片，如何解决

- 21.讲讲ftok函数，底层如何实现的
- 22.讲讲你了解的进程调度

- 24.讲讲你用过的所有锁，除了互斥锁与读写锁
- 25.讲讲自旋锁，递归锁，乐观锁，悲观锁
- 9.进程地址空间分布？为什么要有？如何管理？系统调用？



- 多进程与多线程的区别
进程的地址空间

共享内存使用

操作系统内存管理、虚拟分页内存管理
cpp分配内存有哪几种方式


## 虚拟内存

- 解放物理空间的存储管理, 使得数据被分配的地址与逻辑上程序执行的上下文解耦。
- 提供进程之间的地址空间隔离，防止进程访问地址越界或非法。
- 在多进程中，应避免进程的虚拟空间地址映射到相同的物理空间地址。

## 什么是死锁？

如果一个进程集合里面的每个进程都在等待这个集合中的其他一个进程（包括自身）才能继续往下执行，若无外力他们将无法推进，这种情况就是死锁，处于死锁状态的进程称为死锁进程

## 产生死锁的四个必要条件？

- （1）互斥条件：进程对所分配到的资源不允许其他进程进行访问，若其他进程访问该资源，只能等待，直至占有该资源的进程使用完成后释放该资源
- （2）请求和保持条件：进程获得一定的资源之后，又对其他资源发出请求，但是该资源可能被其他进程占有，此事请求阻塞，但又对自己获得的资源保持不放
- （3）不可剥夺条件：是指进程已获得的资源，在未完成使用之前，不可被剥夺，只能在使用完后自己释放
- （4）环路等待条件：是指进程发生死锁后，必然存在一个进程--资源之间的环形链

## 文件权限

0～9位符号说明： 第0位：- 表示普通文件，d表示目录。 1～3位：表示文件所有者权限，r可读，w可写，x可执行，-表示无此权限；比如：r-x表示可读不可写可执行（3个字母顺序是固定的，哪个位置上是 - 就说明无此权限）。 4～6位：表示文件所在组成员权限，内容与1～3位一致。 7～9位：表示其他组成员权限，内容与1～3位一致。rwx分别为421

## 计算机为什么要用补码？
化减为加：由于计算中的CPU只有加法器，没有减法器。
## 计算机内部的存储结构？
- 寄存器
- 高速缓存cache
- 内存
- 硬盘
- 外部存储
## 虚拟内存和物理内存的区别？
- 物理内存（内存条）：当打开程序时，系统会将这些程序加载到物理内存上。
- 虚拟内存（硬盘）：虚拟的不是物理内存，而是代替物理内存行使存储的功能，物理内存的运行程序的功能是无法用虚拟内存来完成的。
- 物理内存与虚拟内存的关系：当运行程序过多，物理内存不够用时，系统会将一部分硬盘空间当内存使用，这部分空间就是虚拟内存。
- 虚拟地址空间（作用：解决物理内存稀缺问题）：系统为每个进程所分配的4GB虚拟地址空间（32位系统），用来存放进程的虚拟地址，再通过MMU（内存管理单元）将虚拟地址映射到物理内存地址。
## 多线程同步，什么时候用自旋锁，什么时候用互斥锁
- 在多任务操作系统中，同时运行的多个任务可能都需要使用同一种资源。
- 在线程里也有这么一把锁——互斥锁（mutex），互斥锁是一种简单的加锁的方法来控制对共享资源的访问，互斥锁只有两种状态,即上锁( lock )和解锁( unlock )。
- 自旋锁与互斥量功能一样，唯一一点不同的就是互斥量阻塞后休眠让出cpu，而自旋锁阻塞后不会让出cpu，会一直忙等待，直到得到锁。
- 自旋锁的使用场景：锁的持有时间比较短，或者说小于2次上下文切换的时间。




## 并发和并行区别
- 并行是同时做多件事情
- 并发则是在线程这个模型下产生的概念。并发表示同时发生了多件事情，通过时间片切换，哪怕只有单一的核心，也可以实现“同时做多件事情”这个效果。
## 一个进程，有十个线程，其中一个线程fork后，子进程有几个线程

## 乐观锁和悲观锁
- 悲观锁：总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程）。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。
- 乐观锁：总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和CAS算法实现。乐观锁适用于多读的应用类型，这样可以提高吞吐量。


## 死锁预防（破坏产生死锁的必要条件）

- 1.破坏互斥条件，即某个资源在一段时间内只能由一个进程占有，不能同时被两个或两个以上的进程占有。
- 2.破坏占有和等待条件，进程至少已经占有一个资源，但又申请新的资源；由于该资源已被另外进程占有，此时该进程阻塞；但是，它在等待新资源之时，仍继续占用已占有的资源。
- 3.破坏不可抢占条件，进程所获得的资源在未使用完毕之前，资源申请者不能强行地从资源占有者手中夺取资源，而只能由该资源的占有者进程自行释放。
- 4.破坏环路等待，形成一个进程循环等待环

## 死锁避免

- 1.安全状态
- 2.单个资源的银行家算法
- 3.多个资源的银行家算法

## 死锁的解除

- 资源剥夺法。挂起某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程。但应防止被挂起的进程长时间得不到资源，而处于资源匮乏的状态。
- 撤销进程法。强制撤销部分、甚至全部死锁进程并剥夺这些进程的资源。撤销的原则可以按进程优先级和撤销进程代价的高低进行。
- 进程回退法。让一（多）个进程回退到足以回避死锁的地步，进程回退时自愿释放资源而不是被剥夺。要求系统保持进程的历史信息，设置还原点。






## 实现读写锁

```
void Read()
{
    Wait(condition);

    Lock(mutex);
    if(0 == Count++)
        Lock(semaphore);
    UnLock(mutex);

    // 读取数据

    Lock(mutex);
    if(0 == --Count)
        UnLock(semaphore);
    UnLock(mutex);
}

void Write()
{
    Destroy(condition);
    Lock(semaphore);

    // 写入数据

    UnLock(semaphore);
    Create(condition);
}
```

