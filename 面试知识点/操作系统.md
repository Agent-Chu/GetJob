# 操作系统笔试题

- 33.strace指令
- Linux命令你知道哪些？说说他们的作用
多进程通信、同步方式
死锁应该怎么调试
- 多线程通信和同步机制：加锁、信号量、条件变量
- 7 Linux的cpu 100怎么排查，top jstack，日志，gui工具
- 8 Linux大文件怎么查某一行的内容。
- 14 CPU的执行方式
- 15 代码中遇到进程阻塞，进程僵死，内存泄漏等情况怎么排查。通过ps查询状态，分析dump文件等方式排查。
- 16 Linux了解么，查看进程状态ps，查看cpu状态 top。查看占用端口的进程号netstat grep
- 进程和线程的区别。
- 线程死锁。
- 进程的通信方式。
- gdb用过哪些指令，在其中怎么查看线程的运行情况
- linux 文件查找指令
- top显示出来的系统信息都是什么含义
- 9，什么情况下会发生死锁，解决策略有哪些？
- 7.查内存泄露用什么工具？自己使用过么
- 7.用户态和内核态
- 协程的概念
- 线程之间的同步，我说可以用加锁实现
- 16.cpu调优，io调优，内存调优
- 17.讲讲内部碎片，外部碎片，如何解决
- 18.讲讲Linux内存管理
- 21.讲讲ftok函数，底层如何实现的
- 22.讲讲你了解的进程调度
- 23.Linux下线程安全
- 24.讲讲你用过的所有锁，除了互斥锁与读写锁
- 25.讲讲自旋锁，递归锁，乐观锁，悲观锁
- 9.进程地址空间分布？为什么要有？如何管理？系统调用？

- Linux下查看程序内存状况
答：top指令可以查看按内存大小排序的查询内存状况，或者查看/proc/pid/status文件，这个文件会记录进程id所代表的进程的内存状态

- linux下抓过指令
- linux下查看IO占用情况
- 5.进程间通信?哪个最快?为什么?
- 多进程与多线程的区别
进程的地址空间

共享内存使用

操作系统内存管理、虚拟分页内存管理
cpp分配内存有哪几种方式

## 守护进程

- 守护进程也被称为精灵进程。
- （1）它是运行在后台的一种特殊进程。
- （2）它独立于控制终端，所以不能与用户进行直接交互。
- （3）它周期性的执行某种任务或等待处理某些发生的事件。
- （4）它不受用户登录注销的影响，一直在运行着。其它进程都是在用户登录或程序运行后才创建。
- （1）Linux中的大多数服务器都是通过守护进程来实现的。如ssh服务器用于远程连接，ftp服务器。
- （2）守护进程可以完成很多系统任务，如作业规划进程crond用于设置定时任务等。
- 可以通过ps axj命令查看系统中的守护进程。守护进程通常是以d结尾的名字，表示Daemon。

## 进程间通信方式

- 管道（Pipe）：管道可用于具有亲缘关系进程间的通信，允许一个进程和另一个与它有共同祖先的进程之间进行通信。速度慢，容量有限

- 命名管道（named pipe）：命名管道克服了管道没有名字的限制，因此，除具有管道所具有的功能外，它还允许无亲缘关系进程间的通信。命名管道在文件系统中有对应的文件名。命名管道通过命令mkfifo或系统调用mkfifo来创建。

- 信号（Signal）：信号是比较复杂的通信方式，用于通知接受进程有某种事件发生，除了用于进程间通信外，进程还可以发送信号给进程本身；linux除了支持Unix早期信号语义函数sigal外，还支持语义符合Posix.1标准的信号函数sigaction（实际上，该函数是基于BSD的，BSD为了实现可靠信号机制，又能够统一对外接口，用sigaction函数重新实现了signal函数）。

- 消息队列：消息队列是消息的链接表，包括Posix消息队列system V消息队列。有足够权限的进程可以向队列中添加消息，被赋予读权限的进程则可以读走队列中的消息。消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺陷，容量受到系统限制，且要注意第一次读的时候，要考虑上一次没有读完数据的问题。

- 共享内存：使得多个进程可以访问同一块内存空间，是最快的可用IPC形式。是针对其他通信机制运行效率较低而设计的。往往与其它通信机制，如信号量结合使用，来达到进程间的同步及互斥。

- 内存映射（mapped memory）：内存映射允许任何多个进程间通信，每一个使用该机制的进程通过把一个共享的文件映射到自己的进程地址空间来实现它。

- 信号量（semaphore）：主要作为进程间以及同一进程不同线程之间的同步手段。不能传递复杂消息，只能用来同步

- 套接字（Socket）：套接字是一种进程间通信的方法，不同于以往介绍的的进程通信方法的是，它并不局限于同一台计算机的资源，例如共享内容或者消息队列。一台机器上的进程可以使用套接字与另一台机器上的进程通信。因此客户与服务器可以分散到网络中。同一台机器的进程间也可以用套接字通信。

- 文件锁

## 线程通信

- 由于多线程共享地址空间和数据空间，所以多个线程间的通信是一个线程的数据可以直接提供给其他线程使用，而不必通过操作系统（也就是内核的调度）。
- 锁机制：包括互斥锁、条件变量、读写锁
*互斥锁提供了以排他方式防止数据结构被并发修改的方法。
*读写锁允许多个线程同时读共享数据，而对写操作是互斥的。
*条件变量可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。
- 信号量机制(Semaphore)：包括无名线程信号量和命名线程信号量
- 信号机制(Signal)：类似进程间的信号处理

## 同步的概念

- 多个进程常常需要共同修改某些共享变量，表格，文件数据库等，协作完成一些功能。

## 进程和线程的区别

- 进程是系统进行资源调度的基本单位。是一个动态概念，竞争计算机系统资源的基本单位。
- 线程是CPU分派的基本单位，是进程的一个执行单元，是进程内科调度实体。比进程更小的独立运行的基本单位。线程也被称为轻量级进程。
- 进程具有控制表PCB，而线程也有自己的控制表TCB
- 系统在运行的时候会为每个进程分配不同的内存区域，但是不会为线程分配内存（线程所使用的资源是它所属的进程的资源），线程组只能共享资源。线程只能共享它所属进程的资源。
- 地址空间：同一进程的线程共享本进程的地址空间，而进程之间则是独立的地址空间。
- 资源拥有：同一进程内的线程共享本进程的资源如内存、I/O、cpu等，但是进程之间的资源是独立的。

## 多线程

- 哲学家就餐场景可能会发生死锁
- 继承Thread类与实现Runnable接口都可以实现多线程
- wait:释放cpu执行权，释放锁
- sleep:释放cpu执行权，不释放锁
- Stringbuffer 是线程安全的，Stringbuilder是线程不安全的
- Hashtable是线程安全的，hashmap不是线程安全的

## 虚拟内存

- 解放物理空间的存储管理, 使得数据被分配的地址与逻辑上程序执行的上下文解耦。
- 提供进程之间的地址空间隔离，防止进程访问地址越界或非法。
- 在多进程中，应避免进程的虚拟空间地址映射到相同的物理空间地址。

## 什么是死锁？

如果一个进程集合里面的每个进程都在等待这个集合中的其他一个进程（包括自身）才能继续往下执行，若无外力他们将无法推进，这种情况就是死锁，处于死锁状态的进程称为死锁进程

## 产生死锁的四个必要条件？

- （1）互斥条件：进程对所分配到的资源不允许其他进程进行访问，若其他进程访问该资源，只能等待，直至占有该资源的进程使用完成后释放该资源
- （2）请求和保持条件：进程获得一定的资源之后，又对其他资源发出请求，但是该资源可能被其他进程占有，此事请求阻塞，但又对自己获得的资源保持不放
- （3）不可剥夺条件：是指进程已获得的资源，在未完成使用之前，不可被剥夺，只能在使用完后自己释放
- （4）环路等待条件：是指进程发生死锁后，必然存在一个进程--资源之间的环形链

## 文件权限

0～9位符号说明： 第0位：- 表示普通文件，d表示目录。 1～3位：表示文件所有者权限，r可读，w可写，x可执行，-表示无此权限；比如：r-x表示可读不可写可执行（3个字母顺序是固定的，哪个位置上是 - 就说明无此权限）。 4～6位：表示文件所在组成员权限，内容与1～3位一致。 7～9位：表示其他组成员权限，内容与1～3位一致。rwx分别为421

## 计算机为什么要用补码？
化减为加：由于计算中的CPU只有加法器，没有减法器。
## 计算机内部的存储结构？
- 寄存器
- 高速缓存cache
- 内存
- 硬盘
- 外部存储
## 虚拟内存和物理内存的区别？
- 物理内存（内存条）：当打开程序时，系统会将这些程序加载到物理内存上。
- 虚拟内存（硬盘）：虚拟的不是物理内存，而是代替物理内存行使存储的功能，物理内存的运行程序的功能是无法用虚拟内存来完成的。
- 物理内存与虚拟内存的关系：当运行程序过多，物理内存不够用时，系统会将一部分硬盘空间当内存使用，这部分空间就是虚拟内存。
- 虚拟地址空间（作用：解决物理内存稀缺问题）：系统为每个进程所分配的4GB虚拟地址空间（32位系统），用来存放进程的虚拟地址，再通过MMU（内存管理单元）将虚拟地址映射到物理内存地址。
## 多线程同步，什么时候用自旋锁，什么时候用互斥锁
- 在多任务操作系统中，同时运行的多个任务可能都需要使用同一种资源。
- 在线程里也有这么一把锁——互斥锁（mutex），互斥锁是一种简单的加锁的方法来控制对共享资源的访问，互斥锁只有两种状态,即上锁( lock )和解锁( unlock )。
- 自旋锁与互斥量功能一样，唯一一点不同的就是互斥量阻塞后休眠让出cpu，而自旋锁阻塞后不会让出cpu，会一直忙等待，直到得到锁。
- 自旋锁的使用场景：锁的持有时间比较短，或者说小于2次上下文切换的时间。

## 线程间共享的资源
- a. 堆  由于堆是在进程空间中开辟出来的，所以它是理所当然地被共享的；因此new出来的都是共享的（16位平台上分全局堆和局部堆，局部堆是独享的）
- b. 全局变量 它是与具体某一函数无关的，所以也与特定线程无关；因此也是共享的
- c. 静态变量 虽然对于局部变量来说，它在代码中是“放”在某一函数中的，但是其存放位置和全局变量一样，存于堆中开辟的.bss和.data段，是共享的
- d. 文件等公用资源  这个是共享的，使用这些公共资源的线程必须同步。Win32 提供了几种同步资源的方式，包括信号、临界区、事件和互斥体。
## 线程间独享的资源
a. 栈 栈是独享的
b. 寄存器  这个可能会误解，因为电脑的寄存器是物理的，每个线程去取值难道不一样吗？其实线程里存放的是副本，包括程序计数器PC
## 一个进程能不能访问另一个进程的地址
- 共享内存
## 创建进程调用的是OS哪些方法
- fork：允许一进程（父进程）创建一新进程（子进程）。具体做法是，新的子进程几近于对父进程的翻版：子进程获得父进程的栈、数据段、堆和执行文本段的拷贝。可将此视为把父进程一分为二。
- exit(status)：终止一进程，将进程占用的所有资源（内存、文件描述符等）归还内核，交其进行再次分配。参数 status 为一整型变量，表示进程的退出状态。父进程可使用系统调用 wait() 来获取该状态。
- wait(&status)目的有二：其一，如果子进程尚未调用 exit() 终止，那么 wait 会挂起父进程直至子进程终止；其二，子进程的终止状态通过 wait 的 status 参数返回。
- execve(pathname, argv, envp) 加载一个新程序（路径名为 pathname，参数列表为 argv，环境变量列表为 envp）到当前进程的内存。这将丢弃现存的程序文本段，并为新程序重新创建栈、数据段以及堆。通常将这一动作称为执行一个新程序。
## 并发和并行区别
- 并行是同时做多件事情
- 并发则是在线程这个模型下产生的概念。并发表示同时发生了多件事情，通过时间片切换，哪怕只有单一的核心，也可以实现“同时做多件事情”这个效果。
## 一个进程，有十个线程，其中一个线程fork后，子进程有几个线程
## 多进程和多线程的区别
- 线程的划分尺度小于进程，使得多线程程序的并发性高。
- 进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。
- 线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。
- 从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。
## 乐观锁和悲观锁
- 悲观锁：总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程）。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。
- 乐观锁：总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和CAS算法实现。乐观锁适用于多读的应用类型，这样可以提高吞吐量。
## Linux 查看内存
- cat /proc/meminfo

## 死锁预防（破坏产生死锁的必要条件）

- 1.破坏互斥条件，即某个资源在一段时间内只能由一个进程占有，不能同时被两个或两个以上的进程占有。
- 2.破坏占有和等待条件，进程至少已经占有一个资源，但又申请新的资源；由于该资源已被另外进程占有，此时该进程阻塞；但是，它在等待新资源之时，仍继续占用已占有的资源。
- 3.破坏不可抢占条件，进程所获得的资源在未使用完毕之前，资源申请者不能强行地从资源占有者手中夺取资源，而只能由该资源的占有者进程自行释放。
- 4.破坏环路等待，形成一个进程循环等待环

## 死锁避免

- 1.安全状态
- 2.单个资源的银行家算法
- 3.多个资源的银行家算法

## 死锁的解除

- 资源剥夺法。挂起某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程。但应防止被挂起的进程长时间得不到资源，而处于资源匮乏的状态。
- 撤销进程法。强制撤销部分、甚至全部死锁进程并剥夺这些进程的资源。撤销的原则可以按进程优先级和撤销进程代价的高低进行。
- 进程回退法。让一（多）个进程回退到足以回避死锁的地步，进程回退时自愿释放资源而不是被剥夺。要求系统保持进程的历史信息，设置还原点。

## 怎么开启一个线程
使用go关键字
## 线程运行完后会怎样，会被回收吗
执行完任务后，线程会被销毁
## 设计一个线程池

- 线程池即预先创建线程的技术，一个线程执行完后重新放回不会销毁掉提高了线程的利用率。
- 由于我们要使用线程来执行任务的时候直接从线程池中去现成的所以提高了程序的相应速度。
- 线程池可以对里面的线程进行管理，至于如何管理XXXX（如何销毁线程、如何结束线程状态等等）。

- 线程池的大小
- 执行任务队列
- 线程池满了新任务的执行策略
- 工作线程空闲后存活时间（如果想提高线程利用率提议调大该时间）。

## 解释下内存中堆和栈和静态区
堆区:
1.存储的全部是对象，每个对象都包含一个与之对应的class的信息。(class的目的是得到操作指令)
2.jvm只有一个堆区(heap)被所有线程共享，堆中不存放基本类型和对象引用，只存放对象本身.
3.一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收 。

栈区:
1.每个线程包含一个栈区，栈中只保存基础数据类型的对象和自定义对象的引用(不是对象)，对象都存放在堆区中
2.每个栈中的数据(原始类型和对象引用)都是私有的，其他栈不能访问。
3.栈分为3个部分：基本类型变量区、执行环境上下文、操作指令区(存放操作指令)。
4.由编译器自动分配释放 ，存放函数的参数值，局部变量的值等．

静态区/方法区:
1.方法区又叫静态区，跟堆一样，被所有的线程共享。方法区包含所有的class和static变量。
2.方法区中包含的都是在整个程序中永远唯一的元素，如class，static变量。
3.全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域， 未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。
## 实现读写锁

```
void Read()
{
    Wait(condition);

    Lock(mutex);
    if(0 == Count++)
        Lock(semaphore);
    UnLock(mutex);

    // 读取数据

    Lock(mutex);
    if(0 == --Count)
        UnLock(semaphore);
    UnLock(mutex);
}

void Write()
{
    Destroy(condition);
    Lock(semaphore);

    // 写入数据

    UnLock(semaphore);
    Create(condition);
}
```

## 方法sleep()和wait()

- sleep()是Thread类中的方法，而wait()则是Object类中的方法。
- sleep()方法导致了程序（线程）暂停，但是他的监控状态依然保持着，当指定的时间到了又会自动恢复运行状态。在调用sleep()方法的过程中，线程不会释放对象锁。
- wait()方法会导致线程放弃对象锁，进入等待此对象的等待锁定池，只有针对此对象调用notify()方法后本线程才进入对象锁定池准备获取对象锁进入运行状态。注意是准备获取对象锁进入运行状态，而不是立即获得