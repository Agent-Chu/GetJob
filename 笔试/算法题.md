 给出一个非空的字符串，判断这个字符串是否是由它的一个子串进行多次首尾拼接构成的。
例如，"abcabcabc"满足条件，因为它是由"abc"首尾拼接而成的，而"abcab"则不满足条件。 

#include <iostream>
using namespace std;
int main()
{
    string str;
    cin>>str;
    int fPos = 0,rPos =1,sLen = 1;
    int len = str.size();
    for(;rPos < len ; rPos++ ){
        if(str[fPos] == str[rPos]){//如果匹配，则fPos++
            fPos++;
        }else{
            sLen =  rPos+1;//如果不匹配，则认为0~rPos之间为子串，其长度为rPos+1
            fPos = 0;
        }
        if(fPos == sLen && rPos != len -1){
            fPos = 0;//如果匹配到当前子串的结尾，则从子串开头匹配。
        }
    }
    if(fPos != sLen ){
        cout<<"false"<<endl;
    }else{
        cout<<str.substr(0,sLen)<<endl;
    }
    return 0;
}

 给出一个正整数n，请给出所有的包含n个'('和n个')'的字符串，使得'('和')'可以完全匹配。
例如：
'(())()'，'()()()' 都是合法的；
'())()('是不合法的。
请按照__字典序__给出所有合法的字符串。 


LeetCode22原题。

思路可以参照：https://blog.csdn.net/zjc_game_coder/article/details/78520742
代码可以参照：http://www.cnblogs.com/grandyang/p/4444160.html

 给出一个整数n，将n分解为至少两个整数之和，使得这些整数的乘积最大化，输出能够获得的最大的乘积。
例如：
2=1+1，输出1；
10=3+3+4，输出36。 

import java.util.Scanner;
public class Main {
    /*
     * 举例计算11,11=5+6,5*6=30,11=3+4+5,3*4*4=48,11=2+3+3+3,2*3*3*3=54,11=1
     */
    static int p(int num) {
        int maxMul = 1;
        //i表示分解为i个数的加法，这些数相差不超过1.在所有的分解法中选择乘积最大的。
        for (int i = 2; i < num; i++) {
            int rem = num % i;
            int quo = num / i;
            int mul = 1;
            // int j=1;
            for (int j = 1; j <= i - rem; j++)
                mul *= quo;
            for (int j = 1; j <= rem; j++)
                mul *= (quo + 1);
            if (mul > maxMul)
                maxMul = mul;
            else
                return maxMul;
        }
        return maxMul;
    }
    public static void main(String[] args) {
        // TODO Auto-generated method stub
//        int num=2;
//        num=10;
        Scanner scanner=new Scanner(System.in);
//        返回：从输入信息扫描的 int
        int num=scanner.nextInt();
        System.out.println(p( num));
         
    }
}