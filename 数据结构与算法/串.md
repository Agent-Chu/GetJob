# 串

- [字符串](#字符串)
- [字符串存储结构](#字符串存储结构)
- [朴素模式匹配算法](#朴素模式匹配算法)
- [KMP匹配算法](#KMP匹配算法)

---

## 字符串

- 串，零个或者多个字符组成的有限序列，也叫字符串
- 前几个字符一样，长度相同的大
- 前几个字符一样，比较第一个不一样的字符的ASCII码的大小

## 字符串存储结构

### 顺序存储

- 需要预定义长度
- 最后以为是\0，表示字符串结束
- 不计入长度

### 链式存储

- 一个节点存一个字符会浪费空间
- 可以用一个节点存多个字符，不满的用#填充
- 性能不如顺序存储

## 朴素模式匹配算法

- 子串的定位操作：串的模式匹配
- 朴素模式匹配，对比，不相同向后移动
- 队主串的每一个字符作为子串开头，与子串对比，对主串循环，直至匹配成功

```c++
//S主串 T子串 pos主串开始查找位置
int Index(String S, String T, int pos){
    int i = pos;//主串当前下标
    int j = 1;//子串当前下标
    while(i<=S[0] && j<=T[0]){//0存放长度
        if(S[i] == T[j]){
            i++;
            j++;
        }
        else{
            i = i-j+2;//主串的下一位
            j = 1;
        }
    }
    if(j > T[0]){//因为最后一个相等说明匹配成功，但是还是会+1
        return i - T[0];
    }
    else{
        return 0;
    }
}
```

## KMP匹配算法

- 主串不回溯，等于i值不可以变小
- 取决于子串的结构，结构中是否有重复的

next字符串：

- next数组：子串各个位置的j值变化，长度等于子串长度
- 字符串下标从1开始，当j=1时，next[j]=0
- 当j=n时，考虑字符串1到n-1的子串，如果子串的前后缀有k个字符相等，则next[j]=k+1
- 其他情况next[j]=1

```c++
void get_next(String T, int *next){
    int i = 1;
    int j = 0;
    next[1]=0;
    while(i<T[0]){
        if(j==0 || T[i] == T[j]) /* T[i]表示后缀的单个字符，T[j]表示前缀的单个字符 */
        {
            ++i;
            ++j;
            next[i] = j;
        }
        else
            j= next[j];/* 若字符不相同，则j值回溯，从头开始算前缀 */
    }
}
```

```c++
/* 返回子串T在主串S中第pos个字符之后的位置。若不存在，则函数返回值为0。 */
/*  T非空，1≤pos≤StrLength(S)。 */
int Index_KMP(String S, String T, int pos){
    int i = pos;/* i用于主串S中当前位置下标值，若pos不为1，则从pos位置开始匹配 */
    int j = 1;/* j用于子串T中当前位置下标值 */
    int next[255];/* 定义一next数组 */
    get_next(T, next);/* 对串T作分析，得到next数组 */
    while (i <= S[0] && j <= T[0]) /* 若i小于S的长度并且j小于T的长度时，循环继续 */
    {
        if (j==0 || S[i] == T[j])/* 两字母相等则继续，与朴素算法增加了j=0判断 */
        {
            ++i;
            ++j;
        }
        else/* 指针后退重新开始匹配 */
            j = next[j];/* j退回合适的位置，i值不变 */
    }
    if (j > T[0])
        return i-T[0];
    else
        return 0;
}
```

```c++
/* 求模式串T的next函数修正值并存入数组nextval */
void get_nextval(String T, int *nextval)
{
      int i,j;
      i=1;
      j=0;
      nextval[1]=0;
      while (i<T[0])  /* 此处T[0]表示串T的长度 */
     {
        if(j==0 || T[i]== T[j])     /* T[i]表示后缀的单个字符，T[j]表示前缀的单个字符 */
        {
              ++i;  
            ++j;  
            if (T[i]!=T[j])      /* 若当前字符与前缀字符不同 */
                nextval[i] = j;    /* 则当前的j为nextval在i位置的值 */
              else
                nextval[i] = nextval[j];    /* 如果与前缀字符相同，则将前缀字符的 */
                                            /* nextval值赋值给nextval在i位置的值 */
        }
        else
            j= nextval[j];            /* 若字符不相同，则j值回溯 */
      }
}
```