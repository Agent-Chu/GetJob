# 目录

- [线性表](#线性表)
  - [顺序存储结构](#顺序存储结构)
  - [链式存储结构](#链式存储结构)
  - [静态链表](#静态链表)
  - [循环链表](#循环链表)
  - [双向链表](#双向链表)

---

## 线性表

**定义：** 零个或多个数据元素的有限序列。

**关键概念：** 直接前驱元素，直接后驱元素。

### 顺序存储结构

连续的地址单元存储，C中可以用一维数组来实现，线性表的长度应该小于等于数组长度。

地址计算方法：LOC(ai) = LOC(a1)+(i-1)*c

- [线性表顺序存储结构code](https://github.com/ChuangLiu727/GetJob/blob/master/数据结构与算法/code/线性表顺序存储结构.cpp)

### 链式存储结构

单链表：每个结点只有一个指针域

链表是动态数据结构，创建时无需知道链表的长度，添加节点只需要为新节点分配新的内存，整个数据结构没有闲置内存。

- [线性表链式存储结构code](https://github.com/ChuangLiu727/GetJob/blob/master/数据结构与算法/code/线性表链式存储结构code.cpp)

### 静态链表

用数组描述的链表，两种方法：结构体数组和两个平行数组，分别记录data和next

结构体数组中的第一个元素（下标为0）的next存放未分配的空间的第一个节点的下标

最后一个元素的next存放链表第一个节点的下标，如果整个链表为空时，则为0

插入需要设计一个函数模拟malloc，用于返回第一个空闲的下表，并且更新数组[0]的next

同理，删除需要自己设计一个函数模拟free，修改要free的下标的next，并且更新数组[0]的next

- [静态链表code](https://github.com/ChuangLiu727/GetJob/blob/master/数据结构与算法/code/静态链表code.cpp)

### 循环链表

- 将单链表中的终端节点的指针，由空指针改成指向头结点
- 循环链表一定需要头结点
- 判断链表结束：判断 p->next 是不是等于头结点

如何用O(1)时间访问最后节点和头结点：

- 用指向终端节点的尾指针`rear`来表示循环链表
- 查找终端节点就是`rear`
- 开始节点就是`rear->next->next`

### 双向链表

- 在单链表的每个节点中，在设置一个指向前驱节点的指针域

存储结构：

```c++
typedef struct DulNode{
    int data;
    struct DulNode *prior;
    struct DulNode *next;
} DulNode, *DuLinkList;
```

插入操作

```c++
s->prior = p;       //把p的值赋给s的前驱
s->nest = p->next;  //把p->next的值赋给s的后驱
p->next->prior = s; //把s赋给p->next的前驱
p->next = s;        //把s的值赋给p的后驱
```

删除操作

```c++
p->prior->next = p->next;
p->next->prior = p->prior;
free(p);
```

## 单向链表和双向链表的原理和特点、使用中（增删查）的优缺点

- 单向链表：只有一个指向下一个节点的指针。
- 优点：单向链表增加删除节点简单。遍历时候不会死循环；
- 缺点：只能从头到尾遍历。只能找到后继，无法找到前驱，也就是只能前进。
- 适用于节点的增加删除。

- 双向链表：有两个指针，一个指向前一个节点，一个后一个节点。
- 优点：可以找到前驱和后继，可进可退；
- 缺点：增加删除节点复杂，多需要分配一个指针存储空间。
- 适用于需要双向查找节点值的情况。