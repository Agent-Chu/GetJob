### 数据结构了解过吗？hashmap底层是怎么实现的？

答：hashmap的话是数组+链表实现的，通过hash散列化来决定进哪一个数组，如果有的话就“挂”在链表的最后面。

### 哈希表的设计

- 存放的是字典数据类型，即（key，value）的数据，是根据key 去存取value。

### hash表中的冲突

- 开放定址法：依靠数组中的空位解决碰撞冲突
  - 线性探测法：直接检测散列表的下一个位置（即索引值加1），如果仍冲突，继续；
  - 二次探测法：即H + 1^2, H + 2^2, H + 3^2…
  - 伪随机探测
- 再哈希法：使用多个哈希函数，第一个冲突时，使用第二个哈希函数，知道不冲突为止；
- 链地址法：将所有哈希地址相同的关键字，都链接到同一个链表中；

### HashMap底层，扩容机制

- map的底层结构是hmap（即hashmap的缩写），核心元素是一个由若干个桶（bucket，结构为bmap）组成的数组，每个bucket可以存放若干元素（通常是8个），key通过哈希算法被归入不同的bucket中。
- 当超过8个元素需要存入某个bucket时，hmap会使用extra中的overflow来拓展该bucket。
- 随着元素的增加，在一个bucket链中寻找特定的key会变得效率低下，所以在插入的元素个数/bucket个数达到某个阈值（当前设置为6.5，实验得来的值）时，map会进行扩容，
- 扩容完成后，每个hash对应两个bucket（一个新的一个旧的）。oldbucket不会立即被转移到新的bucket下，而是当访问到该bucket时，会调用growWork方法进行迁移，growWork方法会将oldbucket下的元素rehash到新的bucket中。随着访问的进行，所有oldbucket会被逐渐移动到bucket中。

### 问：hashcode一样怎么办？hashcode和equals的区别？

- 通过equals方法判断真正的内容。
1、如果两个对象相等（equals），那么他们一定有相同的哈希值（hash code）。
2、如果两个对象的哈希值相等，那么这两个对象有可能相等也有可能不相等。（需要再通过equals来判断）

## 一致性哈希

- 在解决分布式系统中负载均衡的问题时候可以使用Hash算法让固定的一部分请求落到同一台服务器上，这样每台服务器固定处理一部分请求（并维护这些请求的信息），起到负载均衡的作用。
- 但是普通的余数hash（hash(比如用户id)%服务器机器数）算法伸缩性很差，当新增或者下线服务器机器时候，用户id与服务器的映射关系会大量失效。一致性hash则利用hash环对其进行了改进。