# 死锁

- [概念](#概念)
- [必要条件](#必要条件)
- [鸵鸟策略](#鸵鸟策略)
- [死锁检测与死锁恢复](#死锁检测与死锁恢复)
- [死锁预防](#死锁预防)
- [死锁避免](#死锁避免)
- [死锁解除](#死锁解除)
- [死锁调试](#死锁调试)

---

## 概念

是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。
处于死锁状态的进程称为死锁进程
活锁

活锁指的是任务或者执行者没有被阻塞，由于某些条件没有满足，导致一直重复尝试，失败，尝试，失败。

## 必要条件

- 互斥：每个资源要么已经分配给了一个进程，要么就是可用的。一个资源每次只能被一个进程使用
- 占有和等待(请求与保持)：已经得到了某个资源的进程可以再请求新的资源。一个进程因请求资源而阻塞时，对已获得的资源保持不放
- 不可抢占(不可剥夺)：已经分配给一个进程的资源不能强制性地被抢占，它只能被占有它的进程显式地释放。进程已获得的资源，在末使用完之前，不能强行剥夺
- 环路等待(循环等待)：有两个或者两个以上的进程组成一条环路，该环路中的每个进程都在等待下一个进程所占有的资源。

## 鸵鸟策略

把头埋在沙子里，假装根本没发生问题。

因为解决死锁问题的代价很高，因此鸵鸟策略这种不采取任务措施的方案会获得更高的性能。

当发生死锁时不会对用户造成多大影响，或发生死锁的概率很低，可以采用鸵鸟策略。

大多数操作系统，包括 Unix，Linux 和 Windows，处理死锁问题的办法仅仅是忽略它。

## 死锁检测与死锁恢复

不试图阻止死锁，而是当检测到死锁发生时，采取措施进行恢复。如果一个进程所请求的资源能够被满足，那么就让它执行，否则释放它拥有的所有资源，然后让其它能满足条件的进程执行。

### 1. 每种类型一个资源的死锁检测

通过检测资源分配图的有向图是否存在环来实现，从一个节点出发进行深度优先搜索，对访问过的节点进行标记，如果访问了已经标记的节点，就表示有向图存在环，也就是检测到死锁的发生。

### 2. 每种类型多个资源的死锁检测

有三个进程四个资源，每个数据代表的含义如下：

- E 向量：资源总量
- A 向量：资源剩余量
- C 矩阵：每个进程所拥有的资源数量，每一行都代表一个进程拥有资源的数量
- R 矩阵：每个进程请求的资源数量

进程 P<sub>1</sub> 和 P<sub>2</sub> 所请求的资源都得不到满足，只有进程 P<sub>3</sub> 可以，让 P<sub>3</sub> 执行，之后释放 P<sub>3</sub> 拥有的资源，此时 A = (2 2 2 0)。P<sub>2</sub> 可以执行，执行后释放 P<sub>2</sub> 拥有的资源，A = (4 2 2 1) 。P<sub>1</sub> 也可以执行。所有进程都可以顺利执行，没有死锁。

算法总结如下：

每个进程最开始时都不被标记，执行过程有可能被标记。当算法结束时，任何没有被标记的进程都是死锁进程。

1. 寻找一个没有标记的进程 P<sub>i</sub>，它所请求的资源小于等于 A。
2. 如果找到了这样一个进程，那么将 C 矩阵的第 i 行向量加到 A 中，标记该进程，并转回 1。
3. 如果没有这样一个进程，算法终止。

### 3. 死锁恢复

- 利用抢占恢复
- 利用回滚恢复
- 通过杀死进程恢复

## 死锁预防

在程序运行之前预防发生死锁。

### 1. 破坏互斥条件

- 例如假脱机打印机技术允许若干个进程同时输出，唯一真正请求物理打印机的进程是打印机守护进程。
- 允许某些进程(线程)同时访问某些资源，但有的资源不允许同时被访问如打印机等。
即某个资源在一段时间内只能由一个进程占有，不能同时被两个或两个以上的进程占有。

### 2. 破坏占有和等待条件

进程至少已经占有一个资源，但又申请新的资源；由于该资源已被另外进程占有，此时该进程阻塞；但是，它在等待新资源之时，仍继续占用已占有的资源。

- 一种实现方式是规定所有进程在开始执行前请求所需要的全部资源。
- 如果当前进程所需的全部资源得不到满足，则不分配任何资源。
- 只有当系统能够满足当前的全部资源得到满足时，才一次性将所有申请的资源全部分配给该进程。
- 由于运行的进程已占有了它所需的全部资源，所以不会发生占有资源又重新申请资源的现象，因此不会发生死锁。

有以下缺点：

- 在许多情况下，一个进程在执行之前不可能知道它所需的全部资源。这是由于进程在执行时是动态的，不可预测的。
- 资源利用率低。无论所分配资源何时用到，一个进程只有在占有所需的全部资源后才能执行。即使有些资源最后才被该进程用到一次，但该进程在生存期间一直占有它们，造成长期占有。
- 降低了进程的并发性。因为资源有限，又加上存在浪费，能分配到所需全部资源的进程个数必然少了。

### 3. 破坏不可抢占条件

进程所获得的资源在未使用完毕之前，资源申请者不能强行地从资源占有者手中夺取资源，而只能由该资源的占有者进程自行释放。

- 即允许进程强行从占有者那里夺取某些资源。这种预防方法实现起来困难，会降低系统性能。

### 4. 破坏环路等待

- 给资源统一编号，进程只能按编号顺序来请求资源。
- 所有进程对资源的请求必须严格按资源需要递增的顺序提出。进程占用小号资源，才能申请大号资源，就不会产生环路。
- 这种策略与前面的策略相比，资源的利用率和系统吞吐量都有很大提高。

缺点：

- 限制了进程对资源的请求，同时系统给所有资源合理编号也是件困难事，并增加了系统开销。

## 死锁避免

在程序运行时避免发生死锁。

### 1. 安全状态

定义：如果没有死锁发生，并且即使所有进程突然请求对资源的最大需求，也仍然存在某种调度次序能够使得每一个进程运行完毕，则称该状态是安全的。

安全状态的检测与死锁的检测类似，因为安全状态必须要求不能发生死锁。下面的银行家算法与死锁检测算法非常类似，可以结合着做参考对比。

### 2. 单个资源的银行家算法

一个小城镇的银行家，他向一群客户分别承诺了一定的贷款额度，算法要做的是判断对请求的满足是否会进入不安全状态，如果是，就拒绝请求；否则予以分配。

该算法需要检查申请者对资源的最大需求量，如果系统现存的各类资源可以满足申请者的请求，就满足申请者的请求。这样申请者就可很快完成其计算，然后释放它占用的资源，从而保证了系统中的所有进程都能完成，所以可避免死锁的发生。

### @3. 多个资源的银行家算法

检查一个状态是否安全的算法如下：

- 查找右边的矩阵是否存在一行小于等于向量 A。如果不存在这样的行，那么系统将会发生死锁，状态是不安全的。
- 假若找到这样一行，将该进程标记为终止，并将其已分配资源加到 A 中。
- 重复以上两步，直到所有进程都标记为终止，则状态时安全的。

如果一个状态不是安全的，需要拒绝进入这个状态。

## 死锁的解除

一旦检测出死锁，就应立即釆取相应的措施，以解除死锁。

- 资源剥夺法。挂起某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程。但应防止被挂起的进程长时间得不到资源，而处于资源匮乏的状态。
- 撤销进程法。强制撤销部分、甚至全部死锁进程并剥夺这些进程的资源。撤销的原则可以按进程优先级和撤销进程代价的高低进行。
- 进程回退法。让一（多）个进程回退到足以回避死锁的地步，进程回退时自愿释放资源而不是被剥夺。要求系统保持进程的历史信息，设置还原点。

## 实现读写锁

```
void Read()
{
    Wait(condition);

    Lock(mutex);
    if(0 == Count++)
        Lock(semaphore);
    UnLock(mutex);

    // 读取数据

    Lock(mutex);
    if(0 == --Count)
        UnLock(semaphore);
    UnLock(mutex);
}

void Write()
{
    Destroy(condition);
    Lock(semaphore);

    // 写入数据

    UnLock(semaphore);
    Create(condition);
}
```

## 死锁调试

https://www.cnblogs.com/zhuyp1015/p/3618863.html