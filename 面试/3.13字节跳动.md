# 3.13字节跳动

## 计算机网络

### TCP和UDP的区别
- TCP协议是有连接的，有连接的意思是开始传输实际数据之前TCP的客户端和服务器端必须通过三次握手建立连接，会话结束之后也要结束连接。而UDP是无连接的
- TCP协议保证数据按序发送，按序到达，提供超时重传来保证可靠性，但是UDP不保证按序到达，甚至不保证到达，只是努力交付，即便是按序发送的序列，也不保证按序送到。
- TCP协议所需资源多，TCP首部需20个字节（不算可选项），UDP首部字段只需8个字节。
- TCP有流量控制和拥塞控制，UDP没有，网络拥堵不会影响发送端的发送速率
- TCP是一对一的连接，而UDP则可以支持一对一，多对多，一对多的通信。
- TCP面向的是字节流的服务，UDP面向的是报文的服务。
### 三次握手
- A是客户端，B是服务端
- 首先 B 处于 LISTEN（监听）状态，等待客户的连接请求。
- A 向 B 发送连接请求报文，SYN=1，ACK=0，选择一个初始的序号 x。
- B 收到连接请求报文，如果同意建立连接，则向 A 发送连接确认报文，SYN=1，ACK=1，确认号为 x+1，同时也选择一个初始的序号 y。
- A 收到 B 的连接确认报文后，还要向 B 发出确认，确认号为 y+1，序号为 x+1。
- B 收到 A 的确认后，连接建立。
### TCP四次挥手
- A 发送连接释放报文，FIN=1。
- B 收到之后发出确认，此时 TCP 属于半关闭状态，B 能向 A 发送数据但是 A 不能向 B 发送数据。
- 当 B 不再需要连接时，发送连接释放报文，FIN=1。
- A 收到后发出确认，进入 TIME-WAIT 状态，等待 2 MSL（最大报文存活时间）后释放连接。
- B 收到 A 的确认后释放连接。
### 四次挥手时，第一次挥手后，客户端和服务器的TCP分别处于什么状态
- 此时 TCP 属于半关闭状态，B 能向 A 发送数据但是 A 不能向 B 发送数据。
### TCP如何保证传输的可靠性
- 校验和
- 确认应答：TCP传输的过程中，每次接收方收到数据后，都会对传输方进行确认应答。也就是发送ACK报文。这个ACK报文当中带有对应的确认序列号，告诉发送方，接收到了哪些数据，下一次的数据从哪里发。
- 序列号：TCP传输时将每个字节的数据都进行了编号，这就是序列号。
- 超时重传
- 连接管理：三次握手，四次挥手
- 流量控制
- 拥塞控制
### TCP的流量控制
- 流量控制是为了控制发送方发送速率，保证接收方来得及接收。
- 在TCP协议的报头信息当中，有一个16位字段的窗口大小。接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。
- 流量控制是点对点控制。
- TCP是双工协议，双方可以同时通信，所以发送方接收方各自维护一个发送窗和接收窗。
### TCP的拥塞控制
- 如果网络出现拥塞，分组将会丢失，此时发送方会继续重传，从而导致网络拥塞程度更高。因此当出现拥塞时，应当控制发送方的速率。这一点和流量控制很像，但是出发点不同。流量控制是为了让接收方能来得及接收，而拥塞控制是为了降低整个网络的拥塞程度。
- TCP 主要通过四个算法来进行拥塞控制：慢开始、拥塞避免、快重传、快恢复。
### udp上实现一个可靠的协议要怎么做?保证数据有序性？
- 只需要提供一个重传机制即可。
- 为每一个发送出去的udp数据包分配一个包id，每次接收方收到一个数据包时，都要回应发送方一个ack对应这个包id。协议通过这种确认机制来保证接收方能收到发送方发出的udp数据包，在发出的时候，发送方应该设置一个计时器，超时的话会重传数据包。
### Time_wait有什么用
- 客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL。
- 确保最后一个确认报文能够到达。如果 B 没收到 A 发送来的确认报文，那么就会重新发送连接释放请求报文，A 等待一段时间就是为了处理这种情况的发生。
- 等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。
### TCP server最多可以建立多少个TCP连接
- 客户端每次发起一个tcp连接时,系统会随机选取一个空闲的端口,该端口是独占的不能与其他tcp连接共享,因此理论上一台机器有多少空闲的端口,就能对外发起多少个tcp连接
- 根据tcp/ip协议,端口port使用16位无符号整数unsigned short来存储,因此本地端口一共有2^16=65536个,即0-65535,其中0~1023是预留端口,0有特殊含义不能使用,1024以下端口都是超级管理员用户(如root)才可以使用,因此就算使用root权限,一台机器最多能使用的端口也只有65535个(除去一些保留的和已被占用的端口,实际可能不足这个数).
### HTTP和TCP的关系
- HTTP协议即超文本传送协议(Hypertext Transfer Protocol )
- HTTP协议是建立在TCP协议之上的一种应用。
- HTTP连接最显著的特点是客户端发送的每次请求都需要服务器回送响应，在请求结束后，会主动释放连接。从建立连接到关闭连接的过程称为“一次连接”。
- 由于HTTP在每次请求结束后都会主动释放连接，因此HTTP连接是一种“短连接”，要保持客户端程序的在线状态，需要不断地向服务器发起连接请求。
- 通常的 做法是即时不需要获得任何数据，客户端也保持每隔一段固定的时间向服务器发送一次“保持连接”的请求，服务器在收到该请求后对客户端进行回复，表明知道客户端“在线”。若服务器长时间无法收到客户端的请求，则认为客户端“下线”，若客户端长时间无法收到服务器的回复，则认为网络已经断开。
### HTTP数据量很大，怎么发送
- 客户端把请求分几次发送，每次发送服务端能接受的最大请求大小，最后在服务端合并即可
### Socket编程
- 套接字是一种进程间通信的方法，不同于以往介绍的的进程通信方法的是，它并不局限于同一台计算机的资源，例如共享内容或者消息队列。
- 一台机器上的进程可以使用套接字与另一台机器上的进程通信。因此客户与服务器可以分散到网络中。
- 同一台机器的进程间也可以用套接字通信。
### 一个URL从浏览器输入到响应页面，整个过程是怎么样的，能讲得多详细就讲多详细。
- 1、首先，在浏览器地址栏中输入url
- 2、浏览器先查看浏览器缓存-系统缓存-路由器缓存，如果缓存中有，会直接在屏幕中显示页面内容。若没有，则跳到第三步操作。
- 3、在发送http请求前，需要域名解析(DNS解析)，解析获取相应的IP地址。
- 4、浏览器向服务器发起tcp连接，与浏览器建立tcp三次握手。
- 5、握手成功后，浏览器向服务器发送http请求，请求数据包。
- 6、服务器处理收到的请求，将数据返回至浏览器
- 7、浏览器收到HTTP响应
- 8、读取页面内容，浏览器渲染，解析html源码
- 9、生成Dom树、解析css样式、js交互
- 10、客户端和服务器交互
### HTTP的请求头，作用
- GET：获取资源，GET方法用来请求已被URI识别的资源。指定的资源经服务器端解析后返回响应内容（也就是说，如果请求的资源是文本，那就保持原样返回；如果是CGI[通用网关接口]那样的程序，则返回经过执行后的输出结果）。
- POST：传输实体文本，虽然用GET方法也可以传输实体的主体，但一般不用GET方法进行传输，而是用POST方法；虽然GET方法和POST方法很相似，但是POST的主要目的并不是获取响应的主体内容。
- HEAD：获得报文首部，HEAD方法和GET方法一样，知识不返回豹纹的主体部分，用于确认URI的有效性及资源更新的日期时间等。
- PUT：传输文件，PUT方法用来传输文件，就像FTP协议的文件上传一样，要求在请求报文的主体中包含文件内容，然后保存在请求URI指定的位置。但是HTTP/1.1的PUT方法自身不带验证机制，任何人都可以上传文件，存在安全问题，故一般不用。
- DELETE：删除文件，指明客户端想让服务器删除某个资源，与PUT方法相反，按URI删除指定资源
- OPTIONS：询问支持的方法，OPTIONS方法用来查询针对请求URI指定资源支持的方法（客户端询问服务器可以提交哪些请求方法）
- TRACE：追踪路径，客户端可以对请求消息的传输路径进行追踪，TRACE方法是让Web服务器端将之前的请求通信还给客户端的方法
- CONNECT：要求用隧道协议连接代理，CONNECT方法要求在与代理服务器通信时建立隧道，实现用隧道协议进行TCP通信。主要使用SSL（安全套接层）和TLS（传输层安全）协议把通信内容加密后经网络隧道传输
### Http断点续传
- 1、如何从断点处开始下载：System.Net.HttpWebRequest 这个对象有个AddRange（int pos）方法，该方表示在文件长度pos处开始下载。
- 2、如何找到本地已经下载部分的文件断点（上述参数pos）：使用对FielStream fs= New FileStream(path, FileMode.Open)打开文件，则断点位置即为pos=fs.Length;
- 3、如何在文件断点结尾处写入（从网络下载）数据流：fs.Seek(pos, SeekOrigin.Current);
- 4、如何保存文件：当文件还未下载完时，我们在文件末尾追加个.temp后缀，当http的流读完时我们使用File.Move(xx.zip.temp,xx.zip);//将临时文件改为正常文件后缀
### 如何判断一个IP是不是国内IP？
- 最多的办法就是前端获取到ip之后传入后台，由后台来根据ip对照表筛选判断
### http缓存
- 浏览器缓存分为强缓存和协商缓存
- 浏览器先根据这个资源的http头信息来判断是否命中强缓存。如果命中则直接加在缓存中的资源，并不会将请求发送到服务器。
- 如果未命中强缓存，则浏览器会将资源加载请求发送到服务器。服务器来判断浏览器本地缓存是否失效。若可以使用，则服务器并不会返回资源信息，浏览器继续从缓存加载资源。
- 如果未命中协商缓存，则服务器会将完整的资源返回给浏览器，浏览器加载新资源，并更新缓存。
### 提取两个海量url数据中的相同值
- 1 将AB两个文件，用相同的哈希函数，分解为1000个独立哈希值相同的小文件，这里哈希函数的设计是个重点。
- 2 哈希值不同的url必然不在序号对应的文件中，因此只要在序号对应的两个文件中进行互相匹配即可。
### session和cookie的区别
- cookie以文本格式存储在浏览器上，存储量有限；
- session存储在服务端，可以无限量存储多个变量并且比cookie更安全
### 怎么给大量url和ip去重
对每一个给定的URL，都是用一个已经建立好的Hash函数，映射到某个物理地址上。当需要进行检测URL是否重复的时候，只需要将这个URL进行Hash映射
### Http协议是一个无状态协议，那么有什么方法可以让用户保留登录的状态？
使用cookie和session都可以
### http和https的区别，

HTTP特点：
- 无状态：协议对客户端没有状态存储，对事物处理没有“记忆”能力，比如访问一个网站需要反复进行登录操作
- 无连接：HTTP/1.1之前，由于无状态特点，每次请求需要通过TCP三次握手四次挥手，和服务器重新建立连接。比如某个客户机在短时间多次请求同一个资源，服务器并不能区别是否已经响应过用户的请求，所以每次需要重新响应请求，需要耗费不必要的时间和流量。
- 基于请求和响应：基本的特性，由客户端发起请求，服务端响应
- 简单快速、灵活
- 通信使用明文、请求和响应不会对通信方进行确认、无法保护数据的完整性
HTTPS有如下特点：
- 内容加密：采用混合加密技术，中间者无法直接查看明文内容
- 验证身份：通过证书认证客户端访问的是自己的服务器
- 保护数据完整性：防止传输的内容被中间人冒充或者篡改
### https加密的过程
- 1.服务器把自己的公开密钥登录至数字证书认证机构。
- 2.数字证书认证机构用自己的私有密钥向服务器的公开密码署数字签名并颁发公钥证书。
- 3.客户端拿到服务器的公钥证书后，使用数字签名认证机构的公开密钥，向数字证书认证机构验证公钥证书上的数字签名，以确认服务器的公开密钥的真实性。
- 4.使用服务器的公开密钥对报文加密后发送。
- 5.服务器用私有密钥对报文解密。
### 消息队列作用
异步处理，应用解耦，流量削锋和消息通讯四个场景

## 数据结构

### 排序算法的稳定性
### 快速排序复杂度，实现，什么时候复杂度最大
### 各种排序算法及其效率
| 排序类型 | 排序名称 | 平均情况 | 最好情况 | 最坏情况 | 辅助空间 | 稳定性 |
| ------ | ------ | ------ | ------ | ------ | ------ | ------ |
| 插入类 | 直接插入排序 | n^2 | n | n^2 | 1 | 稳定 |
| 插入类 | 希尔排序 | nlogn ~ n^2 | n^1.3 | n^2 | 1 | 不稳定 |
| 选择类 | 简单选择 | n^2 | n^2 | n^2 | 1 | 稳定 |
| 选择类 | 堆排序 | nlogn | nlogn | nlogn | 1 | 不稳定 |
| 交换类 | 冒泡排序 | n^2 | n | n^2 | 1 | 稳定 |
| 交换类 | 快速排序 | nlogn | nlogn | n^2 | logn ~ n | 不稳定 |
| 归并类 | 归并排序 | nlogn | nlogn | nlogn | n | 稳定 |
### 设计一个可以满足高效率获取第k大和前k个大的元素的数据结构
- 最小堆的数据结构来解决
- 最顶端是最小值，再次遇到比它大的值，就可以入堆，入堆后重新调整堆，将小的值pass掉。
- 这样我们就可以选出最大的前K个数据了。
- 假若我们要找出N个数据中最小的前k个数据，就要用最大堆了。
### 平衡二叉树查找复杂度

### 红黑树和平衡二叉树
### B+树的原理
### B树和B+树的区别
### 单向链表和双向链表的原理和特点、使用中（增删查）的优缺点
### 如何实现一个栈的类和对应的API
### 数据结构了解过吗？hashmap底层是怎么实现的？
答：hashmap的话是数组+链表实现的，通过hash散列化来决定进哪一个数组，如果有的话就“挂”在链表的最后面。


## 操作系统

### 计算机为什么要用补码？
化减为加：由于计算中的CPU只有加法器，没有减法器。
### 计算机内部的存储结构？
- 寄存器
- 高速缓存cache
- 内存
- 硬盘
- 外部存储
### 虚拟内存和物理内存的区别？
- 物理内存（内存条）：当打开程序时，系统会将这些程序加载到物理内存上。
- 虚拟内存（硬盘）：虚拟的不是物理内存，而是代替物理内存行使存储的功能，物理内存的运行程序的功能是无法用虚拟内存来完成的。
- 物理内存与虚拟内存的关系：当运行程序过多，物理内存不够用时，系统会将一部分硬盘空间当内存使用，这部分空间就是虚拟内存。
- 虚拟地址空间（作用：解决物理内存稀缺问题）：系统为每个进程所分配的4GB虚拟地址空间（32位系统），用来存放进程的虚拟地址，再通过MMU（内存管理单元）将虚拟地址映射到物理内存地址。
### 多线程同步，什么时候用自旋锁，什么时候用互斥锁
- 在多任务操作系统中，同时运行的多个任务可能都需要使用同一种资源。
- 在线程里也有这么一把锁——互斥锁（mutex），互斥锁是一种简单的加锁的方法来控制对共享资源的访问，互斥锁只有两种状态,即上锁( lock )和解锁( unlock )。
- 自旋锁与互斥量功能一样，唯一一点不同的就是互斥量阻塞后休眠让出cpu，而自旋锁阻塞后不会让出cpu，会一直忙等待，直到得到锁。
- 自旋锁的使用场景：锁的持有时间比较短，或者说小于2次上下文切换的时间。
### 进程和线程的区别
- 进程是系统进行资源调度的基本单位。
- 线程是CPU分派的基本单位
- 进程具有控制表PCB，而线程也有自己的控制表TCB
- 系统在运行的时候会为每个进程分配不同的内存区域，但是不会为线程分配内存（线程所使用的资源是它所属的进程的资源），线程组只能共享资源。线程只能共享它所属进程的资源。
### 进程通信
- 管道（Pipe）：管道可用于具有亲缘关系进程间的通信，允许一个进程和另一个与它有共同祖先的进程之间进行通信。速度慢，容量有限
- 命名管道（named pipe）：命名管道克服了管道没有名字的限制，因此，除具有管道所具有的功能外，它还允许无亲缘关系进程间的通信。命名管道在文件系统中有对应的文件名。命名管道通过命令mkfifo或系统调用mkfifo来创建。
- 信号（Signal）：信号是比较复杂的通信方式，用于通知接受进程有某种事件发生，除了用于进程间通信外，进程还可以发送信号给进程本身；linux除了支持Unix早期信号语义函数sigal外，还支持语义符合Posix.1标准的信号函数sigaction（实际上，该函数是基于BSD的，BSD为了实现可靠信号机制，又能够统一对外接口，用sigaction函数重新实现了signal函数）。
- 消息队列：消息队列是消息的链接表，包括Posix消息队列system V消息队列。有足够权限的进程可以向队列中添加消息，被赋予读权限的进程则可以读走队列中的消息。消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺陷，容量受到系统限制，且要注意第一次读的时候，要考虑上一次没有读完数据的问题。
- 共享内存：使得多个进程可以访问同一块内存空间，是最快的可用IPC形式。是针对其他通信机制运行效率较低而设计的。往往与其它通信机制，如信号量结合使用，来达到进程间的同步及互斥。
- 内存映射（mapped memory）：内存映射允许任何多个进程间通信，每一个使用该机制的进程通过把一个共享的文件映射到自己的进程地址空间来实现它。
- 信号量（semaphore）：主要作为进程间以及同一进程不同线程之间的同步手段。不能传递复杂消息，只能用来同步
- 套接字（Socket）：更为一般的进程间通信机制，可用于不同机器之间的进程间通信。起初是由Unix系统的BSD分支开发出来的，但现在一般可以移植到其它类Unix系统上：Linux和System V的变种都支持套接字。
- 文件锁
### 线程通信
- 由于多线程共享地址空间和数据空间，所以多个线程间的通信是一个线程的数据可以直接提供给其他线程使用，而不必通过操作系统（也就是内核的调度）。
- 锁机制：包括互斥锁、条件变量、读写锁
*互斥锁提供了以排他方式防止数据结构被并发修改的方法。
*读写锁允许多个线程同时读共享数据，而对写操作是互斥的。
*条件变量可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。
- 信号量机制(Semaphore)：包括无名线程信号量和命名线程信号量
- 信号机制(Signal)：类似进程间的信号处理
### 进程间通信和线程间通信的区别
### 线程间共享的资源
- a. 堆  由于堆是在进程空间中开辟出来的，所以它是理所当然地被共享的；因此new出来的都是共享的（16位平台上分全局堆和局部堆，局部堆是独享的）
- b. 全局变量 它是与具体某一函数无关的，所以也与特定线程无关；因此也是共享的
- c. 静态变量 虽然对于局部变量来说，它在代码中是“放”在某一函数中的，但是其存放位置和全局变量一样，存于堆中开辟的.bss和.data段，是共享的
- d. 文件等公用资源  这个是共享的，使用这些公共资源的线程必须同步。Win32 提供了几种同步资源的方式，包括信号、临界区、事件和互斥体。
### 线程间独享的资源
a. 栈 栈是独享的
b. 寄存器  这个可能会误解，因为电脑的寄存器是物理的，每个线程去取值难道不一样吗？其实线程里存放的是副本，包括程序计数器PC
### 一个进程能不能访问另一个进程的地址
- 共享内存
### 创建进程调用的是OS哪些方法
- fork：允许一进程（父进程）创建一新进程（子进程）。具体做法是，新的子进程几近于对父进程的翻版：子进程获得父进程的栈、数据段、堆和执行文本段的拷贝。可将此视为把父进程一分为二。
- exit(status)：终止一进程，将进程占用的所有资源（内存、文件描述符等）归还内核，交其进行再次分配。参数 status 为一整型变量，表示进程的退出状态。父进程可使用系统调用 wait() 来获取该状态。
- wait(&status)目的有二：其一，如果子进程尚未调用 exit() 终止，那么 wait 会挂起父进程直至子进程终止；其二，子进程的终止状态通过 wait 的 status 参数返回。
- execve(pathname, argv, envp) 加载一个新程序（路径名为 pathname，参数列表为 argv，环境变量列表为 envp）到当前进程的内存。这将丢弃现存的程序文本段，并为新程序重新创建栈、数据段以及堆。通常将这一动作称为执行一个新程序。
### 并发和并行区别
- 并行是同时做多件事情
- 并发则是在线程这个模型下产生的概念。并发表示同时发生了多件事情，通过时间片切换，哪怕只有单一的核心，也可以实现“同时做多件事情”这个效果。
### 一个进程，有十个线程，其中一个线程fork后，子进程有几个线程
### 多进程和多线程的区别
- 线程的划分尺度小于进程，使得多线程程序的并发性高。
- 进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。
- 线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。
- 从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。
### 乐观锁和悲观锁
- 悲观锁：总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程）。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。
- 乐观锁：总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和CAS算法实现。乐观锁适用于多读的应用类型，这样可以提高吞吐量。
### Linux 查看内存
- cat /proc/meminfo
### 死锁预防

- 1.破坏互斥条件
- 2.破坏占有和等待条件
- 3.破坏不可抢占条件
- 4.破坏环路等待

### 死锁避免

- 1.安全状态
- 2.单个资源的银行家算法
- 3.多个资源的银行家算法

### 死锁的解除

- 资源剥夺法。挂起某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程。但应防止被挂起的进程长时间得不到资源，而处于资源匮乏的状态。
- 撤销进程法。强制撤销部分、甚至全部死锁进程并剥夺这些进程的资源。撤销的原则可以按进程优先级和撤销进程代价的高低进行。
- 进程回退法。让一（多）个进程回退到足以回避死锁的地步，进程回退时自愿释放资源而不是被剥夺。要求系统保持进程的历史信息，设置还原点。

### 怎么开启一个线程
使用go关键字
### 线程运行完后会怎样，会被回收吗
执行完任务后，线程会被销毁
### 设计一个线程池

- 线程池即预先创建线程的技术，一个线程执行完后重新放回不会销毁掉提高了线程的利用率。
- 由于我们要使用线程来执行任务的时候直接从线程池中去现成的所以提高了程序的相应速度。
- 线程池可以对里面的线程进行管理，至于如何管理XXXX（如何销毁线程、如何结束线程状态等等）。

- 线程池的大小
- 执行任务队列
- 线程池满了新任务的执行策略
- 工作线程空闲后存活时间（如果想提高线程利用率提议调大该时间）。

### 解释下内存中堆和栈和静态区
堆区:
1.存储的全部是对象，每个对象都包含一个与之对应的class的信息。(class的目的是得到操作指令)
2.jvm只有一个堆区(heap)被所有线程共享，堆中不存放基本类型和对象引用，只存放对象本身.
3.一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收 。

栈区:
1.每个线程包含一个栈区，栈中只保存基础数据类型的对象和自定义对象的引用(不是对象)，对象都存放在堆区中
2.每个栈中的数据(原始类型和对象引用)都是私有的，其他栈不能访问。
3.栈分为3个部分：基本类型变量区、执行环境上下文、操作指令区(存放操作指令)。
4.由编译器自动分配释放 ，存放函数的参数值，局部变量的值等．

静态区/方法区:
1.方法区又叫静态区，跟堆一样，被所有的线程共享。方法区包含所有的class和static变量。
2.方法区中包含的都是在整个程序中永远唯一的元素，如class，static变量。
3.全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域， 未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。
### 实现读写锁

```
void Read()
{
    Wait(condition);

    Lock(mutex);
    if(0 == Count++)
        Lock(semaphore);
    UnLock(mutex);

    // 读取数据

    Lock(mutex);
    if(0 == --Count)
        UnLock(semaphore);
    UnLock(mutex);
}

void Write()
{
    Destroy(condition);
    Lock(semaphore);

    // 写入数据

    UnLock(semaphore);
    Create(condition);
}
```

## 数据库

### MYSQL的索引
- 将字段通过一定的方法进行存储，好让查询该字段上的信息时，能够快速找到对应的数据，
- MySQL中的索引的存储类型有两种：BTREE、HASH
- 所有的MySql列类型(字段类型)都可以被索引，也就是可以给任意字段设置索引
- 大大加快数据的查询速度

缺点：（MySQL 索引是不是越多越好？为什么？）

- 1、创建索引和维护索引要耗费时间，并且随着数据量的增加所耗费的时间也会增加
- 2、索引也需要占空间，我们知道数据表中的数据也会有最大上线设置的，如果我们有大量的索引，索引文件可能会比数据文件更快达到上线值
- 3、当对表中的数据进行增加、删除、修改时，索引也需要动态的维护，降低了数据的维护速度。

使用原则：

- 1、对经常更新的表就避免对其进行过多的索引，对经常用于查询的字段应该创建索引，
- 2、数据量小的表最好不要使用索引，因为由于数据较少，可能查询全部数据花费的时间比遍历索引的时间还要短，索引就可能不会产生优化效果。
- 3、在一同值少的列上(字段上)不要建立索引，比如在学生表的"性别"字段上只有男，女两个不同值。相反的，在一个字段上不同值较多可是建立索引

### MYSQL索引为什么用B+树
- 能够定位到数据点和范围查询。修改key与子树的组织逻辑，将索引访问都落到叶子节点并 按顺序将叶子节点串起来（方便范围查询）
- 1、 B+树的磁盘读写代价更低：B+树的内部节点并没有指向关键字具体信息的指针，因此其内部节点相对B树更小，如果把所有同一内部节点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多，一次性读入内存的需要查找的关键字也就越多，相对IO读写次数就降低了。

- 2、B+树的查询效率更加稳定：由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。

- 3、由于B+树的数据都存储在叶子结点中，分支结点均为索引，方便扫库，只需要扫一遍叶子结点即可，但是B树因为其分支结点同样存储着数据，我们要找到具体的数据，需要进行一次中序遍历按序来扫，所以B+树更加适合在区间查询的情况，所以通常B+树用于数据库索引。
- B树在提高了IO性能的同时并没有解决元素遍历的我效率低下的问题，正是为了解决这个问题，B+树应用而生。B+树只需要去遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作或者说效率太低。
### 索引的类型
- 普通索引：仅加速查询
- 唯一索引：加速查询 + 列值唯一（可以有null）
- 主键索引：加速查询 + 列值唯一（不可以有null）+ 表中只有一个
- 组合索引（联合索引）（复合索引）：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并
- 全文索引：对文本的内容进行分词，进行搜索

### 复合索引

- 复合索引的建立需要进行仔细分析；尽量考虑用单字段索引代替
- A、正确选择复合索引中的主列字段，一般是选择性较好的字段；
- B、复合索引的几个字段是否经常同时以AND方式出现在Where子句中？单字段查询是否极少甚至没有？如果是，则可以建立复合索引；否则考虑单字段索引；
- C、如果复合索引中包含的字段经常单独出现在Where子句中，则分解为多个单字段索引；
- D、如果复合索引所包含的字段超过3个，那么仔细考虑其必要性，考虑减少复合的字段；
- E、如果既有单字段索引，又有这几个字段上的复合索引，一般可以删除复合索引；

### MySQL Hash 索引适用情况

- A：哈希索引只包含哈希值和行指针，而不存储字段值，所以不能使用索引中的值来避免读取行（即不能使用哈希索引来做覆盖索引扫描），不过，访问内存中的行的速度很快（因为memory引擎的数据都保存在内存里），所以大部分情况下这一点对性能的影响并不明显。
- B：哈希索引数据并不是按照索引列的值顺序存储的，所以也就无法用于排序
- C：哈希索引也不支持部分索引列匹配查找，因为哈希索引始终是使用索引的全部列值内容来计算哈希值的。如：数据列（a,b）上建立哈希索引，如果只查询数据列a，则无法使用该索引。
- D：哈希索引只支持等值比较查询，如：=,in(),<=>(注意，<>和<=>是不同的操作)，不支持任何范围查询（必须给定具体的where条件值来计算hash值，所以不支持范围查询）。
- E：访问哈希索引的数据非常快，除非有很多哈希冲突，当出现哈希冲突的时候，存储引擎必须遍历链表中所有的行指针，逐行进行比较，直到找到所有符合条件的行。
- F：如果哈希冲突很多的话，一些索引维护操作的代价也很高，如：如果在某个选择性很低的列上建立哈希索引（即很多重复值的列），那么当从表中删除一行时，存储引擎需要遍历对应哈希值的链表中的每一行，找到并删除对应的引用，冲突越多，代价越大。

### Query Cache

- 为了加快查询语句的执行性能
- 完全独立工作于各种数据库引擎的上层，并使用独立的内存区域。
- 当某一个客户端连接（session）进行SQL查询并得到返回信息时，MySQL数据库除了将查询结果返回给客户端外，还在特定的内存区域缓存这条SQL查询语句的结果，以便包括这个客户端在内的所有客户的再次执行相同查询请求时，MySQL能够直接从缓存区返回结果。

避免“缓存数据不一致”的问题？

- 一旦被缓存的查询结果所涉及的数据表发生了“写”操作，那么无论“写”操作本身是否影响到被缓存的数据，涉及到数据表的所有缓存数据都将被清除。
- 这种简单暴力的处理方式，不仅绕过了数据一致性问题，还节约了宝贵的时间——因为在大多数数据库应用中，读请求是远远多余写请求的。
- MySQL数据库读写请求比例达到或查过1：1，那么使用Query Cache就没有什么意义，建议直接关闭。

### 事务的四个隔离级别

- 1.未提交读(Read Uncommitted)：该隔离级别允许脏读取，其隔离级别是最低的。换句话说，如果一个事务正在处理某一数据，并对其进行了更新，但同时尚未完成事务，因此还没有提交事务；而以此同时，允许另一个事务也能够访问该数据。脏读是指在一个事务处理过程里读取了另一个未提交的事务中的数据。
- 2.提交读(Read Committed)：是不同的时候执行的时候只能获取到已经提交的数据。这样就不会出现上面的脏读的情况了。可是解决了脏读问题，但是还是解决不了可重复读问题。
- 3.可重复读(Repeated Read)：就是保证在事务处理过程中，多次读取同一个数据时，该数据的值和事务开始时刻是一致的。因此该事务级别进制了不可重复读取和脏读，但是有可能出现幻读的数据。所以只能用顺序读了。
- 4.顺序读：是最严格的事务隔离级别。它要求所有的事务排队顺序执行，即事务只能一个接一个地处理，不能并发
幻读就是指同样的事务操作，在前后两个时间段内执行对同一个数据项的读取，可能出现不一致的结果。

### SQL的四种连接（关联查询）

- 内连接：指连接结果仅包含符合连接条件的行，参与连接的两个表都应该符合连接条件。（WHERE TESTA.A=TESTB.A）
- 外连接：连接结果不仅包含符合连接条件的行同时也包含自身不符合条件的行。包括左外连接、右外连接和全外连接。
- 左外连接：左边表数据行全部保留，右边表保留符合连接条件的行。（LEFT OUTER JOIN TESTB ON TESTA.A=TESTB.A）
- 右外连接：右边表数据行全部保留，左边表保留符合连接条件的行。（RIGHT OUTER JOIN TESTB ON TESTA.A=TESTB.A）
- 全外连接：左外连接 + 右外连接。全外连接是在等值连接的基础上将左表和右表的未匹配数据都加上。（FULL OUTER JOIN TESTB ON TESTA.A=TESTB.A）
- union查询：把多个表的查询表结果拼成一个表结果. 所使用的方法就是union.

### Redis数据类型
- string（字符串）：string 类型是 Redis 最基本的数据类型，string 类型的值最大能存储 512MB。 
- hash（哈希）：Redis hash 是一个键值(key=>value)对集合。并且可以像数据库中update一个属性一样只修改某一项属性值，特别适合用于存储、读取、修改用户属性。
- list（列表）：列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。
- set（集合）：Set是string类型的无序集合。集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。
- zset(sorted set：有序集合)。 zset 和 set 一样也是string类型元素的集合,且不允许重复的成员。不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。zset的成员是唯一的,但分数(score)却可以重复。
### sorted set底层实现
- hash table 和 skip list(跳跃表)
- hash table是具体使用redis中的dict来实现的，主要是为了保证查询效率为O(1) 
- skip list(跳跃表)主要是保证元素有序并能够保证INSERT和REMOVE操作是O(logn)的复杂度。
### redis分布式锁实现

## 语言

### 指针和引用的区别
### 垃圾回收算法具体说说？各种垃圾回收器了解吗？什么时候执行STOP THE WORLD？
### C++的内存管理和回收的原理
### 讲一下垃圾回收算法？
### 有引用计数和可达性分析法。回收算法的话就有垃圾收集算法：标记-清除、复制、标记-整理、分代收集 
### 什么是面向对象
### 结构体大小

Struct  Node {

Char a;

Int val;

Node *node;

Char a;
}；
### 虚函数表，如何用C实现
### 什么是可重入
### 静态库动态库优缺点
### hash表中的冲突是什么产生的，用什么解决方法
### 解释下哈希表的设计 以及哈希冲突的解决等， rehash的具体过程
### 如何实现一个 HashMap？
### 问：hashcode一样怎么办？hashcode和equals的区别？
答：通过equals方法判断真正的内容。 hashcode和equals的关系如下：
1、如果两个对象相等（equals），那么他们一定有相同的哈希值（hash code）。
2、如果两个对象的哈希值相等，那么这两个对象有可能相等也有可能不相等。（需要再通过equals来判断）
### 问：equals和==的区别？我要比较内容呢？
答：equals:是用来比较两个对象内部的内容是否相等的。
==：是用来判断两个对象的地址是否相同，即是否是指相同一个对象。
如果没有重写equals时，是直接用==判断的
如果是基本类型和基本型封装，则仍然为比较内容。

### 编译是怎么一个过程呢？
答：编译器的话经过四个步骤，词义分析，语义分析，语法分析和代码生成。
### 说到了HashMap，讲到了扩容机制。然后扯到了一个情况让分析下这个的时间复杂度。就是每次扩容2倍的空间，那么依次put进n个数据，整体的时间复杂度是多少。
### 一致性哈希了解么？

## 设计模式

### 单例模式

- 单例对象的类只能允许一个实例存在。
- 许多时候整个系统只需要拥有一个的全局对象，这样有利于我们协调系统整体的行为。比如在某个服务器程序中，该服务器的配置信息存放在一个文件中，这些配置数据由一个单例对象统一读取，然后服务进程中的其他对象再通过这个单例对象获取这些配置信息。这种方式简化了在复杂环境下的配置管理。
- 单例模式要求类能够有返回对象一个引用(永远是同一个)和一个获得该实例的方法（必须是静态方法，通常使用getInstance这个名称）。
- 将该类的构造方法定义为私有方法，这样其他处的代码就无法通过调用该类的构造方法来实例化该类的对象，只有通过该类提供的静态方法来得到该类的唯一实例；
- 在该类内提供一个静态方法，当我们调用这个方法时，如果类持有的引用不为空就返回这个引用，如果类保持的引用为空就创建该类的实例并将实例的引用赋予该类保持的引用。

## 算法题：

### 冒泡的实现和优缺点
### 二叉树从根到叶子的路径总和是否存在指定的值，很简单的问题。
### 堆排序实现。
### 手撕代码，找出一从小到大排序数组中小于0的最大数的索引和大于0的最小数的索引，如果数组没排序怎么找
### 手写快排
### 代码 两个str 最大公共子序列和子串
### int 4字节整数的海量数据，如何给出一个数，判断是否在这堆数据里？
### 给定数字字符串，用*分为六部分，每部分0~600，输出所有可能的结果
### 大文本数据（数T），统计每个字符串的频率
### 怎么判断链表有环，怎么找到环入口
### 怎么判断链表是否相交，找到相交点
### 代码：输出二叉树从左侧看的结果 
### 手写求两个链表第一个交叉节点

给定一颗二叉树，求其中root的最长路径。所谓路径是指，联通两个结点的最小边数
 
两个升序数组，找出第k小的数字，这题没见过，先说了个最笨的方法，要求优化。想了一下，又说了一个用二分优化的，要求再优化，最后他提示了一下，想明白了写了代码
问还有什么想问的。 

写LRU

查找两个链表的交叉节点

 5. 算法题：一个链表，奇数位升序，偶数位降序，如何整体排成升序？
6. 算法题：千万级别的数据量，实现队列FIFO，如何设计数据结构节省内存空间（数据+链表）


算法题：如何利用rand(1,8)实现随机生成1-5
9. 手撕堆排


一个二叉树，每个节点除了有左右子节点外，还有指向父节点的引用。给出一个节点，返回它在二叉树中中序遍历的下一个节点。 

合并两个有序数组
2. 一棵二叉树找到是否有一条路径（从根节点到子节点），节点值的和为N（leetcode原题）
3. 忘了。。。 

手撕代码：求二叉树的两个节点的最近共同父节点
6. 手撕代码：问题同上，空间复杂度O(1)
7. 手撕代码：常规二叉树树节点求最近共同父节点 

按层次遍历二叉树
5. 手撕代码：按层次遍历二叉树（不完全二叉树）节点为null的需要输出null 

远程写代码:一个数组有1个数字出现了一次,其他数字出现了三次,请问不用map的情况如何找到这个只出现了一次的数（不会）
远程写代码:二叉搜索树中第K小的元素

远程写代码:删除一个整数数组中value为50的数字，并且返回最终的长度

求数组的中位数。数组由一个升序数组翻转形成，如1 2 3 4 5 6 7可以从5处翻转，形成5 6 7 1 2 3 4，求5 6 7 1 2 3 4的中位数。要求时间复杂度低于O(n)。 

给一个数组，定义X为某个区间的最小值乘上这个区间内所有元素的和，求最大的X。如数组为3 1 6 4 5，则最大的X=4*（6+4+5）=60

一个数组，每个位置的值对应下标。重新排列，要求对应位置上不能有同下标相同的值，即原先a[0]=0，重排后a[0]不可以等于0。输出总共有多少种重新排列的方法。 

红黑树/旋转 

手写快排
手写堆排
已知出栈序列求所有的入栈序列（这题很有意思，当时只是写了列出所有的可能，后来想到这题和已知入栈序列求所有出栈序列是一样的）

合并两个有序链表。递归和非递归的实现。 

给定一个二叉树，原地将它展开为链表。
leetcode原题。

 给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。
秒了。 

给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。
当时我真的是很慌张！脑子里想的是我会做我会做！可是却是一片空白。深呼吸一下。用递归做了出来。 又问我除了递归怎么做？“那就遍历，每次都比较就行”
“那为什么不用遍历用递归呢？”“递归写起来简单啊！”

代码：两个链表相加。{1->2->3} + {1->2->3} = 246. 

手撕代码，找出数组中第k大的数

两个有序链表合并成一个有序
（代码有错，忘了写迭代）

一个链表，假设第一个节点我们定为下标为1，第二个为2，那么下标为奇数的结点是升序排序，偶数的结点是降序排序，如何让整个链表有序？（分离链表，合并两个有序链表）

假设我们有一个队列，可能存放几千万上亿的数据，我们应该如何设计这个队列？写出来看看？（提问：这个队列是只需要在头尾添加和删除吗？双向队列？答：是的）

一个二维矩阵，从左到右是升序，从上到下是降序，找一个数是否存在于矩阵中（类似于二叉查找树）

翻转链表（面试官：能不能用c写）....（然后让我一边写一边跟他讲redis）

单链表的反转，不用递归的方法。

有序数组存在某个值，查找这个值的下标，有则输出，无则输出-1

二叉树的最大路径。

写个二进制转十进制

手写“反转链表”算法？（迭代和递归）

给你一个数组，数组长度为 n。请找出数组中第 k 大的数

n, A[i] int 范围内

附件条件：不允许改变元素在数组中的位置。

一开始想都没想就先说了用partition的思路，面试官听了之后加了一个附加条件...就完全没思路了，最后问了提示：“给你一个数你能找到是数组的第几大吗？”，才想出来并实现

思路就是在int范围内取中位数，算出其在数组中是第几大元素，与k比较并不断二分

## 项目

技术难点

项目遇到的困难

说说你做了什么项目，用了什么技术栈？
### 打包工具都用什么，会写简单webpack配置吗

## HR面

平时学习技术的方法，最近在看什么书
觉得怎样提高解决问题的能力
## 还有什么要问的

公司对我这个职位的期望是什么？
这个职位未来几年的职业发展是怎样的？
为了胜任这个岗位我还需要学习哪些技术知识？