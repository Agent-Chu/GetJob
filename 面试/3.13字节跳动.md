# 3.13字节跳动

## 职责

1、负责图片版权相关业务的Web平台、移动平台开发、框架设计和实现工作；
2、进行模块设计及文档编写，保证项目质量，并确保开发项目按时完成；
3、负责版权图片业务的核心应用系统产品升级及维护、性能优化；
4、主要实现语言为Golang。

## 一面

interface，如何判断interface的类型
二叉树最小公共父节点
Y型链表的交叉结点

## 二面

两个栈模拟队列
HTTPS
SSL
公钥私钥

## 三面

#### 设计一个长链接转短链接的服务
#### 设计一个即时多人聊天软件
#### 怎么解决hash冲突
#### 讲讲Http协议
#### 一个服务器上面有一个文件，要把这个文件传给别的服务器，别的服务器数量是成千上万个

CDN的基本原理是广泛采用各种缓存服务器，将这些缓存服务器分布到用户访问相对集中的地区或网络中，在用户访问网站时，利用全局负载技术将用户的访问指向距离最近的工作正常的缓存服务器上，由缓存服务器直接响应用户请求

#### 排序算法，各种排序算法的适用场景
#### TCP三次握手
#### Redis的底层数据结构的实现
#### 数据库中事务的概念
#### 数据库三范式

### 项目

### 算法

#### 两个有序数组找第k大的数

```c++
int find_kth(int A[], int m, int B[], int n, int k) {
    if (m > n) return find_kth(B, n, A, m, k);
    if (m == 0) return B[k - 1];
    if (k == 1) return min(A[0], B[0]);
    int ia = min(k / 2, m), ib = k - ia;
    if (A[ia - 1] < B[ib - 1])
        return find_kth(A + ia, m - ia, B, n, k - ia);
    else if (A[ia - 1] > B[ib - 1])
        return find_kth(A, m, B + ib, n - ib, k - ib);
    else
        return A[ia - 1];
    }
};
```

#### 找一堆数字里的中位数

1、如果数组元素的个数是奇数，取数组前(size+1)/2个元素建堆，如果是偶数则取前 size/2 个元素建堆。
2、建完堆之后，此时堆顶的元素是这前 (size-1)/2 个元素中最小的；此时需要将数组中剩余的元素分别和堆顶的元素进行比较：如果小于等于堆顶元素则直接丢弃，如果大于堆顶的元素则需要更新堆顶的元素并重新调整堆的结构，使其保证小顶堆的特性。
3、将剩余的元素全部比较完之后，此时堆顶的元素就是所要求的中位数。
在这里需要提到的是，优先级队列的底层也是通过建堆来实现的。默认是建大堆，此时就要编写一个使其建小堆的仿函数了，其实也就是相当于修改了它的优先级。

```
#include<queue>
#include<vector>
int GetMidNumNoSort2(int *arr, int size){
    assert(arr);
    int len = (size + 1) / 2; //奇数个元素
    struct Compare //建小堆 {
        int operator()(int left, int right) {
            return left > right;
        }
    };
    priority_queue<int, vector<int>, Compare> heap; //先以整个数组的前len个元素建小堆
    for (int i = 0; i < len; i++) {
        heap.push(arr[i]);
    }
    for (int i = len; i < size; i++) {
        if (arr[i] > heap.top()) //比堆顶元素大则更新该小堆
        {
            heap.pop();
            heap.push(arr[i]);
        }
    }
    if (!heap.empty()) {
        return heap.top();
    }
}
```

#### 给定一个数组，找出这个数组中每一个数右边的第一个比它大的数

这个题目用栈可以很好的解决；

下面给出例子：9 6 5 7 3 2 1 5 9 10，返回的是 10 7 7 9 5 5 5 9 10 N。

```
#include<iostream>
#include<vector>
#include<stack>

using namespace std;

vector<int> FindRfmax(vector<int> nums){
    int len = nums.size();
    if (len == 0) return nums;
    int i = 0;
    vector<int> res(len);
    stack<int> stk;
    while (i < len){
        if (stk.empty() || nums[stk.top()]>nums[i]){
            stk.push(i++);
        }
        else{
            res[stk.top()] = nums[i];
            stk.pop();
        }
    }
    while (!stk.empty()){
        res[stk.top()] = INT_MIN;
        stk.pop();
    }
    return res;
}

void main()
{
    vector<int> input = { 9, 6, 5, 7, 3, 2, 1, 5, 9, 10 };
    vector<int> output;
    output = FindRfmax(input);
}
```

#### 合并k个链表

首先把k个链表的首元素都加入最小堆中，它们会自动排好序。然后我们每次取出最小的那个元素加入我们最终结果的链表中，然后把取出元素的下一个元素再加入堆中，下次仍从堆中取出最小的元素做相同的操作，以此类推，直到堆中没有元素了，此时k个链表也合并为了一个链表，返回首节点即可

```C++
struct cmp {
    bool operator () (ListNode *a, ListNode *b) {
        return a->val > b->val;
    }
};

class Solution {  
public:
    ListNode *mergeKLists(vector<ListNode *> &lists) {  
        priority_queue<ListNode*, vector<ListNode*>, cmp> q;
        for (int i = 0; i < lists.size(); ++i) {//只加入首元素
            if (lists[i])
                q.push(lists[i]);
        }
        ListNode *head = NULL, *pre = NULL, *tmp = NULL;//pre是当前尾结点指针
        while (!q.empty()) {//取首元素最小
            tmp = q.top();
            q.pop();
            if (!pre)//说明是第一个节点
                head = tmp;
            else
                pre->next = tmp;
            pre = tmp;
            if (tmp->next)//如果最小的有下一个元素，则加入堆
                q.push(tmp->next);
        }
        return head;
    }  
};
```

#### 按照字典序打印1～N的排序

```
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
int main(void)
{
    int n;
    int i,j;
    char a[1000][1000];
    char t[1000];
    int k = 0;
    scanf("%d",&n);
    for (i = 1; i <= n; i++)
    {
        _itoa(i,a[k],10);  //将数字转换为字符串存入到字符串数组a中
         
        k++;
    }
    for (i = 0; i < k - 1; i++) //将字符串排序
    {
        for (j = 0; j < k - 1 - i;j++)
            if (strcmp(a[j], a[j + 1]) > 0)
            {
            strcpy(t, a[j]);
            strcpy(a[j], a[j + 1]);
            strcpy(a[j+1], t);
             
            }
    }
    for (i = 0; i < k; i++)//输出排序后的字符串
        puts(a[i]);
 
     
    return 0;
}
```

#### 手写LRU

```java
import java.util.LinkedHashMap;
import java.util.Map;

public class LRUCache<K, V> extends LinkedHashMap<K, V> {

    private static final long serialVersionUID = 1L;
    private final int CACHE_SIZE;

    public LRUCache(int cacheSize) { 
        // true 表示让 linkedHashMap按照访问顺序来进行排序，最近访问的放在头部，最老访问的放在尾部。
        super((int) Math.ceil(cacheSize / 0.75) + 1, 0.75f, true);// 这块就是设置一个hashmap的初始大小，同时最后一个true指的是让linkedhashmap按照访问顺序来进行排序，最近访问的放在头，最老访问的就在尾。
        CACHE_SIZE = cacheSize;
    }

    @Override
    protected boolean removeEldestEntry(Map.Entry<K, V> eldest) { 
        // 当map中的数据量大于指定的缓存个数的时候，就自动删除最老的数据。
        // 这个意思就是说当map中的数据量大于指定的缓存个数的时候，就自动删除最老的数据
        return size() > CACHE_SIZE;
    }
}
```
