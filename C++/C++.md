# 目录

- [编程基础](https://github.com/ChuangLiu727/GetJob/blob/master/C++/编程基础.md)
- [面向对象基础](https://github.com/ChuangLiu727/GetJob/blob/master/C++/面向对象基础.md)
- [标准模板库](https://github.com/ChuangLiu727/GetJob/blob/master/C++/标准模板库.md)
- [编译](https://github.com/ChuangLiu727/GetJob/blob/master/C++/编译.md)
- [Makefile](https://github.com/ChuangLiu727/GetJob/blob/master/C++/makefile.md)

---

## C++与C的区别

https://www.cnblogs.com/ITziyuan/p/9487760.html

## cout和printf有什么区别

- cout/cin类型处理更加安全，更加智能，我们无须应对int、float中的%d、%f，而且扩展性极强，对于新定义的类，printf想要输入输出一个自定义的类的成员是天方夜谭的，而iostream中使用的位运算符都是可重载的，并且可以将清空缓冲区的自由交给了用户（在printf中的输出是没有缓冲区的），而且流风格的写法也更加自然和简洁。
- cin cout效率没scanf printf高
  - 1.流输入输出对于基本类型来说使用很方便，不用手写格式控制字符串。
  - 2.对于标准库的一些class来说，显然重载操作符也比自己写格式控制字符串要方便很多。
  - 3.对于复杂的格式可以进行自定义操作符。
  - 4.可读性更好（这个很多人有不同意见，见仁见智了）。

## 为什么模板函数的声明与实现都放在.h文件中

当你不使用这个模版函数或模版类,编译器并不实例化它 ,当你使用时，编译器需要实例化它， 因为编译器是一次只能处理一个编译单元, 也就是一次处理一个cpp文件,所以实例化时需要看到该模板的完整定义 . 所以都放在头文件中 这不同于普通的函数, 在使用普通的函数时，编译时只需看到该函数的声明即可编译, 而在链接时由链接器来确定该函数的其实模板实现不能放在cpp文件中，主要就是CPP在c++编译期间不能决定模板参数的类型，所以不能生成模板函数的实例，所以他会把模板类型带到链接期间，如果这个期间有函数调用了该实例，这个时候由于没有把模板实例到特定类型，就会导致编译错误。

## extern “C”的作用详解

extern "C"的主要作用就是为了能够正确实现C++代码调用其他C语言代码。加上extern "C"后，会指示编译器这部分代码按C语言的进行编译，而不是C++的。由于C++支持函数重载，因此编译器编译函数的过程中会将函数的参数类型也加到编译后的代码中，而不仅仅是函数名；而C语言并不支持函数重载，因此编译C语言代码的函数时不会带上函数的参数类型，一般之包括函数名。

## 大端小端

- 大端模式：大端模式就是指把数据的高字节保存在内存的低地址中，数据的低字节保存在内存的高地址中，这和我们一般的阅读顺序是一致的。
- 小端模式：小端模式与大端模式相反，数据的高字节位置保存在内存的高地址处，数据的低字节保存在内存的低地址处。这种存储模式将地址的高低和数据位权有效地结合起来，高地址部分权值高，低地址部分权值低。

比如我们要存取一个0x12345678的数据，在大小端机器的存取方式分别是：

- 大端模式：12345678
- 小端模式：78563412

## 判断机器大小端方式

字符指针判断

在32位平台下，int占4个字节，而char类型的指针是占一个字节的，如果我们把int强传为char类型的指针，只会保存一个字节的数据，那么我们只需要判断char里面的第一个字节和int里面的第一个字节是否是一致即可判断。
如果一致则为小端模式，反之为大端模式。
注：

下面代码我们令 int a=1 如果是小端模式，int下1会存放在在低地址处，而强传为char类型的指针，1也在低地址处，所以可以判断。

```
#include <iostream>
using namespace std;
int main()
{
    int a = 1;
    if (*(char*)&a == 1)
        cout << "小端模式" << endl;
    else
        cout << "大端模式" << endl;
    return 0;
}
```

联合体判断

由于联合体所有数据共享一块地址空间，存放数据的所有成员都是从低地址开始存放，所以我们可以在联合体内定义一个int和一个char类型变量，然后在外部实例化的时候创建int变量，用char变量调用，相当于隐式类型转化，如果结果为1，则低字节存放在低地址，既是小端机器，反之大端机器。

```
#include <iostream>
using namespace std;
union Test
{
    int a;
    char b;
};
int main()
{
    Test t;
    t.a = 1;
    if (t.b == 1)
        cout << "小端机器" << endl;
    else
        cout << "大端机器" << endl;
    return 0;
}
```

## RAII

- RAII技术被认为是C++中管理资源的最佳方法，使用RAII技术也可以实现安全、简洁的状态管理，编写出优雅的异常安全的代码。
- RAII全称是“Resource Acquisition is Initialization”，直译过来是“资源获取即初始化”，也就是说在构造函数中申请分配资源，在析构函数中释放资源。
- 智能指针（std::shared_ptr和std::unique_ptr）即RAII最具代表的实现，使用智能指针，可以实现自动的内存管理，再也不需要担心忘记delete造成的内存泄漏。毫不夸张的来讲，有了智能指针，代码中几乎不需要再出现delete了。

## 智能指针

https://www.cnblogs.com/wxquare/p/4759020.html

## strcpy和memcpy区别

- 1、复制的内容不同。strcpy只能复制字符串，而memcpy可以复制任意内容，例如字符数组、整型、结构体、类等。
- 2、复制的方法不同。strcpy不需要指定长度，它遇到被复制字符的串结束符"\0"才结束，所以容易溢出。memcpy则是根据其第3个参数决定复制的长度。
- 3、用途不同。通常在复制字符串时用strcpy，而需要复制其他类型数据时则一般用memcpy

## const与#define的异同

(0)  相同

两者都可以用来定义常量；

      #define PI 3.14159 // 常量宏  
      const doulbe Pi=3.14159; // 常量
(1)  编译器处理方式不同

　　define宏是在预处理阶段展开；

　　const常量是编译运行阶段使用；
(2)  类型和安全检查不同

　　define宏没有类型，不做任何类型检查，仅仅是展开。

　　const常量有具体的类型，在编译阶段会执行类型检查。
(3)  存储方式不同

　　define宏在定义时不会分配内存；define宏仅仅是展开，有多少地方使用，就展开多少次；

　　const常量在定义时会在内存中分配(可以是堆中也可以是栈中)；
(4)  赋值时的空间分配

　　　const  可以节省空间，避免不必要的内存分配。 例如：  
        #define PI 3.14159 //常量宏  
        const doulbe Pi=3.14159; //此时并未将Pi放入ROM中 ......  
        double i=Pi; //此时为Pi分配内存，以后不再分配！  
        double I=PI; //编译期间进行宏替换，分配内存  
        double j=Pi; //没有内存分配  
        double J=PI; //再进行宏替换，又一次分配内存！  
        const定义常量从汇编的角度来看，只是给出了对应的内存地址，而不是象#define一样给出的是立即数，所以，const定义的常量在程序运行过程中只有一份拷贝，而 #define定义的常量在内存中有若干个拷贝。 
(5)  提高了效率

编译器通常不为普通const常量分配存储空间，而是将它们保存在符号表中，这使得它成为一个编译期间的常量，没有了存储与读内存的操作，使得它的效率也很高。