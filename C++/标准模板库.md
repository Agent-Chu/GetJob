# 标准模板库

- 各种STL基本的增删改查
- 每种容器都提供了很多操作，但实际增删改查我们通常只需要掌握透彻一种方式即可。
- STL就是封装了我们常用的数据结构，所以最先需要了解每种数据结构的特性。而且了解实现方式对我们能够准确、高效使用STL打下了基础。
- 如何避免错误，避免一些未知的错误，比如迭代器失效问题。

- [string](#string)
- [vector](#vector)
- [map](#map)
- [set](#set)

## string

### string概念

### string源码

### string使用方法

## vector

### vector概念

- 线性容器，严格按照线性顺序排列，存储在一块连续的内存空间中
- 能自动存储元素，可以自动增长或者缩小内存空间
- 可以使用下标方式访问元素
- 可以使用指针偏移方式访问元素
- 可以使用迭代器访问元素或者遍历容器
- 可以在容器末尾增加或删除元素
- 可以提供和数组一样的性能
- size()返回容器大小，指元素个数
- capacity()返回容量，即容器分配的内存大小，一般容量大于容器大小

### vector使用

#### 初始化：

```c++
vector<T> v1;           //空vector，元素类型为T，执行默认初始化
vector<T> v2(v1);       //v2包含v1所有元素的副本
vector<T> v2 = v1;      //同上
vector<T> v3(n, val);   //n个重复元素，每个元素的值都是val
vector<T> v4(n);        //n个初始化后的对象
vector<T> v5{a,b,c};    //个数和大括号中的相同，并赋值对应的值
vector<T> v5={a,b,c};   //等价于上
```

#### 遍历容器：

迭代器方法：

```c++
vector<int> v1;
vector<int>::iterator iter;
for(iter = vec.begin(); iter != vec.end(); ++iter) {
    cout<<*iter<<endl;
}
```

```c++
vector<int> v1;
for(v1.begin(), v1.end(), print);
```

```c++
vector<int> v1;
for(int i = 0; i < v1.size() ; ++i) {
    cout<<v1[i]<<endl;
}
```

#### 排序元素：

```c++
vector<int> vec;
int cmp(){
}
sort(vec.begin(), vec.end(), cmp);
```

#### 查找元素：

```c++
vector<int>::iterator iter = find(vec.begin(), vec.end(), 3);
```

#### 插入元素：

```c++
vec.push_back(element);
vec.insert(iterator, element);
```

#### 删除元素：

```c++
vec.pop_back();
vec.erase(iterator);
```

```c++
vector<int>::iterator iter=vec.begin();
for(;iter!=vec.end();){
    if(*iter==3){
        iter = vec.erase(iter);
    }else{
        ++iter;
    }
}
```

不能删除后直接对iter直接++操作，因为删除后iter会变成野指针

#### 修改元素：

```c++
vec[position] = element;
```

#### 其他：

```c++
vec.empty();    //判断是否空
vec.size();    // 实际元素
vec.capacity();    // 容器容量
vec.begin();    // 获得首迭代器
vec.end();    // 获得尾迭代器
vec.clear();    // 清空
```

### vector内存管理

#### 修正过剩内存

```c++
vector<int>(ivec).swap(ivec);
```

`vector<int>(ivec)`表示构建一个临时vector，是ivec的拷贝，临时vector只分配它需要的内存，没有多余内存，交换后，临时vector会有原来vec的多余内存，然后结束时临时vector会被销毁，实现了修整过剩内存

### vector实现：

[模拟Vector实现](https://github.com/linw7/Skill-Tree/blob/master/code/my_vector.cpp)

- 线性表，数组实现。
- 支持随机访问。
- 插入删除操作需要大量移动数据。
- 需要连续的物理存储空间。
- 每当大小不够时，重新分配内存（*2），并复制原内容。

#### vector错误避免：

[迭代器失效](https://github.com/linw7/Skill-Tree/blob/master/code/vector_iterator.cpp)

- 插入元素
  - 尾后插入：size < capacity时，首迭代器不失效尾迭代实现（未重新分配空间），size == capacity时，所有迭代器均失效（需要重新分配空间）。
  - 中间插入：size < capacity时，首迭代器不失效但插入元素之后所有迭代器失效，size == capacity时，所有迭代器均失效。

- 删除元素
  - 尾后删除：只有尾迭代失效。
  - 中间删除：删除位置之后所有迭代失效。

## map

- 一种关联式容器，把`元素的值`和`特定的键`关联起来，建立Key-Value对应关系
- 增加和删除节点对map影响很小
- 不可以修改键值，只能修改对应的实值
- map内部是红黑树，有自动排序功能，所以map中的数据都是有序的，key类型必须支持<操作符
- 查找复杂度：Log(N)
- 需要包含头文件：`#include <map>`
- 默认按照key从小到大排序

```c++
map<T_key, T_value> mymap;
```

### map用法：

#### map插入元素：

```c++
mymap.insert(pair<T_key, T_value>(key, value));    // 同key不插入
mymap.insert(map<T_key, T_value>::value_type(key, value));    // 同key不插入
mymap[key] = value;    // 同key覆盖
```

判断是否插入成功：

```c++
map<int, string> mapStudent;
pair< map<int, string>::iterator , bool > insert_pair;
insert_pair = mapStudent.insert( pair<int, string>(1, "student1") );
if(insert_pair.second){}//如果为true，则插入成功
```

#### map遍历容器：

迭代器遍历同vector

反向迭代器：

```c++
map<int, string>::reverse_iterator iter;
for(iter = mymap.rbegin(); iter != mymap.rend(); ++iter) {
    cout << iter->first << " => " << iter->second << '\n';
}
```

数组方式：

```c++
int iSize = mapStudent.size();
for(int i=1, i <= iSize; i++){
    cout<<i<<" "<<mapStudent[i]<,endl;
}
```

#### map查找元素

- count函数，返回0或1
- find函数，返回一个迭代器，如果没找到，返回的迭代器等于`.end()`的迭代器

```c++
map<int, string> mapStudent;
mapStudent[1] = "1";
mapStudent[2] = "2";
mapStudent[3] = "3";

map<int, string>::iterator iter = map.find(1);
if(iter != mapStudent.end()){
    cout << iter->first << " => " << iter->second << '\n';
}
```

#### map删除元素：

```c++
mymap.erase(key);    // 按值删
mymap.erase(iterator);    // 按迭代器删
```

按迭代器删基本同vector

```c++
for(;iter!=mapStudent.end();){
    if((*iter).second == "1" ){
        mapStudennt.erase(iter++);
    }else{
        ++iter;
    }
}
```

#### map排序

指定第三个参数Compare

```c++
map<int, string, greater<int> > mapStudent;
```

```c++
struct CmpByKeyLength{
    bool operator()(const string& k1, const string& k2){
        return k1.length() < k2.length();
    }
}
map<string, int, CmpByKeyLength > mapStudent;
```

#### map修改元素：

```c++
mymap[key] = new_value;
```

## set

