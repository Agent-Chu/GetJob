# 标准模板库

- 各种STL基本的增删改查
- 每种容器都提供了很多操作，但实际增删改查我们通常只需要掌握透彻一种方式即可。
- STL就是封装了我们常用的数据结构，所以最先需要了解每种数据结构的特性。而且了解实现方式对我们能够准确、高效使用STL打下了基础。
- 如何避免错误，避免一些未知的错误，比如迭代器失效问题。

## string

### string概念

### string源码

### string使用方法

## vector

### vector概念

- 线性容器，严格按照线性顺序排列，存储在一块连续的内存空间中
- 能自动存储元素，可以自动增长或者缩小内存空间
- 可以使用下标方式访问元素
- 可以使用指针偏移方式访问元素
- 可以使用迭代器访问元素或者遍历容器
- 可以在容器末尾增加或删除元素
- 可以提供和数组一样的性能
- size()返回容器大小，指元素个数
- capacity()返回容量，即容器分配的内存大小，一般容量大于容器大小

### vector使用

#### 初始化：

```c++
vector<T> v1;           //空vector，元素类型为T，执行默认初始化
vector<T> v2(v1);       //v2包含v1所有元素的副本
vector<T> v2 = v1;      //同上
vector<T> v3(n, val);   //n个重复元素，每个元素的值都是val
vector<T> v4(n);        //n个初始化后的对象
vector<T> v5{a,b,c};    //个数和大括号中的相同，并赋值对应的值
vector<T> v5={a,b,c};   //等价于上
```

#### 遍历容器：

迭代器方法：

```c++
vector<int> v1;
vector<int>::iterator iter;
for(iter = vec.begin(); iter != vec.end(); ++iter) {
    cout<<*iter<<endl;
}
```

```c++
vector<int> v1;
for(v1.begin(), v1.end(), print);
```

```c++
vector<int> v1;
for(int i = 0; i < v1.size() ; ++i) {
    cout<<v1[i]<<endl;
}
```

#### 排序元素：

```c++
vector<int> vec;
int cmp(){
}
sort(vec.begin(), vec.end(), cmp);
```

#### 查找元素：

```c++
vector<int>::iterator iter = find(vec.begin(), vec.end(), 3);
```

#### 插入元素：

```c++
vec.push_back(element);
vec.insert(iterator, element);
```

#### 删除元素：

```c++
vec.pop_back();
vec.erase(iterator);
```

#### 修改元素：

```c++
vec[position] = element;
```

#### 其他：

```c++
vec.empty();    //判断是否空
vec.size();    // 实际元素
vec.capacity();    // 容器容量
vec.begin();    // 获得首迭代器
vec.end();    // 获得尾迭代器
vec.clear();    // 清空
```

### vector实现：

[模拟Vector实现](https://github.com/linw7/Skill-Tree/blob/master/code/my_vector.cpp)

- 线性表，数组实现。
- 支持随机访问。
- 插入删除操作需要大量移动数据。
- 需要连续的物理存储空间。
- 每当大小不够时，重新分配内存（*2），并复制原内容。

#### vector错误避免：

[迭代器失效](https://github.com/linw7/Skill-Tree/blob/master/code/vector_iterator.cpp)

- 插入元素
  - 尾后插入：size < capacity时，首迭代器不失效尾迭代实现（未重新分配空间），size == capacity时，所有迭代器均失效（需要重新分配空间）。
  - 中间插入：size < capacity时，首迭代器不失效但插入元素之后所有迭代器失效，size == capacity时，所有迭代器均失效。

- 删除元素
  - 尾后删除：只有尾迭代失效。
  - 中间删除：删除位置之后所有迭代失效。

## map

### map定义：

```c++
map<T_key, T_value> mymap;
```

### map用法：

#### map插入元素：

```c++
mymap.insert(pair<T_key, T_value>(key, value));    // 同key不插入
mymap.insert(map<T_key, T_value>::value_type(key, value));    // 同key不插入
mymap[key] = value;    // 同key覆盖
```

#### map删除元素：

```c++
mymap.erase(key);    // 按值删
mymap.erase(iterator);    // 按迭代器删
```

#### map修改元素：

```c++
mymap[key] = new_value;
```

#### map遍历容器：

```c++
for(auto it = mymap.begin(); it != mymap.end(); ++it) {
    cout << it->first << " => " << it->second << '\n';
}
```

### map实现：

## set