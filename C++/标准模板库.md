# 标准模板库

- 各种STL基本的增删改查
- 每种容器都提供了很多操作，但实际增删改查我们通常只需要掌握透彻一种方式即可。
- STL就是封装了我们常用的数据结构，所以最先需要了解每种数据结构的特性。而且了解实现方式对我们能够准确、高效使用STL打下了基础。
- 如何避免错误，避免一些未知的错误，比如迭代器失效问题。

- [string](#string)
- [vector](#vector)
- [map](#map)
- [set](#set)
- [HashMap](#HashMap)

## 容器的时间复杂度

map, set, multimap, and multiset
上述四种容器采用红黑树实现，红黑树是平衡二叉树的一种。不同操作的时间复杂度近似为:

插入: O(logN)

查看:O(logN)

删除:O(logN)

hash_map, hash_set, hash_multimap, and hash_multiset
上述四种容器采用哈希表实现，不同操作的时间复杂度为：

插入:O(1)，最坏情况O(N)。

查看:O(1)，最坏情况O(N)。

删除:O(1)，最坏情况O(N)。

## string

- `#include <string>`

### string声明

```c++
    string s;  //声明一个空字符串
    string str1="Spend all your time waiting.";
    string str2="For that second chance.";
    string str3(str1,6);//把下标6当作起始位置
    string str4(str1,6,3);//下标6起始，3个字符长度
    char ch_music[]={"Sarah McLachlan"};
    string str5=ch_music;
    string str6(ch_music);//拷贝构造
    string str7(ch_music,5);//"Sarah"
    string str8(4,'a');//aaaa
    string str9(ch_music+6,ch_music+14);//" McLachlan"
```

### c++字符串和c的转换

#### c_str()

- c_str()返回一个以'\0'结尾的字符数组

```c++
#include<iostream>
#include<string>
using namespace std;
int main(){
    string str="Hello world.";
    const char * cstr=str.c_str();//定义一个c字符串指针
    cout<<cstr<<endl;
    str="Abcd.";//当str改变时，使用c_str的内容也会跟着改变
    cout<<cstr<<endl;
    return 0;
}
```

#### c_str()复制

- 将c_str()中的内容复制出来保证有效性
- 使用strncpy将内容复制到了cstr

```c++
#include<iostream>
#include<string>
#include<string.h>
using namespace std;
int main(){
    char * cstr=new char[20];
    string str="Hello world.";
    strncpy(cstr,str.c_str(),str.size());
    cout<<cstr<<endl;
    str="Abcd.";
    cout<<cstr<<endl;
    return 0;
}
```

#### str.copy

```c++
#include<iostream>
#include<string>
using namespace std;

int main (){
    size_t length;
    char buffer[8];
    string str("Test string......");
    cout<<"str:"<<str<<endl;

    //第二个参数7表示复制后最大长度，第三个参数是pos从pos开始
    length=str.copy(buffer,7,5);
    buffer[length]='\0';
    cout<<"str.copy(buffer,7,5),buffer contains: "<<buffer<<endl;

    length=str.copy(buffer,str.size(),5);
    buffer[length]='\0';  
    cout<<"str.copy(buffer,str.size(),5),buffer contains:"<<buffer<<endl;

    length=str.copy(buffer,7,0);
    buffer[length]='\0';
    cout<< "str.copy(buffer,7,0),buffer contains:"<<buffer<<endl;

    //缺省参数pos，默认pos=0；
    length=str.copy(buffer,7);
    buffer[length]='\0';
    cout<<"str.copy(buffer,7),buffer contains:"<<buffer<<endl;

    length=str.copy(buffer,string::npos,5);
    buffer[length]='\0';
    cout<<"string::npos:"<<(int)(string::npos)<<endl;
    cout<<"buffer[string::npos]:"<<buffer[string::npos]<<endl;
    cout<<"buffer[length-1]:"<<buffer[length-1]<<endl;
    cout<<"str.copy(buffer,string::npos,5),buffer contains:"<<buffer<<endl;

    length=str.copy(buffer,string::npos);
    buffer[length]='\0';
    cout<<"str.copy(buffer,string::npos),buffer contains:"<<buffer<<endl;
    cout<<"buffer[string::npos]:"<<buffer[string::npos]<<endl;
    cout<<"buffer[length-1]:"<<buffer[length-1]<<endl;
    return 0;
 }
```

### string和int的转换

#### snprintf

```c++
#include<stdio.h>
int main (){
    char a[20];
    int i = snprintf(a, 9, "%012d", 12345);
    printf("i = %d, a = %s", i, a);
    return 0;
 }
```

#### strtol

```c++
#include<iostream>
#include<stdlib.h>
#include<string>
using namespace std;
int main(){
    char *endptr;
    char nptr[]="123abc";
    int ret = strtol(nptr, &endptr, 10 );
    cout<<"ret:"<<ret<<endl;
    cout<<"endptr:"<<endptr<<endl;

    char *endptr2;
    char nptr2[]=" \n\t    abc";
    ret = strtol(nptr2, &endptr2, 10 );
    cout<<"ret:"<<ret<<endl;
    cout<<"endptr2:"<<endptr2<<endl;

    char *endptr8;
    char nptr8[]="0123";
    ret = strtol(nptr8, &endptr8,0);
    cout<<"ret:"<<ret<<endl;
    cout<<"endptr8:"<<endptr8<<endl;

    char *endptr16;
    char nptr16[]="0x123";
    ret = strtol(nptr16, &endptr16,0);
    cout<<"ret:"<<ret<<endl;
    cout<<"endptr16:"<<endptr16<<endl;  

    return 0;
}
```

## vector

### vector概念

- 线性容器，严格按照线性顺序排列，存储在一块连续的内存空间中
- 能自动存储元素，可以自动增长或者缩小内存空间
- 可以使用下标方式访问元素
- 可以使用指针偏移方式访问元素
- 可以使用迭代器访问元素或者遍历容器
- 可以在容器末尾增加或删除元素
- 可以提供和数组一样的性能
- size()返回容器大小，指元素个数
- capacity()返回容量，即容器分配的内存大小，一般容量大于容器大小

### 初始化：

```c++
vector<T> v1;           //空vector，元素类型为T，执行默认初始化
vector<T> v2(v1);       //v2包含v1所有元素的副本
vector<T> v2 = v1;      //同上
vector<T> v3(n, val);   //n个重复元素，每个元素的值都是val
vector<T> v4(n);        //n个初始化后的对象
vector<T> v5{a,b,c};    //个数和大括号中的相同，并赋值对应的值
vector<T> v5={a,b,c};   //等价于上
```

### 遍历容器：

迭代器方法：

```c++
vector<int> v1;
vector<int>::iterator iter;
for(iter = vec.begin(); iter != vec.end(); ++iter) {
    cout<<*iter<<endl;
}
```

```c++
vector<int> v1;
for(v1.begin(), v1.end(), print);
```

```c++
vector<int> v1;
for(int i = 0; i < v1.size() ; ++i) {
    cout<<v1[i]<<endl;
}
```

### 排序元素：

```c++
vector<int> vec;
int cmp(){
}
sort(vec.begin(), vec.end(), cmp);
```

### 查找元素：

```c++
vector<int>::iterator iter = find(vec.begin(), vec.end(), 3);
```

### 插入元素：

```c++
vec.push_back(element);
vec.insert(iterator, element);
```

### 删除元素：

```c++
vec.pop_back();
vec.erase(iterator);
```

```c++
vector<int>::iterator iter=vec.begin();
for(;iter!=vec.end();){
    if(*iter==3){
        iter = vec.erase(iter);
    }else{
        ++iter;
    }
}
```

不能删除后直接对iter直接++操作，因为删除后iter会变成野指针

### 修改元素：

```c++
vec[position] = element;
```

### 其他：

```c++
vec.empty();    //判断是否空
vec.size();    // 实际元素
vec.capacity();    // 容器容量
vec.begin();    // 获得首迭代器
vec.end();    // 获得尾迭代器
vec.clear();    // 清空
```

### vector内存管理

#### 修正过剩内存

```c++
vector<int>(ivec).swap(ivec);
```

`vector<int>(ivec)`表示构建一个临时vector，是ivec的拷贝，临时vector只分配它需要的内存，没有多余内存，交换后，临时vector会有原来vec的多余内存，然后结束时临时vector会被销毁，实现了修整过剩内存

### vector实现：

[模拟Vector实现](https://github.com/linw7/Skill-Tree/blob/master/code/my_vector.cpp)

- 线性表，数组实现。
- 支持随机访问。
- 插入删除操作需要大量移动数据。
- 需要连续的物理存储空间。
- 每当大小不够时，重新分配内存（*2），并复制原内容。

#### vector错误避免：

[迭代器失效](https://github.com/linw7/Skill-Tree/blob/master/code/vector_iterator.cpp)

- 插入元素
  - 尾后插入：size < capacity时，首迭代器不失效尾迭代实现（未重新分配空间），size == capacity时，所有迭代器均失效（需要重新分配空间）。
  - 中间插入：size < capacity时，首迭代器不失效但插入元素之后所有迭代器失效，size == capacity时，所有迭代器均失效。

- 删除元素
  - 尾后删除：只有尾迭代失效。
  - 中间删除：删除位置之后所有迭代失效。

## map

- 一种关联式容器，把`元素的值`和`特定的键`关联起来，建立Key-Value对应关系
- 增加和删除节点对map影响很小
- 不可以修改键值，只能修改对应的实值
- map内部是红黑树，有自动排序功能，所以map中的数据都是有序的，key类型必须支持<操作符
- 查找复杂度：Log(N)
- 需要包含头文件：`#include <map>`
- 默认按照key从小到大排序

```c++
map<T_key, T_value> mymap;
```

### map插入元素：

```c++
mymap.insert(pair<T_key, T_value>(key, value));    // 同key不插入
mymap.insert(map<T_key, T_value>::value_type(key, value));    // 同key不插入
mymap[key] = value;    // 同key覆盖
```

判断是否插入成功：

```c++
map<int, string> mapStudent;
pair< map<int, string>::iterator , bool > insert_pair;
insert_pair = mapStudent.insert( pair<int, string>(1, "student1") );
if(insert_pair.second){}//如果为true，则插入成功
```

### map遍历容器：

迭代器遍历同vector

反向迭代器：

```c++
map<int, string>::reverse_iterator iter;
for(iter = mymap.rbegin(); iter != mymap.rend(); ++iter) {
    cout << iter->first << " => " << iter->second << '\n';
}
```

数组方式：

```c++
int iSize = mapStudent.size();
for(int i=1, i <= iSize; i++){
    cout<<i<<" "<<mapStudent[i]<,endl;
}
```

### map查找元素

- count函数，返回0或1
- find函数，返回一个迭代器，如果没找到，返回的迭代器等于`.end()`的迭代器

```c++
map<int, string> mapStudent;
mapStudent[1] = "1";
mapStudent[2] = "2";
mapStudent[3] = "3";

map<int, string>::iterator iter = map.find(1);
if(iter != mapStudent.end()){
    cout << iter->first << " => " << iter->second << '\n';
}
```

### map删除元素：

```c++
mymap.erase(key);    // 按值删
mymap.erase(iterator);    // 按迭代器删
```

按迭代器删基本同vector

```c++
for(;iter!=mapStudent.end();){
    if((*iter).second == "1" ){
        mapStudennt.erase(iter++);
    }else{
        ++iter;
    }
}
```

### map排序

指定第三个参数Compare

```c++
map<int, string, greater<int> > mapStudent;
```

```c++
struct CmpByKeyLength{
    bool operator()(const string& k1, const string& k2){
        return k1.length() < k2.length();
    }
}
map<string, int, CmpByKeyLength > mapStudent;
```

### map修改元素：

```c++
mymap[key] = new_value;
```

## set

### set概念

- set中每个元素的值都是唯一的
- 根据元素的值自动排序
- 元素的值不能直接改变
- map和set的插入删除效率比其他容器高，因为其中以红黑树的节点方式存储，所以插入删除只需要移动节点
- map和set在insert后，以前的iterator不会失效，因为是以节点方式存储的
- vector在insert后，以前的iterator可能会失效，因为在内存中是以连续方式存储的，所以当插入空间不足是，会重新分配了另一端连续内存
- 不要使用过期的iterator
- set的搜索速度，当数据量增大十倍时，搜索次数只多了一次，因为内部使用的是二分查找

### set使用

- [set code](https://github.com/ChuangLiu727/GetJob/blob/master/C++/code/set.cpp)

## HashMap

### HashMap特点

- hash_map基于hash table（哈希表）。 哈希表最大的优点，就是把数据的存储和查找消耗的时间大大降低，几乎可以看成是常数时间；而代价仅仅是消耗比较多的内存。然而在当前可利用内存越来越多的情况下，用空间换时间的做法是值得的。另外，编码比较容易也是它的特点之一。

### HashMap基本原理

- 使用一个下标范围比较大的数组来存储元素。可以设计一个函数（哈希函数，也叫做散列函数），使得每个元素的关键字都与一个函数值（即数组下标，hash值）相对应，于是用这个数组单元来存储这个元素；
- 按照关键字为每一个元素“分类”，然后将这个元素存储在相应“类”所对应的地方，称为桶。
- 不能够保证每个元素的关键字与函数值是一一对应的，因此极有可能出现对于不同的元素，却计算出了相同的函数值，这样就产生了“冲突”，换句话说，就是把不同的元素分在了相同的“类”之中。 总的来说，“直接定址”与“解决冲突”是哈希表的两大特点。
- 如果每个桶内部只有一个元素，那么查找的时候只有一次比较。当许多桶内没有值时，许多查询就会更快了(指查不到的时候).

### HashMap工作过程

- hash_map，首先分配一大片内存，形成许多桶。
- 利用hash函数，对key进行映射到不同区域（桶）进行保存。

插入过程是：

    得到key
    通过hash函数得到hash值
    得到桶号(一般都为hash值对桶数求模)
    存放key和value在桶内。

取值过程是:

    得到key
    通过hash函数得到hash值
    得到桶号(一般都为hash值对桶数求模)
    比较桶的内部元素是否与key相等，若都不相等，则没有找到。
    取出相等的记录的value。

### hashmap底层实现

- map的底层结构是hmap（即hashmap的缩写），核心元素是一个由若干个桶（bucket，结构为bmap）组成的数组，每个bucket可以存放若干元素（通常是8个），key通过哈希算法被归入不同的bucket中。
- hash_map是一个聚合类，它继承自_Hash类，包括一个vector数组，一个list和一个pair，其中vector数组用于保存桶，list用于进行冲突处理，pair用于保存key->value结构(pair是将2个数据组合成一个数据，stl中的map就是将key和value放在一起来保存)

```c++
class hash_map<class _Tkey, class _Tval>
{
private:
    typedef pair<_Tkey, _Tval> hash_pair;
    typedef list<hash_pair>    hash_list;
    typedef vector<hash_list>  hash_table;
};
```

### hash表中的冲突解决办法

- 开放定址法：依靠数组中的空位解决碰撞冲突
  - 线性探测法：直接检测散列表的下一个位置（即索引值加1），如果仍冲突，继续；
  - 二次探测法：即H + 1^2, H + 2^2, H + 3^2…
  - 伪随机探测
- 再哈希法：使用多个哈希函数，第一个冲突时，使用第二个哈希函数，知道不冲突为止；
- 链地址法：将所有哈希地址相同的关键字，都链接到同一个链表中；

### HashMap扩容机制

- （默认大小为16，负载因子0.75，阈值12）
- Hashmap的扩容需要满足两个条件
  - 当前数据存储的数量（即size()）大小必须大于等于阈值；
  - 当前加入的数据发生了hash冲突。

---

- 阈值 = (数组总大小length,不是数组中个数size) * loadFactor
- 12  =  16 * 0.75
- loadFactor的默认值为0.75，这是一个折中的取值。如果过小，比如0.5，那么当存放的元素超过一半时就进行扩容，会造成资源的浪费；如果过大，比如1，那么当元素满的时候才进行扩容，会使get,put操作的碰撞几率增加。
- 当HashMap中元素个数超过16*0.75=12（这个值就是代码中的threshold值，也叫做临界值）的时候，就把数组的大小扩展为 2*16=32，即扩大一倍，然后重新计算每个元素在数组中的位置。
- 扩容完成后，每个hash对应两个bucket（一个新的一个旧的）。oldbucket不会立即被转移到新的bucket下，而是当访问到该bucket时，会调用growWork方法进行迁移，growWork方法会将oldbucket下的元素rehash到新的bucket中。随着访问的进行，所有oldbucket会被逐渐移动到bucket中。

---

- hashmap在存值的时候，可能达到最后存满16个值的时候，再存入第17个值才会发生扩容现象，因为前16个值，每个值在底层数组中分别占据一个位置，并没有发生hash碰撞。
- 当然也有可能存储更多值（超多16个值，最多可以存26个值）都还没有扩容。原理：前11个值全部hash碰撞，存到数组的同一个位置（这时元素个数小于阈值12，不会扩容），后面所有存入的15个值全部分散到数组剩下的15个位置（这时元素个数大于等于阈值，但是每次存入的元素并没有发生hash碰撞，所以不会扩容），前面11+15=26，所以在存入第27个值的时候才同时满足上面两个条件，这时候才会发生扩容现象。

### hashcode一样怎么办？hashcode和equals的区别

- 通过equals方法判断真正的内容。
- 如果两个对象相等（equals），那么他们一定有相同的哈希值（hash code）。
- 如果两个对象的哈希值相等，那么这两个对象有可能相等也有可能不相等。（需要再通过equals来判断）

## 拉链法

## 线性探测法

