# 标准模板库

- 各种STL基本的增删改查
- 每种容器都提供了很多操作，但实际增删改查我们通常只需要掌握透彻一种方式即可。
- STL就是封装了我们常用的数据结构，所以最先需要了解每种数据结构的特性。而且了解实现方式对我们能够准确、高效使用STL打下了基础。
- 如何避免错误，避免一些未知的错误，比如迭代器失效问题。

- [string](#string)
- [vector](#vector)
- [map](#map)
- [set](#set)
- [hashmap](#hashmap)

## string

- `#include <string>`

### string源码

####

```c++
```

### string声明

```c++
#include<iostream>
#include<string>
using namespace std;
int main(){
    string s;  //声明一个空字符串
    string str1="Spend all your time waiting.";
    string str2="For that second chance.";
    string str3(str1,6);//把下标6当作起始位置
    string str4(str1,6,3);//下标6起始，3个字符长度
    char ch_music[]={"Sarah McLachlan"};
    string str5=ch_music;
    string str6(ch_music);//拷贝构造
    string str7(ch_music,5);//"Sarah"
    string str8(4,'a');//aaaa
    string str9(ch_music+6,ch_music+14);//" McLachlan"
    cout<<"str1:"<<str1<<endl;
    cout<<"str2:"<<str2<<endl;
    cout<<"str3:"<<str3<<endl;
    cout<<"str4:"<<str4<<endl;
    cout<<"str5:"<<str5<<endl;
    cout<<"str6:"<<str6<<endl;
    cout<<"str7:"<<str7<<endl;
    cout<<"str8:"<<str8<<endl;
    cout<<"str9:"<<str9<<endl;
    return 0;
}
```

### c++字符串和c的转换

#### c_str()

- c_str()返回一个以'\0'结尾的字符数组

```c++
#include<iostream>
#include<string>
using namespace std;
int main(){
    string str="Hello world.";
    const char * cstr=str.c_str();//定义一个c字符串指针
    cout<<cstr<<endl;
    str="Abcd.";//当str改变时，使用c_str的内容也会跟着改变
    cout<<cstr<<endl;
    return 0;
}
```

#### c_str()复制

- 将c_str()中的内容复制出来保证有效性
- 使用strncpy将内容复制到了cstr

```c++
#include<iostream>
#include<string>
#include<string.h>
using namespace std;
int main(){
    char * cstr=new char[20];
    string str="Hello world.";
    strncpy(cstr,str.c_str(),str.size());
    cout<<cstr<<endl;
    str="Abcd.";
    cout<<cstr<<endl;
    return 0;
}
```

#### str.copy

```c++
#include<iostream>
#include<string>
using namespace std;

int main (){
    size_t length;
    char buffer[8];
    string str("Test string......");
    cout<<"str:"<<str<<endl;

    //第二个参数7表示复制后最大长度，第三个参数是pos从pos开始
    length=str.copy(buffer,7,5);
    buffer[length]='\0';
    cout<<"str.copy(buffer,7,5),buffer contains: "<<buffer<<endl;

    length=str.copy(buffer,str.size(),5);
    buffer[length]='\0';  
    cout<<"str.copy(buffer,str.size(),5),buffer contains:"<<buffer<<endl;

    length=str.copy(buffer,7,0);
    buffer[length]='\0';
    cout<< "str.copy(buffer,7,0),buffer contains:"<<buffer<<endl;

    //缺省参数pos，默认pos=0；
    length=str.copy(buffer,7);
    buffer[length]='\0';
    cout<<"str.copy(buffer,7),buffer contains:"<<buffer<<endl;

    length=str.copy(buffer,string::npos,5);
    buffer[length]='\0';
    cout<<"string::npos:"<<(int)(string::npos)<<endl;
    cout<<"buffer[string::npos]:"<<buffer[string::npos]<<endl;
    cout<<"buffer[length-1]:"<<buffer[length-1]<<endl;
    cout<<"str.copy(buffer,string::npos,5),buffer contains:"<<buffer<<endl;

    length=str.copy(buffer,string::npos);
    buffer[length]='\0';
    cout<<"str.copy(buffer,string::npos),buffer contains:"<<buffer<<endl;
    cout<<"buffer[string::npos]:"<<buffer[string::npos]<<endl;
    cout<<"buffer[length-1]:"<<buffer[length-1]<<endl;
    return 0;
 }
```

### string和int的转换

#### snprintf

```c++
#include<stdio.h>
int main (){
    char a[20];
    int i = snprintf(a, 9, "%012d", 12345);
    printf("i = %d, a = %s", i, a);
    return 0;
 }
```

#### strtol

```c++
#include<iostream>
#include<stdlib.h>
#include<string>
using namespace std;
int main(){
    char *endptr;
    char nptr[]="123abc";
    int ret = strtol(nptr, &endptr, 10 );
    cout<<"ret:"<<ret<<endl;
    cout<<"endptr:"<<endptr<<endl;

    char *endptr2;
    char nptr2[]=" \n\t    abc";
    ret = strtol(nptr2, &endptr2, 10 );
    cout<<"ret:"<<ret<<endl;
    cout<<"endptr2:"<<endptr2<<endl;

    char *endptr8;
    char nptr8[]="0123";
    ret = strtol(nptr8, &endptr8,0);
    cout<<"ret:"<<ret<<endl;
    cout<<"endptr8:"<<endptr8<<endl;

    char *endptr16;
    char nptr16[]="0x123";
    ret = strtol(nptr16, &endptr16,0);
    cout<<"ret:"<<ret<<endl;
    cout<<"endptr16:"<<endptr16<<endl;  

    return 0;
}
```

## vector

### vector概念

- 线性容器，严格按照线性顺序排列，存储在一块连续的内存空间中
- 能自动存储元素，可以自动增长或者缩小内存空间
- 可以使用下标方式访问元素
- 可以使用指针偏移方式访问元素
- 可以使用迭代器访问元素或者遍历容器
- 可以在容器末尾增加或删除元素
- 可以提供和数组一样的性能
- size()返回容器大小，指元素个数
- capacity()返回容量，即容器分配的内存大小，一般容量大于容器大小

### vector使用

#### 初始化：

```c++
vector<T> v1;           //空vector，元素类型为T，执行默认初始化
vector<T> v2(v1);       //v2包含v1所有元素的副本
vector<T> v2 = v1;      //同上
vector<T> v3(n, val);   //n个重复元素，每个元素的值都是val
vector<T> v4(n);        //n个初始化后的对象
vector<T> v5{a,b,c};    //个数和大括号中的相同，并赋值对应的值
vector<T> v5={a,b,c};   //等价于上
```

#### 遍历容器：

迭代器方法：

```c++
vector<int> v1;
vector<int>::iterator iter;
for(iter = vec.begin(); iter != vec.end(); ++iter) {
    cout<<*iter<<endl;
}
```

```c++
vector<int> v1;
for(v1.begin(), v1.end(), print);
```

```c++
vector<int> v1;
for(int i = 0; i < v1.size() ; ++i) {
    cout<<v1[i]<<endl;
}
```

#### 排序元素：

```c++
vector<int> vec;
int cmp(){
}
sort(vec.begin(), vec.end(), cmp);
```

#### 查找元素：

```c++
vector<int>::iterator iter = find(vec.begin(), vec.end(), 3);
```

#### 插入元素：

```c++
vec.push_back(element);
vec.insert(iterator, element);
```

#### 删除元素：

```c++
vec.pop_back();
vec.erase(iterator);
```

```c++
vector<int>::iterator iter=vec.begin();
for(;iter!=vec.end();){
    if(*iter==3){
        iter = vec.erase(iter);
    }else{
        ++iter;
    }
}
```

不能删除后直接对iter直接++操作，因为删除后iter会变成野指针

#### 修改元素：

```c++
vec[position] = element;
```

#### 其他：

```c++
vec.empty();    //判断是否空
vec.size();    // 实际元素
vec.capacity();    // 容器容量
vec.begin();    // 获得首迭代器
vec.end();    // 获得尾迭代器
vec.clear();    // 清空
```

### vector内存管理

#### 修正过剩内存

```c++
vector<int>(ivec).swap(ivec);
```

`vector<int>(ivec)`表示构建一个临时vector，是ivec的拷贝，临时vector只分配它需要的内存，没有多余内存，交换后，临时vector会有原来vec的多余内存，然后结束时临时vector会被销毁，实现了修整过剩内存

### vector实现：

[模拟Vector实现](https://github.com/linw7/Skill-Tree/blob/master/code/my_vector.cpp)

- 线性表，数组实现。
- 支持随机访问。
- 插入删除操作需要大量移动数据。
- 需要连续的物理存储空间。
- 每当大小不够时，重新分配内存（*2），并复制原内容。

#### vector错误避免：

[迭代器失效](https://github.com/linw7/Skill-Tree/blob/master/code/vector_iterator.cpp)

- 插入元素
  - 尾后插入：size < capacity时，首迭代器不失效尾迭代实现（未重新分配空间），size == capacity时，所有迭代器均失效（需要重新分配空间）。
  - 中间插入：size < capacity时，首迭代器不失效但插入元素之后所有迭代器失效，size == capacity时，所有迭代器均失效。

- 删除元素
  - 尾后删除：只有尾迭代失效。
  - 中间删除：删除位置之后所有迭代失效。

## map

- 一种关联式容器，把`元素的值`和`特定的键`关联起来，建立Key-Value对应关系
- 增加和删除节点对map影响很小
- 不可以修改键值，只能修改对应的实值
- map内部是红黑树，有自动排序功能，所以map中的数据都是有序的，key类型必须支持<操作符
- 查找复杂度：Log(N)
- 需要包含头文件：`#include <map>`
- 默认按照key从小到大排序

```c++
map<T_key, T_value> mymap;
```

### map用法：

#### map插入元素：

```c++
mymap.insert(pair<T_key, T_value>(key, value));    // 同key不插入
mymap.insert(map<T_key, T_value>::value_type(key, value));    // 同key不插入
mymap[key] = value;    // 同key覆盖
```

判断是否插入成功：

```c++
map<int, string> mapStudent;
pair< map<int, string>::iterator , bool > insert_pair;
insert_pair = mapStudent.insert( pair<int, string>(1, "student1") );
if(insert_pair.second){}//如果为true，则插入成功
```

#### map遍历容器：

迭代器遍历同vector

反向迭代器：

```c++
map<int, string>::reverse_iterator iter;
for(iter = mymap.rbegin(); iter != mymap.rend(); ++iter) {
    cout << iter->first << " => " << iter->second << '\n';
}
```

数组方式：

```c++
int iSize = mapStudent.size();
for(int i=1, i <= iSize; i++){
    cout<<i<<" "<<mapStudent[i]<,endl;
}
```

#### map查找元素

- count函数，返回0或1
- find函数，返回一个迭代器，如果没找到，返回的迭代器等于`.end()`的迭代器

```c++
map<int, string> mapStudent;
mapStudent[1] = "1";
mapStudent[2] = "2";
mapStudent[3] = "3";

map<int, string>::iterator iter = map.find(1);
if(iter != mapStudent.end()){
    cout << iter->first << " => " << iter->second << '\n';
}
```

#### map删除元素：

```c++
mymap.erase(key);    // 按值删
mymap.erase(iterator);    // 按迭代器删
```

按迭代器删基本同vector

```c++
for(;iter!=mapStudent.end();){
    if((*iter).second == "1" ){
        mapStudennt.erase(iter++);
    }else{
        ++iter;
    }
}
```

#### map排序

指定第三个参数Compare

```c++
map<int, string, greater<int> > mapStudent;
```

```c++
struct CmpByKeyLength{
    bool operator()(const string& k1, const string& k2){
        return k1.length() < k2.length();
    }
}
map<string, int, CmpByKeyLength > mapStudent;
```

#### map修改元素：

```c++
mymap[key] = new_value;
```

## set

### set概念

- set中每个元素的值都是唯一的
- 根据元素的值自动排序
- 元素的值不能直接改变
- map和set的插入删除效率比其他容器高，因为其中以红黑树的节点方式存储，所以插入删除只需要移动节点
- map和set在insert后，以前的iterator不会失效，因为是以节点方式存储的
- vector在insert后，以前的iterator可能会失效，因为在内存中是以连续方式存储的，所以当插入空间不足是，会重新分配了另一端连续内存
- 不要使用过期的iterator
- set的搜索速度，当数据量增大十倍时，搜索次数只多了一次，因为内部使用的是二分查找

### set使用

- [set code](https://github.com/ChuangLiu727/GetJob/blob/master/C++code/set.cpp)

## hashmap

- hashmap.不用任何库自己实现一个hadhmap你会怎么做？冲突，rehash
hash冲突的几种解决办法
- 5 hashmap的实现，hashtable，concurrenthashmap实现。
- 7 hashmap的实现讲一下吧，讲的很详细了。