# 内存管理

## 什么时候会发生段错误

- 段错误是指程序访问(读写)了系统未给予读写权限的内存空间。
- 访问了不存在的内存空间,访问了系统保护的空间，对只读内存空间写覆盖等，常见的形式有数组越界访问，野指针操作等

## malloc和free原理

- malloc首先挨个检查堆中的内存是否可用，如果可用那么大小是否能满足需求，要是都满足的话就直接用。当遍历了堆中的所有内存块时，要是没有能满足需求的块时就只能通过系统调用向操作系统申请新的内存，然后将新的内存添加到堆中。
- free()函数的实现思路，只要将内存管理块设置为可用就可以了。这样下次调用malloc()函数的时候就可以将该内存块作为可分配块再次进行分配了。

## 如何判断内存泄漏

## 内存溢出

- out of memory
- 指程序申请内存时，没有足够的内存供申请者使用，
- 给了你一块存储int类型数据的存储空间，但是你却存储long类型的数据，那么结果就是内存不够用
- 此时就会报错OOM,即所谓的内存溢出。
- 内存溢出就是你要的内存空间超过了系统实际分配给你的空间，此时系统相当于没法满足你的需求，就会报内存溢出的错误。
- 内存溢出：一个盘子用尽各种方法只能装4个果子，你装了5个，结果掉倒地上不能吃了。这就是溢出。比方说栈，栈满时再做进栈必定产生空间溢出，叫上溢，栈空时再做退栈也产生空间溢出，称为下溢。就是分配的内存不足以放下数据项序列,称为内存溢出。说白了就是我承受不了那么多，那我就报错，

## 内存溢出的原因

- 1.内存中加载的数据量过于庞大，如一次从数据库取出过多数据；
- 2.集合类中有对对象的引用，使用完后未清空，使得JVM不能回收；
- 3.代码中存在死循环或循环产生过多重复的对象实体；
- 4.使用的第三方软件中的BUG；
- 5.启动参数内存值设定的过小

## 内存溢出解决方法

- 第一步，修改JVM启动参数，直接增加内存。(-Xms，-Xmx参数一定不要忘记加。)
- 第二步，检查错误日志，查看“OutOfMemory”错误前是否有其 它异常或错误。
- 第三步，对代码进行走查和分析，找出可能发生内存溢出的位置。
  - 1.检查对数据库查询中，是否有一次获得全部数据的查询。一般来说，如果一次取十万条记录到内存，就可能引起内存溢出。这个问题比较隐蔽，在上线前，数据库中数据较少，不容易出问题，上线后，数据库中数据多了，一次查询就有可能引起内存溢出。因此对于数据库查询尽量采用分页的方式查询。
  - 2.检查代码中是否有死循环或递归调用。
  - 3.检查是否有大循环重复产生新对象实体。
  - 4.检查对数据库查询中，是否有一次获得全部数据的查询。一般来说，如果一次取十万条记录到内存，就可能引起内存溢出。这个问题比较隐蔽，在上线前，数据库中数据较少，不容易出问题，上线后，数据库中数据多了，一次查询就有可能引起内存溢出。因此对于数据库查询尽量采用分页的方式查询。
  - 5.检查List、MAP等集合对象是否有使用完后，未清除的问题。List、MAP等集合对象会始终存有对对象的引用，使得这些对象不能被GC回收。
- 第四步，使用内存查看工具动态查看内存使用情况

## 内存泄漏

- 内存泄漏堆积后的后果是内存溢出。
- 内存泄漏是指你向系统申请分配内存进行使用(new)，可是使用完了以后却不归还(delete)，结果你申请到的那块内存你自己也不能再访问（也许你把它的地址给弄丢了），而系统也不能再次将它分配给需要的程序。
- 是指程序中己动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。
- 内存泄漏并不是指内存在物理上的消失，而是应用程序分配某段内存后，因为设计错误，失去了对该段内存的控制，因而造成了内存的浪费。

---

- 堆内存泄漏（Heap leak）。对内存指的是程序执行中依据须要分配通过malloc,realloc new等从堆中分配的一块内存，再是完毕后必须通过调用相应的 free或者delete 删掉。假设程序的设计的错误导致这部分内存没有被释放，那么此后这块内存将不会被使用，就会产生Heap Leak.
- 系统资源泄露（Resource Leak）.主要指程序使用系统分配的资源比方 Bitmap,handle ,SOCKET等没有使用对应的函数释放掉，导致系统资源的浪费，严重可导致系统效能减少，系统执行不稳定。  

---

- 可使用RAII，RAII(Resource acquisition is initialization)资源获取即初始化,利用C++对象生命周期的概念来控制程序的资源,比如内存,文件句柄,网络连接以及审计追踪(audit trail)等.若希望保持对某个重要资源的跟踪,那么创建一个对象,并将资源的生命周期和对象的生命周期相关联.如此一来,就能够利用C++复杂老练的对象管理设施来管理资源.

## 内存泄漏的分类

- 常发性内存泄漏。发生内存泄漏的代码会被多次执行到，每次被执行的时候都会导致一块内存泄漏。
- 偶发性内存泄漏。发生内存泄漏的代码只有在某些特定环境或操作过程下才会发生。常发性和偶发性是相对的。对于特定的环境，偶发性的也许就变成了常发性的。所以测试环境和测试方法对检测内存泄漏至关重要。
- 一次性内存泄漏。发生内存泄漏的代码只会被执行一次，或者由于算法上的缺陷，导致总会有一块仅且一块内存发生泄漏。比如，在类的构造函数中分配内存，在析构函数中却没有释放该内存，所以内存泄漏只会发生一次。
- 隐式内存泄漏。程序在运行过程中不停的分配内存，但是直到结束的时候才释放内存。严格的说这里并没有发生内存泄漏，因为最终程序释放了所有申请的内存。但是对于一个服务器程序，需要运行几天，几周甚至几个月，不及时释放内存也可能导致最终耗尽系统的所有内存。所以，我们称这类内存泄漏为隐式内存泄漏。