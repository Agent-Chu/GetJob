# 面向对象基础

## 面向对象概念

### @什么是面向对象

- 把数据及对数据的操作方法放在一起
- 对象就是数据和对数据的操作方法的集合

### public/protected/private的区别？

- public的变量和函数在类的内部外部都可以访问。
- protected的变量和函数只能在类的内部和其派生类中访问。
- private修饰的元素只能在类内访问。

### 类对象的存储空间

- 类对象所占内存的大小是由成员变量（静态变量除外）决定的，成员函数是不计算在内的。
- 非静态成员的数据类型大小之和。
- 编译器加入的额外成员变量（如指向虚函数表的指针）。
- 为了边缘对齐优化加入的panding。

---

- 空的类是会占用内存空间的，而且大小是1，原因是C++要求每个实例在内存中都有独一无二的地址。
- 类内部的成员变量：
  - 普通的变量：是要占用内存的，但是要注意对齐原则（这点和struct类型很相似）。
  - static修饰的静态变量：不占用内容，原因是编译器将其放在全局变量区。
- 类内部的成员函数：
  - 普通函数：不占用内存。
  - 虚函数：要占用4个字节，用来指定虚函数的虚拟函数表的入口地址。所以一个类的虚函数所占用的地址是不变的，和虚函数的个数是没有关系的。

### 字段or属性

字段用于存储类中需要的数据，通常是private；属性是一个或者一对方法，允许其他类访问，通常是public，有get和set，其中set有一个隐式参数value用于赋值。通常用get获取字段，set修改字段。

```c++
private int shoutNum = 3;//字段
public int ShoutNum{//属性，对字段进行修改
  get{
    return shoutNum;
  }
  set{
    shoutNum = value;
  }
}

cat.ShoutNum = 5;
```

### this指针

- 通常在class定义时要用到类型变量自身时，因为这时候还不知道变量名（为了通用也不可能固定实际的变量名），就用this这样的指针来使用变量自身。
- this指针是类的指针，指向对象的首地址。
- this指针只能在成员函数中使用，在全局函数、静态成员函数中都不能用this。
- this指针只有在成员函数中才有定义，且存储位置会因编译器不同有不同存储位置。
- 在成员函数开始前构造，成员函数结束后清除
- 一个对象的this指针并不是对象本身的一部分，不会影响sizeof(对象)的结果

## @面向对象优点

- （1）容易设计和实现，面向对象思想所应用的封装、继承、多态都是符合人类日常的思维习惯，所以使用面向对象思想设计的程序结构清晰、更容易设计和实现。　　
- （2）复用设计和代码，开发效率和系统质量都得到了提高，面向对象思想的继承和多态，强调了程序设计和代码的重用
- （3）容易扩展，利用面向对象思想的封装、继承和多态，可以设计出“高内聚、低耦合”的系统结构，可以让系统更加灵活、更容易扩展，从而轻松应对系统的扩展需求，降低维护成本。

## 面向对象三大特性

### 封装

- 隐藏对象的属性和实现细节，仅对外提供公共访问方式，将变量隔离，便于使用，提高复用性和安全性。
- 数据和代码捆绑在一起，避免外界干扰和不确定性访问。
- 每个对象都包含它能做的操作的所有信息，不依赖别的对象完成自己的操作。

优点：

- 减少耦合：可以独立的开发、测试、优化、使用、修改
- 类内部可以自由修改
- 类有清晰的对外接口
- 减轻维护负担，不影响其他模块
- 方便性能评估，分模块测试性能
- 可重用性，模块可以独立使用，降低大型系统风险

```c++
public class Person {

    private String name;
    //虽然gender用的是int存储，但是外界看不到，在get方法中可以进行修改
    private int gender;
    //外界无法获得age，没有get方法，但是可以被类内的work方法使用
    private int age;

    public String getName() {
        return name;
    }

    public String getGender() {
        return gender == 0 ? "man" : "woman";
    }

    public void work() {
        if (18 <= age && age <= 50) {
            System.out.println(name + " is working very hard!");
        } else {
            System.out.println(name + " can't work any more!");
        }
    }
}
```

### @继承

- 提高代码复用性；继承是多态的前提。
- 让某种类型对象获得另一个类型对象的属性和方法。
- 继承是is-a关系，如果B是A，则说明B能继承A。
- 父类-子类，基类-派生类，子类继承的同时也有自己的新特性
- 遵循里氏替换原则。类B继承类A时，除添加新的方法完成新增功能外，尽量不要重写父类A的方法，也尽量不要重载父类A的方法。
- 子类拥有父类的protected和public的属性和功能
- 子类有自己的属性和功能
- 子类可以重写父类方法

父类：

```c++
class Animal{
  public Animal(string name){
    this.name=name;
  }
  public Animal(){
    this.name="无名";
  }
}
```

子类：用base关键字代表父类，子类的构造函数的重写由是否有同样的参数来判断

```c++
class Cat:Animal{
  public Cat():base(){//重写父类构造函数
  }
  public Cat(string name):base(name){
  }
}
```

#### 缺点：

- 破坏包装，父类实现的细节会暴漏给子类
- 增加耦合性，当需要对父类的代码进行修改时，必须考虑到对子类产生的影响。有时修改了一点点代码都有可能需要对打断程序进行重构。
- 继承是侵入性的。只要继承，就必须拥有父类的所有属性和方法。
- 降低了代码的灵活性。因为继承时，父类会对子类有一种约束。
- 继承应该遵循里氏替换原则，子类对象必须能够替换掉所有父类对象。

#### 派生类的构造函数和析构函数

- 子类构造函数只需要对新增加的成员变量进行初始化，原来基类的成员变量还由基类的构造函数负责
- 同理，子类析构也只需要对子类新增加的成员变量进行回收，子类不能继承基类的析构函数
- 子类构造函数顺序：基类构造函数，基类中的子对象的构造函数，子类构造函数
- 子类有多个子对象时，子对象的构造取决于子类中定义时的顺序

- 析构函数顺序：派生类析构，派生类的成员类的对象的析构，基类的析构

### @多态

- 概念：向不同对象发送同一消息，在接收时会产生不同行为
- 实现方法：重写（编译时多态），虚函数（运行时多态）
- 属性不存在重写，只有方法(非私有方法、非静态方法、非final方法) 才存在重写，才能发生多态；

```c++
class Animal{
  public virtual string Shout(){
    return "";
  }
}

class Cat:Animal{
  public override string Shout(){}
    ....
  }
}
```

## @类默认生成的6个函数

- 首先，空类大小为1字节。
- 构造函数
- 拷贝构造函数
- 析构函数
- 赋值运算符重载，重载等号，用于赋值
- 取地址运算符重载
- const修饰的取地址运算符重载

```
class A {
public:
  A(); //构造函数
  A(const A& a); //拷贝构造函数
  ~A(); //析构函数
  A& operator =(const A& a); //赋值运算符重载，返回值为该类类型的引用，通过operator关键字后加上要重载的符号完成，它视情况也有参数。
  A* operator &(); //取址运算符重载，返回值为该类型的指针，无参数。
  const A* operator &() const; //取址运算符重载，不同的是在函数名前和函数体前各加一个const
};
```

## 构造函数的特性

- 初始化对象，有且仅在定义一个对象时自动执行一次的函数，就称为构造函数。
- 类的数据成员是不能在声明类的时候初始化的，因为类并不是一个实体，而是一种抽象的数据类型，并不占据存储空间。

- （1）函数名与类名相同。
- （2）无返回值。
- （3）实例化对象时系统会自动调用对应的构造函数。
- （4）构造函数可以重载。
- （5）构造函数可以在类内定义，也可以在类外定义。在类外定义时的格式：类名+“::”+函数名。
- （6）如果类定义中没有给出构造函数，则C++编译器会自动生成一个缺省的构造函数；如果我们定义了一个构造函数，系统就不会生成缺省的构造函数。
- （7）无参的构造函数和缺省的构造函数都认为是缺省的构造函数，所以缺省的构造函数只能有一个。

## 析构函数不能抛出异常

- 1.不要在析构函数中抛出异常！虽然C++并不禁止析构函数抛出异常，但这样会导致程序过早结束或出现不明确的行为。
- 2.如果某个操作可能会抛出异常，class应提供一个普通函数（而非析构函数），来执行该操作。目的是给客户一个处理错误的机会。
- 3.如果析构函数中异常非抛不可，那就用try catch来将异常吞下，但这样方法并不好，我们提倡有错早些报出来。

## 构造函数不能抛出异常

- 1.构造函数中抛出异常，会导致析构函数不能被调用，但对象本身已申请到的内存资源会被系统释放（已申请到资源的内部成员变量会被系统依次逆序调用其析构函数）。
- 2.因为析构函数不能被调用，所以可能会造成内存泄露或系统资源未被释放。
- 3.构造函数中可以抛出异常，但必须保证在构造函数抛出异常之前，把系统资源释放掉，防止内存泄露。

## 拷贝构造函数

- 拷贝构造函数是一种特殊的构造函数，函数的名称必须和类名称一致，它必须的一个参数是本类型的一个引用变量。

```
//拷贝构造函数
CExample(const CExample& C){
  a = C.a;
}
```

## 拷贝构造函数调用时机

- 当函数的参数为类的对象时
- A对象传入形参时，会先会产生一个临时变量，就叫 C 吧。
- 然后调用拷贝构造函数把A的值给C。 整个这两个步骤有点像：CExample C(A);
- 等g_fun()执行完后, 析构掉 C 对象。  

```c++
void g_Fun(CExample C){
  cout<<"test"<<endl;
}
```

- 对象以值传递的方式从函数返回
- 先会产生一个临时对象
- 然后调用拷贝构造函数把temp的值给临时对象。
- 在函数执行到最后先析构temp局部变量。
- 等g_fun()执行完后再析构掉临时对象。  

```c++
//全局函数
CExample g_Fun(){
 CExample temp(0);
 return temp;
}
```

- 对象需要通过另外一个对象进行初始化

```c++
CExample A(100);
CExample B = A;
```

## 构造函数调用顺序

- 基类的构造函数：如果有多个基类，先调用纵向上最上层基类构造函数，如果横向继承了多个类，调用顺序为派生表从左到右顺序。
- 成员类对象的构造函数：如果类的变量中包含其他类（类的组合），需要在调用本类构造函数前先调用成员类对象的构造函数，调用顺序遵照在类中被声明的顺序。
- 派生类的构造函数。

## 析构函数调用顺序

析构函数在对象生命周期结束时自动执行

- 一般情况下，析构函数次序正好和构造函数相反，先构造的后析构
- 函数中定义了一个对象，函数调用结束时，对象会被释放，释放前自动执行析构函数
- static局部对象在mian函数结束或者exit时才执行对象的析构函数
- 全局对象在mian函数结束或者exit时才执行对象的析构函数、
- new建立的对象，在delete释放时，才执行析构函数

## @拷贝构造函数中深拷贝和浅拷贝区别？

- 深拷贝时，当被拷贝对象存在动态分配的存储空间时，需要先动态申请一块存储空间，然后逐字节拷贝内容。
- 浅拷贝仅仅是拷贝指针字面值。
- 当使用浅拷贝时，如果原来的对象调用析构函数释放掉指针所指向的数据，则会产生空悬指针。因为所指向的内存空间已经被释放了。

## @拷贝构造函数和赋值运算符重载的区别？

- 拷贝构造函数是函数，赋值运算符是运算符重载。
- 拷贝构造函数会生成新的类对象，赋值运算符不能。
- 拷贝构造函数是直接构造一个新的类对象，所以在初始化对象前不需要检查源对象和新建对象是否相同；赋值运算符需要上述操作并提供两套不同的复制策略，另外赋值运算符中如果原来的对象有内存分配则需要先把内存释放掉。
- 形参传递是调用拷贝构造函数（调用的被赋值对象的拷贝构造函数），但并不是所有出现"="的地方都是使用赋值运算符，如下：

```c++
Student s;
Student s1 = s;    // 调用拷贝构造函数
Student s2;
s2 = s;    // 赋值运算符操作
```

**注：类中有指针变量时要重写析构函数、拷贝构造函数和赋值运算符**

## 构造函数和析构函数调用时机

- 全局范围中的对象：构造函数在所有函数调用之前执行，在主函数执行完调用析构函数。
- 局部自动对象：建立对象时调用构造函数，函数结束时调用析构函数。
- 动态分配的对象：建立对象时调用构造函数，调用释放时调用析构函数。
- 静态局部变量对象：建立时调用一次构造函数，主函数结束时调用析构函数。

## 哪几种情况必须用到初始化成员列表？

- 常量成员，因为常量只能初始化不能赋值，所以必须放在初始化列表里面
- 引用(reference)类型，引用必须在定义的时候初始化，并且不能重新赋值，所以也要写在初始化列表里面 
- 没有默认构造函数的类类型，因为使用初始化列表可以不必调用默认构造函数来初始化，而是直接调用拷贝构造函数初始化
- 调用一个基类的构造函数，而该函数有一组参数。
- 调用一个数据成员对象的构造函数，而该函数有一组参数。

## 析构函数能否为虚函数

- 析构函数可以为虚函数，并且一般情况下基类析构函数要定义为虚函数。
- 只有在基类析构函数定义为虚函数时，调用操作符delete销毁指向对象的基类指针时，才能准确调用派生类的析构函数（从该级向上按序调用虚函数），才能准确销毁数据，防止资源泄漏等问题
- 析构函数可以是纯虚函数，含有纯虚函数的类是抽象类，此时不能被实例化。但派生类中可以根据自身需求重新改写基类中的纯虚函数。

## 为什么C++默认的析构函数不是虚函数

- 默认不是虚析构函数是因为如果析构函数为虚函数就需要编译器在类中增加虚函数表来实现虚函数机制，这样所需内存空间就更大了，因此没有必要默认为虚析构函数。

## 构造函数能否为虚函数

- 构造函数不能定义为虚函数
- 构造函数中还不能调用虚函数。因为那样实际执行的是父类对应的函数，因为自己还没有构造好（构造顺序先基类再派生类）。

## @在main执行之前执行的代码

- 全局对象的构造函数。

## 如何不在main函数中打印

- 使用构造和析构都可以

```c++
#include <iostream>
using namespace std;

class A{
public:
    A(){
        cout << "hello word" << endl;
    };
    ~A(){
        cout << "hello word" << endl;
    }
};

A a;

int main()
{
    //cout << "main" << endl;
    return 0;
}
```

## 虚函数

- 虚函数是为了实现动态编联产生的
- 虚函数的作用是允许在派生类中重新定义与基类同名的函数，并且可以通过基类指针或引用来访问基类和派生类中的同名函数。
- 基类类型的指针指向不同对象时，自动调用相应的、和基类同名的函数（使用同一种调用形式，既能调用派生类又能调用基类的同名函数）。
- 虚函数需要在基类中加上virtual修饰符修饰，因为virtual会被隐式继承，所以子类中同名函数都是虚函数。
- 在派生类中重新定义此函数时要求函数名、返回值类型、参数个数和类型全部与基类函数相同。
- 派生类中可以不加virtual关键字，但是为了清晰推荐加上

---

- 如果这个类可能作为基类，并且类的成员函数被继承后可能会发生改变，一般声明成虚函数
- 如果成员函数是通过指针或者引用来访问，则声明成虚函数`pt->display()`
- 虚函数可以不定义具体函数体，具体功能留给子类实现

```c++
class Parent{
public:
    char data[20];
    void Function1();
    virtual void Function2();   // 这里声明Function2是虚函数
}parent;
```

```c++
class Child:public Parent{
    void Function1();
    void Function2();
} child;
```

```c++
int main(int argc, char* argv[])
{
    Parent *p;  　　　　　// 定义一个基类指针
    if(_getch()=='c')    // 如果输入一个小写字母c
        p=&child;        // 指向继承类对象
    else
        p=&parent;       // 否则指向基类对象
    p->Function1();  　　 // 这里在编译时会直接给出Parent::Function1()的入口地址。总是输出基类的function1
    p->Function2();
    // 注意这里，执行的是哪一个Function2？
    //如果指向了child，则会执行child的Function2
    //如果指向了parent，则会执行parent的Function2
    return 0;
}
```

## 纯虚函数

- 纯虚函数只是相当于一个接口名，但含有纯虚函数的类不能够实例化。
- C++中包含纯虚函数的类，被称为是“抽象类”。抽象类不能使用new出对象，只有实现了这个纯虚函数的子类才能new出对象。
- C++中的纯虚函数更像是“只提供申明，没有实现”，是对子类的约束，是“接口继承”。
- C++中的纯虚函数也是一种“运行时多态”。

```c++
class a
{
  private:

  public:
    a(){      //构造函数用内联函数的形式
    }
    //虚函数
    virtual  void  xhs(){//这个虚函数必须得在基类中实现
      cout<<"我是基类的虚函数"<<endl;//即使是空的虚函数也要在基类中实现
    }  //派生类中可以不写这个函数，但是派生类对象调用时会调用积累的虚函数

    //纯虚函数
    virtual void cxhs() =0;  //这个纯虚函数不在基类中实现，必须在子类中实现

};
class b:public a
{
  private:

    public:
      void xhs(){         //这个是可有可无的 
        cout<<"我是派生类覆盖基类虚函数的函数"<<endl;
    }

    void cxhs(){         //这个是必须有实现的
      cout<<"我是派生类覆盖基类虚函数的函数"<<endl;
    }
};
```

## 虚函数表（运行时多态）

- 虚函数的地址存放于虚函数表之中。运行期多态就是通过虚函数和虚函数表实现的。
- 类的对象内部会有指向类内部的虚表地址的指针。通过这个指针调用虚函数。
- 每个包含了虚函数的类都包含一个虚表。
- 当一个类（A）继承另一个类（B）时，类A会继承类B的函数的调用权。所以如果一个基类包含了虚函数，那么其继承类也可调用这些虚函数，换句话说，一个类继承了包含虚函数的基类，那么这个类也拥有自己的虚表。

我们来看以下的代码。类A包含虚函数vfunc1，vfunc2，由于类A包含虚函数，故类A拥有一个虚表。

```c++
class A {
public:
    virtual void vfunc1();
    virtual void vfunc2();
    void func1();
    void func2();
private:
    int m_data1, m_data2;
};
```

- 虚表是一个指针数组，其元素是虚函数的指针，每个元素对应一个虚函数的函数指针。
- 普通的函数即非虚函数，其调用并不需要经过虚表，所以虚表的元素并不包括普通函数的函数指针。
- 虚表内的条目，即虚函数指针的赋值发生在编译器的编译阶段，也就是说在代码的编译阶段，虚表就可以构造出来了。

## 虚指针

- 为了指定对象的虚表，对象内部包含一个虚表的指针，来指向自己所使用的虚表。为了让每个包含虚表的类的对象都拥有一个虚表指针，编译器在类中添加了一个指针，*__vptr，用来指向虚表。这样，当类的对象在创建时便拥有了这个指针，且这个指针的值会自动被设置为指向类的虚表。
- 虚指针或虚函数指针是虚函数的实现细节。
- 虚指针指向虚表结构。
- 每个对象调用的虚函数都是通过虚表指针来索引的
- 每一个派生类都有虚表。
- 虚表可以继承，如果子类没有重写虚函数，那么子类虚表中仍然会有该函数的地址，只不过这个地址指向的是基类的虚函数实现。如果基类有3个虚函数，那么基类的虚表中就有三项（虚函数地址），派生类也会有虚表，至少有三项，如果重写了相应的虚函数，那么虚表中的地址就会改变，指向自身的虚函数实现。如果派生类有自己的虚函数，那么虚表中就会添加该项。
- 派生类的虚表中虚函数地址的排列顺序和基类的虚表中虚函数地址排列顺序相同。

## 动态绑定

- 有一个基类，两个派生类，基类有一个virtual函数，两个派生类都覆盖了这个虚函数。当有一个基类的指针或者引用，该基类的指针或者引用指向不同的派生类对象时，调用该虚函数，那么最终调用的应该是被指向对象所对应的派生类实现的虚函数。

---

- 实现动态绑定，即在运行时能够找到派生类自己实现的虚函数，是因为可以在运行时动态的改变基类指针所指向的对象，即该基类指针指向的地址是可以变化的。对象的内部保存了关于自己和父类的虚函数的关系。因为每次基类都是指向对象本身的，而基类通过对象本身找到了所对应的的虚函数，即派生类的虚函数。
- 虚函数是类的成员，是所有的对象共有的，因此要特殊保存虚函数应该是类的事情，而不是对象的工作，对象只负责能够找到它就可以了。
- 编译器会为每个有虚函数的类创建一个虚函数表，里面记录着每个虚函数。另外，每个对象都有一个隐含指针，指向它对应的类的虚函数表。
- 这样，在运行时动态绑定会按照以下过程调用：
  - 首先，基类指针被赋值为派生类中对象的地址，那么就可以找到指向这个类的虚函数的隐含指针；然后通过该虚函数的名字就可以在这个虚函数表中找到对应虚函数的地址，从而进行调用。
  - 由于继承层次中每个类都有自己的虚函数表，因此各自完成自己的动态绑定，互不影响。

## @覆盖（重写）、重载和隐藏的区别？

- 重载(overloading) 是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。
- 覆盖是派生类中重新定义的函数，其函数名、参数列表（个数、类型和顺序）、返回值类型和父类完全相同，只有函数体有区别。派生类虽然继承了基类的同名函数，但用派生类对象调用该函数时会根据对象类型调用相应的函数。覆盖只能发生在类的成员函数中。
- 隐藏是指派生类函数屏蔽了与其同名的函数，这里仅要求基类和派生类函数同名即可。其他状态同覆盖。可以说隐藏比覆盖涵盖的范围更宽泛，毕竟参数不加限定。
- 重载是具有相同函数名但参数列表不同（个数、类型或顺序）的两个函数（不关心返回值），当调用函数时根据传递的参数列表来确定具体调用哪个函数。重载可以是同一个类的成员函数也可以是类外函数。

## 重载和函数模板的区别？

- 重载需要多个函数，这些函数彼此之间函数名相同，但参数列表中参数数量和类型不同。在区分各个重载函数时我们并不关心函数体。
- 模板函数是一个通用函数，函数的类型和形参不直接指定而用虚拟类型来代表。但只适用于参个数相同而类型不同的函数。

## 类模板是什么？

- 用于解决多个功能相同、数据类型不同的类需要重复定义的问题。
- 在建立类时候使用template及任意类型标识符T，之后在建立类对象时，会指定实际的类型，这样才会是一个实际的对象。
- 类模板是对一批仅数据成员类型不同的类的抽象，只要为这一批类创建一个类模板，即给出一套程序代码，就可以用来生成具体的类。

用类模版实现两个数加减的操作

```c++
#include <iostream>

using namespace std;

template<class T>
class Operation{
public:
    Operation(T a,T b):x(a),y(b){}
    T add(){
        return x+y;
    }
    T sub(){
        return x-y;
    }
private:
    T x,y;
};

int main(int argc, const char * argv[]) {
    Operation<int> op_int(1,2);
    cout<<op_int.add()<<endl;
    cout<<op_int.sub()<<endl;
}
```

## @接口

- 接口提供一个与其他系统交互的方法。其他系统无需了解你内部细节，并且也无法了解内部细节，只能通过你提供给外部的接口来与你进行通信。
- 根据c++的特点，我们可以采用纯虚函数的方式来实现。这样做的好处是能够实现封装和多态。
- 如果是抽象类实现接口，可以实现部分方法甚至一个都不实现，具体类才必须实现接口的所有方法。
- 一个类可以实现多个接口
- 接口间可以有继承关系
- 继承树的非叶子节点应该都是抽象类，叶子节点都是具体类

```c++
Class IPerson{
public：

   IPerson() {};

   virtual ~IPerson()=0 {}; //注意，最好定义此虚析构函数，够避免子类不能正常调用析构函数；如果定义为纯虚析构函数，则必须带定义体，因为子类隐含调用该析构函数。

   //提供给外面使用的接口一般采用纯虚函数

   virtual  void SetName（const string &strName）= 0;

   virtual  const string GetName（）= 0;

   virtual  void Work（）= 0;

}
```

## 接口的限制

- 接口一定要有它的实现类，否则就没有意义。
- 接口中的方法只能是抽象方法。且默认为public abstract 修饰
- 接口中不能够成员变量，只能有静态常量，默认为public static final修饰
- 接口中的方法:必须是public的抽象方法
- 接口可以被多继承、 接口不能被实例化
- 不能有构造函数

## @抽象类（abstract class）与接口区别：

- abstract class类中的方法不必是抽象的。abstract class类中定义抽象方法必须在具体(Concrete)子类中实现，所以，不能有抽象构造方法或抽象静态方法。如果的子类没有实现抽象父类中的所有抽象方法，那么子类也必须定义为abstract类型。
- 接口（interface）可以说成是抽象类的一种特例，接口中的所有方法都必须是抽象的。接口中的方法定义默认为public abstract类型，接口中的成员变量类型默认为public static final。

|抽象类|接口|
|---|---|
|抽象类是对类的抽象|接口是对某种行为的抽象|
|可以给出一些成员的实现|不包含成员的实现|
|抽象成员函数可以在子类中部分实现|接口成员必须完全实现|
|一个类只能继承一个抽象类|一个类可以实现多个接口|
|对一些相似的对象用抽象类|对一些相似的行为用接口|
|泛化子类公共的特点|预先定义|
|抽象类可以有构造函数|接口不可以有构造函数|
|抽象类中可以有普通成员变量|接口中没有普通成员变量，只能有常量|
|抽象类中的方法可以被static修饰|接口中的方法不可以被static修饰|
|抽象类中可以有普通方法和抽象方法|接口中的方法全是抽象方法|
|抽象类主要用于当做基类使用，拥有一些方法，并且这些方法有默认实现|接口主要用于模块与模块之间的调用。实现多继承|
|抽象类中的抽象方法的访问类型可以是public，protected|接口中的抽象方法只能是public类型的，并且默认即为public abstract类型|
|抽象类中的静态成员变量的访问类型可以任意|接口中定义的变量只能是public static final类型，并且默认即为public static final类型|

## 集合ArrayList

ArrayList就是动态数组，可以动态的增加和减少元素，实现了ICollection和IList接口，灵活的设置数组的大小

```c++
using System.Collections;

IList arraylist;
arraylist = new ArrayList();
//or ArrayList arraylist = new ArrayList();

List.Add(i);
```

- Add方法用于添加一个元素到当前列表的末尾
- AddRange方法用于添加一批元素到当前列表的末尾
- Remove方法用于删除一个元素，通过元素本身的引用来删除
- RemoveAt方法用于删除一个元素，通过索引值来删除
- RemoveRange用于删除一批元素，通过指定开始的索引和删除的数量来删除
- Insert用于添加一个元素到指定位置，列表后面的元素依次往后移动
- InsertRange用于从指定位置开始添加一批元素，列表后面的元素依次往后移动
- Clear方法用于清除现有所有的元素
- Contains方法用来查找某个对象在不在列表之中

## 泛型

指定数据类型

```c++
IList<Animal> arraylist;
arraylist = new ArrayList<Animal>();
```

## 函数调用过程

- 函数调用者向被调用者传递一些参数，然后执行被调用者的代码，最后被调用者向调用者返回结果
- 函数调用是在栈上发生的
- 当函数从入口函数main函数开始执行时，编译器会将我们操作系统的运行状态，main函数的返回地址、main的参数、mian函数中的变量、进行依次压栈；当main函数开始调用fa()函数时，编译器此时会将main函数的运行状态进行压栈，再将fa()含糊的返回地址、fa函数的参数、fa定义变量依次压栈；当fa调用fb的时候，编译器此时会将fa函数的运行状态进行压栈，再将fb含糊的返回地址、fb函数的参数、fb定义变量依次压栈。

## C语言参数压栈顺序

- 从右到左
- printf()函数，printf函数的原型是：printf（const char* format,…）是一个不定参函数
- 在实际使用中靠format知道它的参数个数，编译器通过format中的%占位符的个数来确定参数的个数。
- 现在我们假设参数的压栈顺序是从左到右的，这时，函数调用的时候，format最先进栈，之后是各个参数进栈，最后pc进栈，此时，由于format先进栈了，上面压着未知个数的参数，想要知道参数的个数，必须找到format，而要找到format，必须要知道参数的个数，这样就陷入了一个无法求解的死循环
- 而如果把参数从右到左压栈，情况又是怎么样的？函数调用时，先把若干个参数都压入栈中，再压format，最后压pc，这样一来，栈顶指针加2便找到了format，通过format中的%占位符，取得后面参数的个数，从而正确取得所有参数。
- 所以，如果不存在这种不定参的函数，则参数的压栈顺序无论是从左到右还是从右到左都是没关系的。

## C++如何处理返回值

## C++中拷贝赋值函数的形参只能是引用

- 不能传值或指针
- 防止无限循环递归

```c++
class Example(){
public:
    Example(int a):aa(a) {}//构造函数

    //拷贝构造函数（值传递参数）
    Example(Example ex){
        aa = ex.aa;
    }
private:
    int aa;
};

int main(){
    Example e1(10);
    Example e2 = e1;
    return 0;
}
```

- 执行 Example e2 = e1; 时调用了拷贝构造函数（传值型的），相当于 e2.Example(e1);
- 在函数中，因为是值传递所以又需要用e1的值拷贝创建一个副本对象ex，则又需要调用拷贝构造函数ex.Example(e1)
- 这样就会无限重复下去来完成创建副本ex，无限调用ex.Example(e1)
- 这就是为什么拷贝构造函数不能使用值传递的形参原因。

正确拷贝构造函数：

```c++
Example(const Example &ex){
    aa = ex.aa;
}
```