# 面向对象基础

## 1.对象基础

### @什么是面向对象

- 把数据及对数据的操作方法放在一起
- 对象就是数据和对数据的操作方法的集合

### public/protected/private的区别？

- public的变量和函数在类的内部外部都可以访问。
- protected的变量和函数只能在类的内部和其派生类中访问。
- private修饰的元素只能在类内访问。

### 对象存储空间？

- 非静态成员的数据类型大小之和。
- 编译器加入的额外成员变量（如指向虚函数表的指针）。
- 为了边缘对齐优化加入的panding。

### C++空类有哪些成员函数

- 首先，空类大小为1字节。
- 默认函数有：
  - 构造函数
  - 析构函数
  - 拷贝构造函数
  - 赋值运算符

### 字段or属性

字段用于存储类中需要的数据，通常是private；属性是一个或者一对方法，允许其他类访问，通常是public，有get和set，其中set有一个隐式参数value用于赋值。通常用get获取字段，set修改字段。

```c++
private int shoutNum = 3;
public int ShoutNum{
  get{
    return shoutNum;
  }
  set{
    shoutNum = value;
  }
}

cat.ShoutNum = 5;
```

### this指针是什么？

- this指针是类的指针，指向对象的首地址。
- this指针只能在成员函数中使用，在全局函数、静态成员函数中都不能用this。
- this指针只有在成员函数中才有定义，且存储位置会因编译器不同有不同存储位置。
- 在成员函数开始前构造，成员函数结束后清除
- this是类的指针

## @面向对象优点

- （1）容易设计和实现，面向对象思想所应用的封装、继承、多态都是符合人类日常的思维习惯，所以使用面向对象思想设计的程序结构清晰、更容易设计和实现。　　
- （2）复用设计和代码，开发效率和系统质量都得到了提高，面向对象思想的继承和多态，强调了程序设计和代码的重用
- （3）容易扩展，利用面向对象思想的封装、继承和多态，可以设计出“高内聚、低耦合”的系统结构，可以让系统更加灵活、更容易扩展，从而轻松应对系统的扩展需求，降低维护成本。

## 2.面向对象三大特性

### 封装

隐藏对象的属性和实现细节，仅对外提供公共访问方式，将变量隔离，便于使用，提高复用性和安全性。

数据和代码捆绑在一起，避免外界干扰和不确定性访问。

每个对象都包含它能做的操作的所有信息，不依赖别的对象完成自己的操作。

优点：

- 减少耦合：可以独立的开发、测试、优化、使用、修改
- 类内部可以自由修改
- 类有清晰的对外接口
- 减轻维护负担，不影响其他模块
- 方便性能评估，分模块测试性能
- 可重用性，模块可以独立使用，降低大型系统风险

```c++
public class Person {

    private String name;
    //虽然gender用的是int存储，但是外界看不到，在get方法中可以进行修改
    private int gender;
    //外界无法获得age，没有get方法，但是可以被类内的work方法使用
    private int age;

    public String getName() {
        return name;
    }

    public String getGender() {
        return gender == 0 ? "man" : "woman";
    }

    public void work() {
        if (18 <= age && age <= 50) {
            System.out.println(name + " is working very hard!");
        } else {
            System.out.println(name + " can't work any more!");
        }
    }
}
```

### @继承

- 提高代码复用性；继承是多态的前提。
- 让某种类型对象获得另一个类型对象的属性和方法。
- 继承是is-a关系，如果B是A，则说明B能继承A。
- 父类-子类，基类-派生类，子类继承的同时也有自己的新特性
- 遵循里氏替换原则。类B继承类A时，除添加新的方法完成新增功能外，尽量不要重写父类A的方法，也尽量不要重载父类A的方法。
- 子类拥有父类的protected和public的属性和功能
- 子类有自己的属性和功能
- 子类可以重写父类方法

父类：

```c++
class Animal{
  public Animal(string name){
    this.name=name;
  }
  public Animal(){
    this.name="无名";
  }
}
```

子类：用base关键字代表父类，子类的构造函数的重写由是否有同样的参数来判断

```c++
class Cat:Animal{
  public Cat():base(){//重写父类构造函数
  }
  public Cat(string name):base(name){
  }
}
```

#### 缺点：

- 破坏包装，父类实现的细节会暴漏给子类
- 增加耦合性，当需要对父类的代码进行修改时，必须考虑到对子类产生的影响。有时修改了一点点代码都有可能需要对打断程序进行重构。
- 继承是侵入性的。只要继承，就必须拥有父类的所有属性和方法。
- 降低了代码的灵活性。因为继承时，父类会对子类有一种约束。
- 继承应该遵循里氏替换原则，子类对象必须能够替换掉所有父类对象。

#### 派生类的构造函数和析构函数

- 子类构造函数只需要对新增加的成员变量进行初始化，原来基类的成员变量还由基类的构造函数负责
- 同理，子类析构也只需要对子类新增加的成员变量进行回收，子类不能继承基类的析构函数
- 子类构造函数顺序：基类构造函数，基类中的子对象的构造函数，子类构造函数
- 子类有多个子对象时，子对象的构造取决于子类中定义时的顺序

- 析构函数顺序：派生类析构，派生类的成员类的对象的析构，基类的析构

### @多态

- 概念：向不同对象发送同一消息，在接收时会产生不同行为
- 实现方法：重写（编译时多态），虚函数（运行时多态）
- 属性不存在重写，只有方法(非私有方法、非静态方法、非final方法) 才存在重写，才能发生多态；

```c++
class Animal{
  public virtual string Shout(){
    return "";
  }
}

class Cat:Animal{
  public override string Shout(){}
    ....
  }
}
```

## 3.构造函数和析构函数

### 拷贝构造函数

```c++
#include <iostream>
using namespace std;

class CExample {
private:
    int a;
public:
    //构造函数
    CExample(int b){
        a = b;
    }
    //拷贝构造函数
    CExample(const CExample& C){
        a = C.a;
    }
    //一般函数
    void Show (){
        cout<<a<<endl;
    }
};

int main()
{
    CExample A(100);
    CExample B = A; // CExample B(A); 也是一样的
    B.Show ();
    return 0;
}
```

- 拷贝构造函数是一种特殊的构造函数，函数的名称必须和类名称一致，它必须的一个参数是本类型的一个引用变量。

- 对象以值传递的方式传入函数参数

```c++
//全局函数，传入的是对象
void g_Fun(CExample C)
{
 cout<<"test"<<endl;
}
```

- 对象以值传递的方式从函数返回

```c++
//全局函数
CExample g_Fun()
{
 CExample temp(0);
 return temp;
}
```

- 对象需要通过另外一个对象进行初始化

```c++
CExample A(100);
CExample B = A;
```


### 在main执行之前执行的代码可能是什么？

- 全局对象的构造函数。

### 构造函数能否为虚函数，析构函数呢？

- 析构函数：
  - 析构函数可以为虚函数，并且一般情况下基类析构函数要定义为虚函数。
  - 只有在基类析构函数定义为虚函数时，调用操作符delete销毁指向对象的基类指针时，才能准确调用派生类的析构函数（从该级向上按序调用虚函数），才能准确销毁数据。
  - 析构函数可以是纯虚函数，含有纯虚函数的类是抽象类，此时不能被实例化。但派生类中可以根据自身需求重新改写基类中的纯虚函数。
- 构造函数：
  - 构造函数不能定义为虚函数，不仅如此，构造函数中还不能调用虚函数。因为那样实际执行的是父类对应的函数，因为自己还没有构造好（构造顺序先基类再派生类）。

### 构造函数调用顺序

- 基类的构造函数：如果有多个基类，先调用纵向上最上层基类构造函数，如果横向继承了多个类，调用顺序为派生表从左到右顺序。
- 成员类对象的构造函数：如果类的变量中包含其他类（类的组合），需要在调用本类构造函数前先调用成员类对象的构造函数，调用顺序遵照在类中被声明的顺序。
- 派生类的构造函数。

### 析构函数调用顺序

析构函数在对象生命周期结束时自动执行

- 一般情况下，析构函数次序正好和构造函数相反，先构造后析构
- 函数中定义了一个对象，函数调用结束时，对象会被释放，释放前自动执行析构函数
- static局部对象在mian函数结束或者exit时才执行对象的析构函数
- 全局对象在mian函数结束或者exit时才执行对象的析构函数、
- new建立的对象，在delete释放时，才执行析构函数

### 拷贝构造函数中深拷贝和浅拷贝区别？

- 深拷贝时，当被拷贝对象存在动态分配的存储空间时，需要先动态申请一块存储空间，然后逐字节拷贝内容。
- 浅拷贝仅仅是拷贝指针字面值。
- 当使用浅拷贝时，如果原来的对象调用析构函数释放掉指针所指向的数据，则会产生空悬指针。因为所指向的内存空间已经被释放了。

### 拷贝构造函数和赋值运算符重载的区别？

- 拷贝构造函数是函数，赋值运算符是运算符重载。
- 拷贝构造函数会生成新的类对象，赋值运算符不能。
- 拷贝构造函数是直接构造一个新的类对象，所以在初始化对象前不需要检查源对象和新建对象是否相同；赋值运算符需要上述操作并提供两套不同的复制策略，另外赋值运算符中如果原来的对象有内存分配则需要先把内存释放掉。
- 形参传递是调用拷贝构造函数（调用的被赋值对象的拷贝构造函数），但并不是所有出现"="的地方都是使用赋值运算符，如下：

```c++
Student s;
Student s1 = s;    // 调用拷贝构造函数
Student s2;
s2 = s;    // 赋值运算符操作
```

**注：类中有指针变量时要重写析构函数、拷贝构造函数和赋值运算符**

### 构造函数和析构函数调用时机？

- 全局范围中的对象：构造函数在所有函数调用之前执行，在主函数执行完调用析构函数。
- 局部自动对象：建立对象时调用构造函数，函数结束时调用析构函数。
- 动态分配的对象：建立对象时调用构造函数，调用释放时调用析构函数。
- 静态局部变量对象：建立时调用一次构造函数，主函数结束时调用析构函数。

### 哪几种情况必须用到初始化成员列表？

- 初始化一个const成员。
- 初始化一个reference成员。
- 调用一个基类的构造函数，而该函数有一组参数。
- 调用一个数据成员对象的构造函数，而该函数有一组参数。

### 构造函数和析构函数的虚函数

- 构造函数不能被声明为虚函数
- 析构函数可以声明为虚函数，防止资源泄漏等问题

## 4.虚函数

- 虚函数：允许在派生类中重新定义与基类同名的函数，可以通过基类的指针访问基类和派生类中的同名函数
- 派生类中可以不加virtual关键字，但是为了清晰推荐加上

- 如果这个类可能作为基类，并且类的成员函数被继承后可能会发生改变，一般声明成虚函数
- 如果成员函数是通过指针或者引用来访问，则声明成虚函数`pt->display()`
- 虚函数可以不定义具体函数体，具体功能留给子类实现

### 虚函数和纯虚函数区别？

- 虚函数是为了实现动态编联产生的，目的是通过基类类型的指针指向不同对象时，自动调用相应的、和基类同名的函数（使用同一种调用形式，既能调用派生类又能调用基类的同名函数）。
- 虚函数需要在基类中加上virtual修饰符修饰，因为virtual会被隐式继承，所以子类中相同函数都是虚函数。
- 当一个成员函数被声明为虚函数之后，其派生类中同名函数自动成为虚函数，在派生类中重新定义此函数时要求函数名、返回值类型、参数个数和类型全部与基类函数相同。

- 纯虚函数只是相当于一个接口名，但含有纯虚函数的类不能够实例化。
- `virtual void function()=0`

### 什么是虚指针？

- 虚指针或虚函数指针是虚函数的实现细节。
- 虚指针指向虚表结构。

## 5.函数重载

重载(overloading) 是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。

### 覆盖、重载和隐藏的区别？

- 覆盖是派生类中重新定义的函数，其函数名、参数列表（个数、类型和顺序）、返回值类型和父类完全相同，只有函数体有区别。派生类虽然继承了基类的同名函数，但用派生类对象调用该函数时会根据对象类型调用相应的函数。覆盖只能发生在类的成员函数中。
- 隐藏是指派生类函数屏蔽了与其同名的函数，这里仅要求基类和派生类函数同名即可。其他状态同覆盖。可以说隐藏比覆盖涵盖的范围更宽泛，毕竟参数不加限定。
- 重载是具有相同函数名但参数列表不同（个数、类型或顺序）的两个函数（不关心返回值），当调用函数时根据传递的参数列表来确定具体调用哪个函数。重载可以是同一个类的成员函数也可以是类外函数。

### 重载和函数模板的区别？

- 重载需要多个函数，这些函数彼此之间函数名相同，但参数列表中参数数量和类型不同。在区分各个重载函数时我们并不关心函数体。
- 模板函数是一个通用函数，函数的类型和形参不直接指定而用虚拟类型来代表。但只适用于参个数相同而类型不同的函数。

### 类模板是什么？

- 用于解决多个功能相同、数据类型不同的类需要重复定义的问题。
- 在建立类时候使用template及任意类型标识符T，之后在建立类对象时，会指定实际的类型，这样才会是一个实际的对象。
- 类模板是对一批仅数据成员类型不同的类的抽象，只要为这一批类创建一个类模板，即给出一套程序代码，就可以用来生成具体的类。

用类模版实现两个数加减的操作

```c++
#include <iostream>

using namespace std;

template<class T>
class Operation{
public:
    Operation(T a,T b):x(a),y(b){}
    T add(){
        return x+y;
    }
    T sub(){
        return x-y;
    }
private:
    T x,y;
};

int main(int argc, const char * argv[]) {
    Operation<int> op_int(1,2);
    cout<<op_int.add()<<endl;
    cout<<op_int.sub()<<endl;
}
```

## 6.抽象类与接口

### @接口

- 如果是抽象类实现接口，可以实现部分方法甚至一个都不实现，具体类才必须实现接口的所有方法。
- 一个类可以实现多个接口
- 接口间可以有继承关系
- 继承树的非叶子节点应该都是抽象类，叶子节点都是具体类

### @抽象类与接口区别：

|抽象类|接口|
|---|---|
|可以给出一些成员的实现|不包含成员的实现|
|抽象成员函数可以在子类中部分实现|接口成员必须完全实现|
|一个类只能继承一个抽象类|一个类可以实现多个接口|
|抽象类是对类的抽象|接口是对某种行为的抽象|
|对一些相似的对象用抽象类|对一些相似的行为用接口|
|泛化子类公共的特点|预先定义|
|抽象类可以有构造函数|接口不可以有构造函数|
|抽象类中可以有普通成员变量|接口中没有普通成员变量，只能有常量|
|抽象类中的方法可以被static修饰|接口中的方法不可以被static修饰|
|抽象类中可以有普通方法和抽象方法|接口中的方法全是抽象方法|
|抽象类主要用于当做基类使用，拥有一些方法，并且这些方法有默认实现|接口主要用于模块与模块之间的调用。实现多继承|

## 7.集合

ArrayList就是动态数组，可以动态的增加和减少元素，实现了ICollection和IList接口，灵活的设置数组的大小

```c++
using System.Collections;

IList arraylist;
arraylist = new ArrayList();
//or ArrayList arraylist = new ArrayList();

List.Add(i);
```

- Add方法用于添加一个元素到当前列表的末尾
- AddRange方法用于添加一批元素到当前列表的末尾
- Remove方法用于删除一个元素，通过元素本身的引用来删除
- RemoveAt方法用于删除一个元素，通过索引值来删除
- RemoveRange用于删除一批元素，通过指定开始的索引和删除的数量来删除
- Insert用于添加一个元素到指定位置，列表后面的元素依次往后移动
- InsertRange用于从指定位置开始添加一批元素，列表后面的元素依次往后移动
- Clear方法用于清除现有所有的元素
- Contains方法用来查找某个对象在不在列表之中

## 8.泛型

指定数据类型

```c++
IList<Animal> arraylist;
arraylist = new ArrayList<Animal>();
```