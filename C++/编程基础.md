# 编程基础

## 1. 变量声明和定义区别？

- 声明仅仅是把变量的声明的位置及类型提供给编译器，并不分配内存空间；定义要在定义的地方为其分配存储空间。
- 相同变量可以再多处声明（外部变量extern），但只能在一处定义。

```c++
extern int a;
```

- 在变量定义前加extern关键字表示声明一个变量但不定义它 。它表示"这只是一个声明,它的定义在别的地方",关键字extern,它表示变量是在文件以外定义的,或在文件后面部分才定义.

## 2. "零值比较"？

- bool类型：if(flag)
- int类型：if(flag == 0)
- 指针类型：if(flag == null)
- float类型：if((flag >= -0.000001) && (flag <= 0. 000001))  （5个0）

## 3. strlen和sizeof区别？

- sizeof是运算符，并不是函数，结果在编译时得到而非运行中获得；
- 通常用于返回类型和静态分配的对象、结构或者数组所占的空间
- sizeof参数可以是任何数据的类型或者数据（sizeof参数不退化）；
- 因为sizeof值在编译时确定，所以不能用来得到动态分配（运行时分配）存储空间的大小。

- sizeof(数组)  返回的是数组空间的大小
- sizeof(指针)  返回存储指针所用空间的大小
- sizeof(类型)  该类型的大小
- sizeof(引用)  所指向的变量(对象)的大小
- sizeof(对象)  对象实际空间大小
- sizeof(函数)  该函数的返回值的大小，该函数的返回值不能为void
- sizeof(类)
  - c++定义一个空的类CTest，CTest没有定义任何成员变量和成员函数，在32位机器上
  - 对该类求sizeof，结果为1。因为默认有构造函数
  - 给CTest添加构造函数，再对CTest求sizeof，结果为1.
  - 给CTest添加虚函数，再对CTest求sizeof，结果为4.

- strlen是字符处理的库函数。
- strlen的参数只能是字符指针且结尾是'\0'的字符串。
- 如果传入一个数组名，则该数组名退化成指针

## 4. 同一不同对象可以互相赋值吗？

- 可以，但含有指针成员时需要注意。
- 对比类的对象赋值时深拷贝和浅拷贝。
- 浅拷贝的意思就是只复制引用（指针），而未复制真正的值。
- 深拷贝就是对目标的完全拷贝，不像浅拷贝那样只是复制了一层引用，就连值也都复制了。

## @变量，结构体，共用体内存问题？

64位操作系统数据类型内存：

- char 8bit 1byte
- short 16bit
- int 32bit 4个字节(固定)
- unsigned int : 4个字节(固定)
- float 32bit 4个字节(固定)
- long 64bit
- double 64bit
- long long 64bit
- *(即指针变量): 8个字节

- 结构体内成员按照声明顺序存储，第一个成员地址和整个结构体地址相同。偏移量为0
- 继续计算剩下的成员的偏移量，偏移量必须是min(#pragma pack()指定的数，这个数据成员的自身长度) 的倍数。
- 在数据成员完成各自对齐之后，结构(或联合)本身也要进行对齐，未特殊说明时，按结构体中size最大的成员对齐（若有double成员），按8字节对齐。
- 结构体大小计算方法：所有成员大小相加，然后取8的倍数
- 不同的变量声明顺序也会影响结构体大小

- 共用体大小计算方法：计算最长成员的大小，然后取8的倍数

```
Struct  Node {
Char a;//偏移量为0
Int val;//偏移量为1，因为char的大小为1，但是偏移量必须是这个成员的整数倍，所以为4
Node *node;//偏移量为4，因为指针的大小为8，但是偏移量必须是这个成员的整数倍，所以为8
Char a;//偏移量为8，因为char的大小为1，但是偏移量必须是这个成员的整数倍，所以为16
};
```

## @static作用是什么？在C和C++中有何区别？

- static可以修饰局部变量（静态局部变量）、全局变量（静态全局变量）和函数，被修饰的变量存储位置在静态区。对于静态局部变量，相对于一般局部变量其生命周期长，直到程序运行结束而非函数调用结束，且只在第一次被调用时定义；对于静态全局变量，相对于全局变量其可见范围被缩小，只能在本文件中可见；修饰函数时作用和修饰全局变量相同，都是为了限定访问域。

- C++的static还可以修饰类成员（静态成员变量和静态成员函数），静态成员变量和静态成员函数不属于任何一个对象，是所有类实例所共有。分配一个单独的空间，不管创建了多少对象的实例，这些实例都共享这个静态成员变量。在程序结束时释放这个空间。
- static的数据记忆性可以满足函数在不同调用期的通信，也可以满足同一个类的多个实例间的通信。
- 未初始化时，static变量默认值为0。

- 静态成员函数同理，不属于任何对象，所以没有this指针，静态成员函数可以直接操作类中的静态成员变量

## @结构体和类的区别？

- 结构体的默认限定符是public；类是private。
- 结构体不可以继承，类可以。
- C++中结构体也可以继承。

## @联合体和结构体有什么区别

- 联合体：使几个不同类型的变量共占一段内存(相互覆盖)
- 结构体是一种构造数据类型，把不同类型的数据组合成一个整体
- 结构体变量所占内存长度是各成员占的内存长度的总和。
- 联合体变量所占内存长度是各最长的成员占的内存长度。
- 联合体每次只能存放哪个的一种
- 联合体变量中起作用的成员是最后一次存放的成员，在存入新的成员后原有的成员失去了作用而对于struct的不同成员赋值是互不影响的。

## @malloc和new的区别？

- malloc和free是标准库函数，支持覆盖；new和delete是运算符，并且支持重载。
- malloc仅仅分配内存空间，free仅仅回收空间，不具备调用构造函数和析构函数功能，用malloc分配空间存储类的对象存在风险；
- new和delete除了分配回收功能外，还会调用构造函数和析构函数。
- malloc和free返回的是void类型指针（必须进行类型转换），new和delete返回的是具体类型指针。

## @指针和引用区别？

- 引用只是别名，不占用具体存储空间，只有声明没有定义；指针是具体变量，指向一块内存，需要占用存储空间。
- 引用不能为空，在声明时必须初始化为另一变量，一旦出现必须为typename &varname = refname 形式；指针可以为空，声明和定义可以分开，可以先只声明指针变量而不初始化，等用到时再指向具体变量。
- sizeof(指针)  返回存储指针所用空间的大小
- sizeof(引用)  所指向的变量(对象)的大小
- 引用一旦初始化之后就不可以再改变（变量可以被引用为多次，但引用只能作为一个变量引用）；指针变量可以重新指向别的变量。
- 引用是类型安全的，而指针不是 (引用比指针多了类型检查
- 指针和引用的自增(++)运算意义不一样；
- 使用引用给参数传值，函数则直接对参数进行操作

## 10. 宏定义和函数有何区别？

- 宏在编译时完成替换，之后被替换的文本参与编译，相当于直接插入了代码，运行时不存在函数调用，执行起来更快；函数调用在运行时需要跳转到具体调用函数。
- 宏函数属于在结构中插入代码，没有返回值；函数调用具有返回值。
- 宏函数参数没有类型，不进行类型检查；函数参数具有类型，需要检查类型。
- 宏函数不要在最后加分号。

## 11. 宏定义和const区别？

- 宏替换发生在编译阶段之前，属于文本插入替换；const作用发生于编译过程中。
- 宏不检查类型；const会检查数据类型。
- 宏定义的数据没有分配内存空间，只是插入替换掉；const定义的变量只是值不能改变，但要分配内存空间。

## 12. 宏定义和typedef区别？

- 宏主要用于定义常量及书写复杂的内容；typedef主要用于定义类型别名。
- 宏替换发生在编译阶段之前，属于文本插入替换；typedef是编译的一部分。
- 宏不检查类型；typedef会检查数据类型。
- 宏不是语句，不在在最后加分号；typedef是语句，要加分号标识结束。
- 注意对指针的操作，typedef char * p_char和#define p_char char *区别巨大。

## 13. 宏定义和内联函数(inline)区别？

- 在使用时，宏只做简单字符串替换（编译前）。而内联函数可以进行参数类型检查（编译时），且具有返回值。
- 内联函数本身是函数，强调函数特性，具有重载等功能。
- 内联函数可以作为某个类的成员函数，这样可以使用类的保护成员和私有成员。而当一个表达式涉及到类保护成员或私有成员时，宏就不能实现了。

编译器将使用相应的函数代码替换函数调用。因此，内联函数的运行速度比常规函数稍快，但代价是需要占用更多内存。如果执行函数代码的时间比处理函数调用机制的时间长，则节省的时间占比很小。若代码执行时间很短，则内联函数就可以节省函数调用的时间。

```c++
inline double square(double x){return x*x;}
```

## 16. volatile有什么作用？

- volatile定义变量的值是易变的，每次用到这个变量的值的时候都要去重新读取这个变量的值，而不是读寄存器内的备份。
- 多线程中被几个任务共享的变量需要定义为volatile类型。

## 17. 什么是常引用？

- 常引用可以理解为常量指针，形式为const typename & refname = varname。
- 常引用下，原变量值不会被别名所修改。
- 原变量的值可以通过原名修改。
- 常引用通常用作只读变量别名或是形参传递。

## 18. 区别以下指针类型？

```c++
int *p[10]
int (*p)[10]
int *p(int)
int (*p)(int)
```

- `int *p[10]`表示指针数组，`p[10]`声明一个数组，`int *`定义了数组中的元素类型。强调数组概念，因为[]的优先级高，是一个数组变量，数组大小为10，数组内每个元素都是指向int类型的指针变量。
- `int (*p)[10]`表示数组指针，强调是指针，因为()的优先级高，只有一个变量，是指针类型，不过指向的是一个int类型的数组，这个数组大小是10。可以理解成`int (*)[10] p`，`int (*)[10]`是指针类型，通常用与二维数组

```c++
int a[3][4];
int (*p)[4]; //该语句是定义一个数组指针，指向含4个元素的一维数组。
 p=a;        //将该二维数组的首地址赋给p，也就是a[0]或&a[0][0]
 p++;       //该语句执行过后，也就是p=p+1;p跨过行a[0][]指向了行a[1][]
```

- `int *p(int)`是函数声明，函数名是p，参数是int类型的，返回值是int *类型的。
- `int (*p)(int)`是函数指针，强调是指针，该指针指向的函数具有int类型参数，并且返回值是int类型的。

## 19. 常量指针和指针常量区别？

- int const a和const int a均表示定义常量类型a。

```c++
const int a;
int const a;
```

- 常量指针
- 常量指针是一个指针，读成常量的指针，指向一个只读变量。
- a为指向int型变量的指针，

```c++
int const *a;
//or
const int *a;
```

- 指针常量
- 指针常量是一个不能给改变指向的指针。
- 表示a为指向整型数据的常指针。(看成const(a)，对指针const)

```c++
int *const a;
```

## 20. a和&a有什么区别？

假设数组int a[10];
`int (*p)[10] = &a;`

- a是数组名，是数组首元素地址，+1表示地址值加上一个int类型的大小，如果a的值是0x00000001，加1操作后变为0x00000005。*(a + 1) = a[1]。
- &a是数组的指针，其类型为int (*)[10]（就是前面提到的数组指针），其加1时，系统会认为是数组首地址加上整个数组的偏移（10个int型变量），值为数组a尾元素后一个元素的地址。
- 若(int *)p ，此时输出 *p时，其值为a[0]的值，因为被转为int *类型，解引用时按照int类型大小来读取。

## 21. 数组名和指针（这里为指向数组首元素的指针）区别？

- 二者均可通过增减偏移量来访问数组中的元素。
- 数组名不是真正意义上的指针，可以理解为常指针，所以数组名没有自增、自减等操作。
- 当数组名当做形参传递给调用函数后，就失去了原有特性，退化成一般指针，多了自增、自减操作，但sizeof运算符不能再得到原数组的大小了。

## 22. 野指针是什么？

- 也叫空悬指针，不是指向null的指针，是指向垃圾内存的指针。
- 产生原因及解决办法：
  - 指针变量未及时初始化 => 定义指针变量及时初始化，要么置空。
  - 指针free或delete之后没有及时置空 => 释放操作后立即置空。

## @堆和栈的区别？

- 申请方式不同。
  - 栈由系统自动分配，速度快，不会有碎片。
  - 堆由程序员手动分配，速度慢，且会有碎片。

- 申请大小限制不同。
  - 栈顶和栈底是之前预设好的，大小固定，可以通过ulimit -a查看，由ulimit -s修改。
  - 堆向高地址扩展，是不连续的内存区域，大小可以灵活调整。

## @C程序的内存空间

- 1、栈区（stack）— 由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。
- 2、堆区（heap） — 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收 。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表。STL分配的内存位于这里
- 3、全局区（静态区）（static）—，全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域
- 未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。程序结束后有系统释放
- 4、文字常量区—常量字符串就是放在这里的。 程序结束后由系统释放
- 5、程序代码区—存放函数体的二进制代码

## 24. delete和delete[]区别？

- delete只会调用一次析构函数。
- delete[]会调用数组中每个元素的析构函数。

## 25.函数重载与函数模版

- 可以用同一函数名定义多个函数，但是这些函数必须参数个数不同或者参数类型不同
- 函数模版是建立一个通用函数，函数的类型和形参不具体指定，只适用于函数参数个数相同，只有函数参数类型不同的情况

```c++
#include <iostream>

using namespace std;

template<typename T>
T min(T a, T b, T c){
    if(a>b)
        a=b;
    if(a>c)
        a=c;
    return a;
}

int main(int argc, const char * argv[]) {
    int a=1,b=2,c=3;
    cout<<min(a,b,c)<<endl;
    long long a1=10000,b1=20000,c1=300000;
    cout<<min(a1,b1,c1)<<endl;
    return 0;
}
```

## 共用体

```c++
union test{
    int a;
    char b;
}
```

引用时只能通过变量成员，不能直接使用

## @三种错误处理方式

- 函数返回值：一般返回值为0表示成功，定义非零的为不同错误，优点是和系统API保持一致，缺点是函数不能返回计算结果了
- 全局变量：将返回值传给全局变量，可以专门定义一个函数GetLastError来分析错误，优点是计算方便，缺点是可能忘记检查全局变量
- 异常：使用try-catch，可以为不同的出错原因定义不同的异常类型，缺点是有些语言不支持异常，抛出异常时对性能有负面影响

## @常成员函数声明

void func() const;

如果const放前面，则是修饰返回值的，所以要放在后面

## @什么是可重入

- 可重入函数主要用于多任务环境中，在实时系统的设计中，经常会出现多个任务调用同一个函数的情况。如果这个函数不幸被设计成为不可重入的函数的话，那么不同任务调用这个函数时可能修改其他任 务调用这个函数的数据，从而导致不可预料的后果。
- 一个可重入的函数简单来说就是可以被中断的函数，也就是说，可以在这个函数执行的任何时刻中断它，转入OS调度下去执行另外一段代码，而返回控制时不会出现什么错误；

满足下列条件的函数多数是不可重入的：

- （1）函数体内使用了静态的数据结构；
- （（2）函数体内调用了malloc()或者free()函数；
- （（3）函数体内调用了标准I/O函数。
- 使用了一些系统资源，比如全局变量区，中断向量表等

## @equals和==的区别

- equals:是用来比较两个对象内部的内容是否相等的。
- ==：是用来判断两个对象的地址是否相同，即是否是指相同一个对象。
- 如果没有重写equals时，是直接用==判断的
- 如果是基本类型和基本型封装，则仍然为比较内容。

## 内存泄漏（Memory Leak）

- 程序中己动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。

## 全局变量初始化顺序问题

- 对于不同编译单位的全局变量，其初始化的顺序没有任何的保证，因此对不同编译单位里的全局变量，在它们的初始化顺序之间建立依赖性都是不明智的。
- 此外也没办法捕捉到全局变量初始化抛出的异常，一般来说要减少全局变量的使用，特别是限制那些要求复杂初始化的全局变量。所以，尽量不用全局变量；用静态变量,通过访问器进行访问。

``` 
int   a   =   5;  
int   b   =   a;  
```

- 如果a和b定义在同一个文件里，那没什么问题,结果b等于5；如果a和b定义在不同文件里，就不能保证b也等于5,也就是说不能保证a先初始化。
- 除了在同一个文件定义的全局对象的初始化是按照定义次序来进行的之外，其他全局或静态变量之间的初始化次序没有任何保障。

解决这种问题的方法是不直接使用全局变量，而改用一个包装函数来访问

```
int get_a(){  
    static   int   a   =   5;  
    return   a;  
}  
int get_b(){  
    static   int   b   =   get_a();  
    return   b;  
}
```

这样的话，无论get_a和get_b是否定义在同一个文件中，get_b总是能够返回正确的结果，原因在于，函数内部的静态变量是在第一次访问的时候来初始化。