# 编程基础

## 1. 变量声明和定义区别？

- 声明仅仅是把变量的声明的位置及类型提供给编译器，并不分配内存空间；定义要在定义的地方为其分配存储空间。
- 相同变量可以再多处声明（外部变量extern），但只能在一处定义。

```c++
extern int a;
```

- 在变量定义前加extern关键字表示声明一个变量但不定义它 。它表示"这只是一个声明,它的定义在别的地方",关键字extern,它表示变量是在文件以外定义的,或在文件后面部分才定义.

## 2. "零值比较"？

- bool类型：if(flag)
- int类型：if(flag == 0)
- 指针类型：if(flag == null)
- float类型：if((flag >= -0.000001) && (flag <= 0. 000001))  （5个0）

## @strlen和sizeof区别

- sizeof是运算符，并不是函数，结果在编译时得到而非运行中获得；
- 通常用于返回类型和静态分配的对象、结构或者数组所占的空间
- sizeof参数可以是任何数据的类型或者数据（sizeof参数不退化）；
- 因为sizeof值在编译时确定，所以不能用来得到动态分配（运行时分配）存储空间的大小。

- sizeof(数组)  返回的是数组空间的大小
- sizeof(指针)  返回存储指针所用空间的大小
- sizeof(类型)  该类型的大小
- sizeof(引用)  所指向的变量(对象)的大小
- sizeof(对象)  对象实际空间大小
- sizeof(函数)  该函数的返回值的大小，该函数的返回值不能为void
- sizeof(类)
  - c++定义一个空的类CTest，CTest没有定义任何成员变量和成员函数，在32位机器上
  - 对该类求sizeof，结果为1。因为默认有构造函数
  - 给CTest添加构造函数，再对CTest求sizeof，结果为1.
  - 给CTest添加虚函数，再对CTest求sizeof，结果为4.

- strlen是字符处理的库函数。
- strlen的参数只能是字符指针且结尾是'\0'的字符串。
- 如果传入一个数组名，则该数组名退化成指针

## 深拷贝和浅拷贝

- 浅拷贝的意思就是只复制引用（指针），而未复制真正的值。
- 深拷贝就是对目标的完全拷贝，不像浅拷贝那样只是复制了一层引用，就连值也都复制了。

## @变量，结构体内存对齐

64位操作系统数据类型内存：

- char 8bit 1byte
- short 16bit
- int 32bit 4个字节(固定)
- unsigned int : 4个字节(固定)
- float 32bit 4个字节(固定)
- long 64bit 8byte （32位下是4byte）
- double 64bit
- long long 64bit
- *(即指针变量): 8个字节 （32位下是4byte）

- 结构体内成员按照声明顺序存储，第一个成员地址和整个结构体地址相同。偏移量为0
- 继续计算剩下的成员的偏移量，偏移量必须是min(#pragma pack()指定的数，这个数据成员的自身长度) 的倍数。
- 在数据成员完成各自对齐之后，结构(或联合)本身也要进行对齐，未特殊说明时，按结构体中size最大的成员对齐（若有double成员，按8字节对齐）
- 不同的变量声明顺序也会影响结构体大小

```c++
struct  Node {
    char a;//偏移量为0
    int val;//偏移量为1，因为char的大小为1，偏移量为 0+1=1 但是偏移量必须是这个成员的整数倍，所以为4
    int *node;//偏移量为4，因为指针的大小为8，偏移量为 4+8=12 但是偏移量必须是这个成员的整数倍，所以为16
    char b;//偏移量为16，因为char的大小为1，偏移量为 16+1=17 但是偏移量必须是这个成员的整数倍，所以为17，由于结构体必须是所有成员大小的整数倍，所以最后是24
}node;

int main()
{
    cout << sizeof(node) << endl;
    return 0;
}
```

## 共用体内存对齐

- 共用体大小计算方法：计算最长成员的大小，然后取最大类型长度的倍数

```c++
union DATE
{
    char a;//1
    int i[5];//4*5
    int b;//4，最长是20，然后取4的倍数
};
int main()
{
    DATE max;
    cout << sizeof(max) << endl;
    return 0;
}
```

## 内存对齐的作用和原因

- 各个硬件平台对存储空间的处理上有很大的不同。一些平台对某些特定类型的数据只能从某些特定地址开始存取。比如有些架构的CPU在访问 一个没有进行对齐的变量的时候会发生错误,那么在这种架构下编程必须保证字节对齐.其他平台可能没有这种情况
- 但是最常见的是如果不按照适合其平台要求对数据存放进行对齐，会在存取效率上带来损失。比如有些平台每次读都是从偶地址开始，如果一个int型（假设为32位系统）如果存放在偶地址开始的地方，那么一个读周期就可以读出这32bit，而如果存放在奇地址开始的地方，就需要2个读周期，并对两次读出的结果的高低字节进行拼凑才能得到该32bit数据。显然在读取效率上下降很多。

## @static作用是什么？在C和C++中有何区别？

- static可以修饰局部变量（静态局部变量）、全局变量（静态全局变量）和函数，被修饰的变量存储位置在静态区。
- 对于静态局部变量，相对于一般局部变量其生命周期长，直到程序运行结束而非函数调用结束，且只在第一次被调用时定义；
- 对于静态全局变量，相对于全局变量其可见范围被缩小，只能在本文件中可见；
- 修饰函数时作用和修饰全局变量相同，都是为了限定访问域。

- C++的static还可以修饰类成员（静态成员变量和静态成员函数），静态成员变量和静态成员函数不属于任何一个对象，是所有类实例所共有。分配一个单独的空间，不管创建了多少对象的实例，这些实例都共享这个静态成员变量。在程序结束时释放这个空间。
- static的数据记忆性可以满足函数在不同调用期的通信，也可以满足同一个类的多个实例间的通信。
- 未初始化时，static变量默认值为0。

- 静态成员函数同理，不属于任何对象，所以没有this指针，静态成员函数可以直接操作类中的静态成员变量

## static变量的作用域

生存周期: 变量从定义到销毁的时间范围。存放在全局数据区的变量的生存周期存在于整个程序运行期间，而存放在栈中的数据则随着函数等的作用域结束导致出栈而销毁，除了静态变量之外的局部变量都存放于栈中。
作用域: 变量的可见代码域（块作用域，函数作用域，类作用域，程序全局作用域）。

static变量是指静态的变量，不管是在全局还是局部声明的static变量都存放于程序的全局变量区域，所以它的生命周期是从程序开始到程序结束。但是static变量的作用域并不等同于它的生存周期，它的作用域决定于它被定义的位置。可以认为static变量的作用域<=生存周期。

## static全局变量与普通的全局变量有什么区别

- 全局变量(外部变量)的说明之前再冠以static 就构成了静态的全局变量。
- 全局变量本身就是静态存储方式， 静态全局变量当然也是静态存储方式。 这两者在存储方式上并无不同。
- 这两者的区别在于非静态全局变量的作用域是整个源程序， 当一个源程序由多个源文件组成时，非静态的全局变量在各个源文件中都是有效的。 而静态全局变量则限制了其作用域， 即只在定义该变量的源文件内有效， 在同一源程序的其它源文件中不能使用它。由于静态全局变量的作用域局限于一个源文件内，只能为该源文件内的函数公用，因此可以避免在其它源文件中引起错误。
- static全局变量只初使化一次，防止在其他文件单元中被引用;

## 静态成员函数

- 静态成员函数的出现就是为了处理静态成员变量的。
- 如果某些成员函数只访问静态数据成员，那么最好把他们声明为静态的成员函数，因为这样不需要特定的对象就可以访问这些成员变量了。

## @结构体和类的区别？

- 结构体的默认限定符是public；类是private。
- 结构体不可以继承，类可以。
- C++中结构体也可以继承。

## @联合体和结构体有什么区别

- 联合体：使几个不同类型的变量共占一段内存(相互覆盖)
- 结构体是一种构造数据类型，把不同类型的数据组合成一个整体
- 结构体变量所占内存长度是各成员占的内存长度的对齐总和。
- 联合体变量所占内存长度是各最长的成员占的内存长度。
- 联合体每次只能存放成员变量中的一种
- 联合体变量中起作用的成员是最后一次存放的成员，在存入新的成员后原有的成员失去了作用，而对于struct的不同成员赋值是互不影响的。

## @动态内存分配malloc

内存分为静态内存（栈）和动态内存（堆），静态内存是系统分配的内存，不可更改，常量一般定义在此区域，动态内存为可变内存，因此变量存储在此区域。所谓的动态内存分配就是按照自己的想法分配内存，避免造成浪费。

在堆上分配也称为动态内存分配：程序在运行的时候用malloc等函数申请任意多少的内存，程序员自己负责在何时用free释放内存。动态内存分配的生存期由我们自己决定，使用非常灵活，但是问题相对也比较多；注意：//如果没有释放的话，很容易就会造成内存溢出，因为堆中的内存块是全局的，因此不会因为函数的调用而结束

## @malloc和new的区别

- malloc和free是标准库函数，支持覆盖；new和delete是运算符，并且支持重载。
- malloc仅仅分配内存空间，free仅仅回收空间，不具备调用构造函数和析构函数功能，用malloc分配空间存储类的对象存在风险；
- new和delete除了分配回收功能外，还会调用构造函数和析构函数。
- malloc和free返回的是void类型指针（必须进行类型转换），new和delete返回的是具体类型指针。

## @指针和引用区别？

- 引用只是别名，不占用具体存储空间，只有声明没有定义；指针是具体变量，指向一块内存，需要占用存储空间。
- 引用不能为空，在声明时必须初始化为另一变量，一旦出现必须为typename &varname = refname 形式；指针可以为空，声明和定义可以分开，可以先只声明指针变量而不初始化，等用到时再指向具体变量。
- sizeof(指针)  返回存储指针所用空间的大小
- sizeof(引用)  所指向的变量(对象)的大小
- 引用一旦初始化之后就不可以再改变（变量可以被引用为多次，但引用只能作为一个变量引用）；指针变量可以重新指向别的变量。
- 引用是类型安全的，而指针不是 (引用比指针多了类型检查
- 指针和引用的自增(++)运算意义不一样；
- ptr++表示指针往后移动一个int的长度。指向下一个内存地址。
- 引用是值++；比如b是引用a[0]的，b++表示a[0]的值++
- 使用引用给参数传值，函数则直接对参数进行操作

## 10. 宏定义和函数有何区别？

- 宏在编译时完成替换，之后被替换的文本参与编译，相当于直接插入了代码，运行时不存在函数调用，执行起来更快；函数调用在运行时需要跳转到具体调用函数。
- 宏函数属于在结构中插入代码，没有返回值；函数调用具有返回值。
- 宏函数参数没有类型，不进行类型检查；函数参数具有类型，需要检查类型。
- 宏函数不要在最后加分号。

## const与#define的异同

- 两者都可以用来定义常量；

```
#define PI 3.14159 // 常量宏  
const doulbe Pi=3.14159; // 常量
```

- 编译器处理方式不同，define宏是在预处理阶段展开；const常量是编译运行阶段使用；
- 类型和安全检查不同，define宏没有类型，不做任何类型检查，仅仅是展开。const常量有具体的类型，在编译阶段会执行类型检查。
- 存储方式不同，define宏在定义时不会分配内存；define宏仅仅是展开，有多少地方使用，就展开多少次；const常量在定义时会在内存中分配(可以是堆中也可以是栈中)；
- 赋值时的空间分配，const定义的常量在程序运行过程中只有一份拷贝，用const赋值不会再次分配内存，而使用#define定义的常量在内存中有若干个拷贝。
- 提高了效率，编译器通常不为普通const常量分配存储空间，而是将它们保存在符号表中，这使得它成为一个编译期间的常量，没有了存储与读内存的操作，使得它的效率也很高。

## 12. 宏定义和typedef区别？

- 宏主要用于定义常量及书写复杂的内容；typedef主要用于定义类型别名。
- 宏替换发生在编译阶段之前，属于文本插入替换；typedef是编译的一部分。
- 宏不检查类型；typedef会检查数据类型。
- 宏不是语句，不在在最后加分号；typedef是语句，要加分号标识结束。
- 注意对指针的操作，typedef char * p_char和#define p_char char *区别巨大。

## 13. 宏定义和内联函数(inline)区别？

- 在使用时，宏只做简单字符串替换（编译前）。而内联函数可以进行参数类型检查（编译时），且具有返回值。
- 内联函数本身是函数，强调函数特性，具有重载等功能。
- 内联函数可以作为某个类的成员函数，这样可以使用类的保护成员和私有成员。而当一个表达式涉及到类保护成员或私有成员时，宏就不能实现了。

编译器将使用相应的函数代码替换函数调用。因此，内联函数的运行速度比常规函数稍快，但代价是需要占用更多内存。如果执行函数代码的时间比处理函数调用机制的时间长，则节省的时间占比很小。若代码执行时间很短，则内联函数就可以节省函数调用的时间。

```c++
inline double square(double x){return x*x;}
```

## @volatile

- 用来解决变量在“共享”环境下容易出现读取错误的问题。
- 定义为volatile的变量是说这变量可能会被意想不到地改变，即在你程序运行过程中一直会变，你希望这个值被正确的处理，每次从内存中去读这个值，而不是因编译器优化从缓存的地方读取，比如读取缓存在寄存器中的数值，从而保证volatile变量被正确的读取。
- volatile定义变量的值是易变的，每次用到这个变量的值的时候都要去重新读取这个变量的值，而不是读寄存器内的备份。
- 多线程中被几个任务共享的变量需要定义为volatile类型。

## 17. 什么是常引用（const int & a）

- 常引用可以理解为常量指针，形式为const typename & refname = varname。
- 常引用下，原变量值不会被别名所修改。
- 原变量的值可以通过原名修改。
- 常引用通常用作只读变量别名或是形参传递。

## 18. 区别以下指针类型？

```c++
int *p[10]
int (*p)[10]
int *p(int)
int (*p)(int)
```

- `int *p[10]`表示指针数组，`p[10]`声明一个数组，`int *`定义了数组中的元素类型。强调数组概念，因为[]的优先级高，是一个数组变量，数组大小为10，数组内每个元素都是指向int类型的指针变量。
- `int (*p)[10]`表示数组指针，强调是指针，因为()的优先级高，只有一个变量，是指针类型，不过指向的是一个int类型的数组，这个数组大小是10。可以理解成`int (*)[10] p`，`int (*)[10]`是指针类型，通常用与二维数组

```c++
int a[3][4];
int (*p)[4]; //该语句是定义一个数组指针，指向含4个元素的一维数组。
 p=a;        //将该二维数组的首地址赋给p，也就是a[0]或&a[0][0]
 p++;       //该语句执行过后，也就是p=p+1;p跨过行a[0][]指向了行a[1][]
```

- `int *p(int)`是函数声明，函数名是p，参数是int类型的，返回值是int *类型的。
- `int (*p)(int)`是函数指针，强调是指针，该指针指向的函数具有int类型参数，并且返回值是int类型的。

## @常量指针和指针常量区别

- int const a和const int a均表示定义常量类型a。
- 常量指针是一个指针，读成常量的指针，指向一个只读变量。
- a为指向int型变量的指针，

```c++
int const *a;
//or
const int *a;
```

- 指针常量是一个不能给改变指向的指针。
- 表示a为指向整型数据的常指针。
- 放在指针后，可以看成对指针const

```c++
int *const a;
```

## 20. a和&a有什么区别？

假设数组int a[10];
`int (*p)[10] = &a;`

- a是数组名，是数组首元素地址，+1表示地址值加上一个int类型的大小，如果a的值是0x00000001，加1操作后变为0x00000005。*(a + 1) = a[1]。
- &a是数组的指针，其类型为int (*)[10]（就是前面提到的数组指针），其加1时，系统会认为是数组首地址加上整个数组的偏移（10个int型变量），值为数组a尾元素后一个元素的地址。
- 若(int *)p ，此时输出 *p时，其值为a[0]的值，因为被转为int *类型，解引用时按照int类型大小来读取。

## @数组名和指针（这里为指向数组首元素的指针）区别

- 二者均可通过增减偏移量来访问数组中的元素。
- 数组名不是真正意义上的指针，可以理解为常指针，所以数组名没有自增、自减等操作。
- 当数组名当做形参传递给调用函数后，就失去了原有特性，退化成一般指针，多了自增、自减操作，但sizeof运算符不能再得到原数组的大小了。

## @野指针是什么

- 也叫空悬指针，不是指向null的指针，是指向垃圾内存的指针。
- 产生原因及解决办法：
  - 指针变量未及时初始化 => 定义指针变量及时初始化，要么置空。
  - 指针free或delete之后没有及时置空 => 释放操作后立即置空。

## @堆和栈的区别？

- 申请方式不同。
  - 栈由系统自动分配，速度快，不会有碎片。
  - 堆由程序员手动分配，速度慢，且会有碎片。

- 申请大小限制不同。
  - 栈顶和栈底是之前预设好的，大小固定，可以通过ulimit -a查看，由ulimit -s修改。
  - 堆向高地址扩展，是不连续的内存区域，大小可以灵活调整。

## @C程序的内存空间

- 1、栈区（stack）
  - 由编译器自动分配释放，保存基础数据类型的对象和自定义对象的引用，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。每个栈中的数据(原始类型和对象引用)都是私有的，其他栈不能访问。
  - 栈分为3个部分：基本类型变量区、执行环境上下文、操作指令区(存放操作指令)。
- 2、堆区（heap）
  - 由new分配的内存块，其释放编译器不去管，由我们程序自己控制（一个new对应一个delete）。如果程序员没有释放掉，在程序结束时OS会自动回收。涉及的问题：“缓冲区溢出”、“内存泄露”
  - 存储的全部是对象，一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收 。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表。STL分配的内存位于这里
- 3、全局区（静态区）（static）（方法区）
  - 全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域
  - 未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。
  - 程序结束后有系统释放，跟堆一样，被所有的线程共享
- 4、文字常量区
  - 常量字符串就是放在这里的。 程序结束后由系统释放
  - 存放常量，不允许修改（通过非正当手段也可以修改）
- 5、程序代码区
  - 存放函数体的二进制代码
  - 存放代码（如函数），不允许修改（类似常量存储区），但可以执行（不同于常量存储区）

## 24. delete和delete[]区别？

- delete只会调用一次析构函数。
- delete[]会调用数组中每个元素的析构函数。

## 25.函数重载与函数模版

- 可以用同一函数名定义多个函数，但是这些函数必须参数个数不同或者参数类型不同
- 函数模版是建立一个通用函数，函数的类型和形参不具体指定，只适用于函数参数个数相同，只有函数参数类型不同的情况

```c++
#include <iostream>

using namespace std;

template<typename T>
T min(T a, T b, T c){
    if(a>b)
        a=b;
    if(a>c)
        a=c;
    return a;
}

int main(int argc, const char * argv[]) {
    int a=1,b=2,c=3;
    cout<<min(a,b,c)<<endl;
    long long a1=10000,b1=20000,c1=300000;
    cout<<min(a1,b1,c1)<<endl;
    return 0;
}
```

## @三种错误处理方式

- 函数返回值：一般返回值为0表示成功，定义非零的为不同错误，优点是和系统API保持一致，缺点是函数不能返回计算结果了
- 全局变量：将返回值传给全局变量，可以专门定义一个函数GetLastError来分析错误，优点是计算方便，缺点是可能忘记检查全局变量
- 异常：使用try-catch，可以为不同的出错原因定义不同的异常类型，缺点是有些语言不支持异常，抛出异常时对性能有负面影响

## @常成员函数声明

void func() const;

如果const放前面，则是修饰返回值的，所以要放在后面

## @什么是可重入

- 可重入函数主要用于多任务环境中，在实时系统的设计中，经常会出现多个任务调用同一个函数的情况。如果这个函数不幸被设计成为不可重入的函数的话，那么不同任务调用这个函数时可能修改其他任务调用这个函数的数据，从而导致不可预料的后果。
- 一个可重入的函数简单来说就是可以被中断的函数，也就是说，可以在这个函数执行的任何时刻中断它，转入OS调度下去执行另外一段代码，而返回控制时不会出现什么错误；

满足下列条件的函数多数是不可重入的：

- 函数体内使用了静态的数据结构；
- 函数体内调用了malloc()或者free()函数；
- 函数体内调用了标准I/O函数。
- 使用了一些系统资源，比如全局变量区，中断向量表等

## @equals和==的区别

- equals:是用来比较两个对象内部的内容是否相等的。
- ==：是用来判断两个对象的地址是否相同，即是否是指相同一个对象。
- 如果没有重写equals时，是直接用==判断的
- 如果是基本类型和基本型封装，则仍然为比较内容。

## 内存泄漏（Memory Leak）

- 程序中己动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。

## 全局变量初始化顺序问题

- 对于不同编译单位的全局变量，其初始化的顺序没有任何的保证，因此对不同编译单位里的全局变量，在它们的初始化顺序之间建立依赖性都是不明智的。
- 此外也没办法捕捉到全局变量初始化抛出的异常，一般来说要减少全局变量的使用，特别是限制那些要求复杂初始化的全局变量。所以，尽量不用全局变量；用静态变量,通过访问器进行访问。

``` 
int a = 5;  
int b = a;  
```

- 如果a和b定义在同一个文件里，那没什么问题,结果b等于5；如果a和b定义在不同文件里，就不能保证b也等于5,也就是说不能保证a先初始化。
- 除了在同一个文件定义的全局对象的初始化是按照定义次序来进行的之外，其他全局或静态变量之间的初始化次序没有任何保障。

解决这种问题的方法是不直接使用全局变量，而改用一个包装函数来访问

```
int get_a(){
    static int a = 5;
    return a;
}
int get_b(){
    static int b = get_a();
    return b;
}
```

这样的话，无论get_a和get_b是否定义在同一个文件中，get_b总是能够返回正确的结果，原因在于，函数内部的静态变量是在第一次访问的时候来初始化。

## C++的四种cast操作符

- `reinterpret_cast<new_type>(expression)`
  - type_id可以是指针，引用，算术类型，函数指针或者成员指针，这个操作符可以在非相关的类型之间转换，操作只是简单的从一个指针到别的指针的值得二进制拷贝，在类型之间指向的内容不作任何类型的检查和转换。
- `dynamic_cast<new_type>(expression)`
  - 他只用于对象和引用，主要用于执行安全的向下转型，他可以将指向子类的父类指针转换为子类指针，但是要求父类有虚函数，如果转换为指针类型失败则返回NULL，如果是引用类型转换失败则跑出bad_cast的异常
- `static_cast<new_type>(expression)`
  - 用于基本数据类型，或者non_const到const（反过来必须用const_cast)
  - 把空指针转换为目标类型的指针
  - 将任何类型的表达式转换为void类型
  - 可以将子类类型的指针转换为父类类型的指针（这种转换的安全性需要开发人员来保证）
- `const_cast<new_type>(expression)`
  - const_cast只能改变运算对象的底层const，用来移除变量的const或volatile限定符。
  - 注意：const_cast是不能用来执行任何类型的转换的，比如只能讲const char* p 转换成char* p，而不能转成int* p。

## ++i和i++的实现

- i++
  - i++先引用后增加，先在i所在的表达式中使用i的当前值，后让i加1
  - i++是先将i的值存到寄存器里，然后执行i+1，然后返回寄存器里的值。
- ++i
  - 先增加后引用，让i先加1，然后在i所在的表达式中使用i的新值
  - ++i是将i的值先+1，然后返回i的值

## C++隐式类型转换

- 隐式转换，是指不需要用户干预，编译器私下进行的类型转换行为
- C++面向对象的多态特性，就是通过父类的类型实现对子类的封装。
- 通过隐式转换，你可以直接将一个子类的对象使用父类的类型进行返回。
- 在比如，数值和布尔类型的转换，整数和浮点数的转换等。
- 基本数据类型的转换以取值范围的作为转换基础（保证精度不丢失）。
- 隐式转换发生在从小->大的转换中。比如从char转换为int。
- 自定义对象 子类对象可以隐式的转换为父类对象。
