# 编译过程

## 预处理（Prepressing）

- 处理#include指令，将被包含的文件插入到该指令所在位置。
- 过滤掉所有注释语句。
- 添加行号和文件名标识。
- 保留所有#pragma编译器指令。

### 宏定义

- 展开所有的宏定义，完成字符常量替换。原则是先替换后计算，简单的字符替换。
- 在定义宏定义的时候如果有表达式，则需要用括号确定优先级，并且最外面也要有括号，防止替换后产生优先级问题

### 条件编译

- 处理条件编译语句，通过是否具有某个宏来决定过滤掉哪些代码。
- 可以通过加#define，并通过#ifdef来判断，将某些具体模块包括进要编译的内容。
- 用于子程序前加#define DEBUG用于程序调试。
- 应对硬件的设置（机器类型等）。
- 条件编译功能if也可实现，但条件编译可以减少被编译语句，从而减少目标程序大小。

```c++
#ifdef 标识符
    程序段
#else
    程序段
#endif作用
```

如果标识符被#define，则选择编译

### do...while(0)

用于在宏定义中定义函数，防止替换后出现条件语句没有大括号包裹产生的else语句孤立的错误，也不能宏定义中简单的用大括号包裹

```c++
#define Foo(x) do{\
    statement one;\
    statement two;\
}while(0)
```

### extern "C"块的应用

```c++
#ifdef __cplusplus /* 如果采用了C++，如下代码使用C编译器 */
    extern "C" { /* 如果没有采用C++，顺序预编译 */
#endif
        /* 采用C编译器编译的C语言代码段 */
#ifdef __cplusplus /* 结束使用C编译器 */
    }
#endif
```

## 编译（Complication）

- 生成汇编代码

### 步骤

#### 词法分析（扫描）

- 将源代码的字符序列分割成一系列记号
- 记号可分为：关键字，标识符，字面量（数字、字符串等），特殊记号（加号、等号等）

#### 语法分析

- 生成语法树，使用上下文无关文法分析
- 可以确定运算符的优先级和含义

#### 语义分析

- 语义分析器，仅完成对表达式层面的分析，不能了解这个语句是否真的有意义（静态语义）
- 静态语义分析：在编译阶段可以确定的语义，通常包括声明、类型匹配、类型转换
- 动态语义分析：在运行阶段出现的语义相关问题，比如将0作为除数，这个在静态语义分析是检测不出来的

#### 中间语言生成

- 在源代码级别进行优化
- 比如（2+7）在编译期间就能被确定

#### 目标代码生成与优化

- 将中间代码转换成目标机器码
- 不同的机器有不同的字长、寄存器、整数数据类型和浮点数数据类型

## 汇编（Assembly）

## 链接（Linking）

- 各个源代码模块独立的被编译，然后将他们组装起来成为一个整体，组装的过程就是链接。
- 被链接的各个部分本本身就是二进制文件，所以在被链接时需要将所有目标文件的代码段拼接在一起，然后将所有对符号地址的引用加以修正。
- 全局变量和函数在最终运行时的绝对地址在链接的时候确定
- 地址和空间分配、符号决议、重定位等

### 静态链接

- 对函数库的链接放在编译时期完成，程序运行时不再需要函数库，函数库变为静态库
- 在编译时和静态库链接在一起成为完整的可执行程序。
- 静态库就是对多个目标文件（.o）文件的打包，通常静态链接的包名为lib****.a，静态链接所有被用到的目标文件都会复制到最终生成的可执行目标文件中。
- 这种方式的好处是在运行时，可执行目标文件已经完全装载完毕，只要按指令序执行即可，速度比较快。

- 打包命令。

```
gcc -c test1.c    // 生成test1.o
gcc -c test2.c    // 生成test2.c
ar cr libtest.a test1.o test2.o
```

首先编译得到test1.o和test2.o两个目标文件，之后通过ar命令将这两个文件打包为.a文件，文件名格式为lib + 静态库名 + .a后缀。在生成可执行文件需要使用到它的时候只需要在编译时加上即可。需要注意的是，使用静态库时加在最后的名字不是libtest.a，而是l + 静态库名。

```
gcc -o main main.c -ltest
```

### 动态链接

- 库函数的链接载入放在了程序运行时期（动态链接库技术）
- 首先也是需要打包，打包成动态库，不过文件名格式为lib + 动态库名 + .so后缀。
- 动态库的打包不需要使用ar命令，gcc就可以完成，但要注意在编译时要加上-fPIC选项，打包时加上-shared选项。

```
gcc -fPIC -c test1.c 
gcc -fPIC -c test2.c
gcc -shared test1.o test2.o -o libtest.so
```

- 使用动态链接的用法也和静态链接相同。

```
gcc -o main main.c -ltest
```

如果仅仅像上面的步骤是没有办法正常使用库的，我们可以通过加-Lpath指定搜索库文件的目录（-L.表示当前目录），默认情况下会到环境变量LD_LIBRARY_PATH指定的目录下搜索库文件，默认情况是/usr/lib，我们可以将库文件拷贝到那个目录下再链接。

### 比较静态库和动态库我们可以得到二者的优缺点。

- 动态库运行时会先检查内存中是否已经有该库的拷贝，若有则共享拷贝，否则重新加载动态库（C语言的标准库就是动态库）。静态库则是每次在编译阶段都将静态库文件打包进去，当某个库被多次引用到时，内存中会有多份副本，浪费资源。

- 动态库另一个有点就是更新很容易，当库发生变化时，如果接口没变只需要用新的动态库替换掉就可以了。但是如果是静态库的话就需要重新被编译。

- 不过静态库也有优点，主要就是静态库一次性完成了所有内容的绑定，运行时就不必再去考虑链接的问题了，执行效率会稍微高一些。

- 静态链接发生于编译阶段，加载至内存前已经完整，但缺点是如果多个程序都需要使用某个静态库，则该静态库会在每个程序中都拷贝一份，非常浪费内存资源，所以出现了动态链接的方式来解决这个问题。