# 编译过程

```bash
gcc -o hello hello.c
```

- 预处理阶段：处理以 # 开头的预处理命令；
- 编译阶段：翻译成汇编文件；
  - 词法分析
  - 语法分析
  - 语义分析
  - 中间代码生成
  - 目标代码生成与优化
- 汇编阶段：汇编翻译成机器代码，将汇编文件翻译成可重定向目标文件；
- 链接阶段：符号解析和重定位，将程序每一个全局变量和全局函数的引用和符号表里的一个符号对应起来，重定位确定每一个模板模块的全局变量和函数在可执行文件内存空间的位置，得到最终的可执行目标文件。

## C++源文件从文本到可执行文件经历的过程

- 1)预处理，产生.ii文件
- 2)编译，产生汇编文件(.s文件)
- 3)汇编，产生目标文件(.o或.obj文件)
- 4)链接,产生可执行文件(.out或.exe文件)

## 预处理（Prepressing）

- 处理#include指令，将被包含的文件插入到该指令所在位置。
- 过滤掉所有注释语句。
- 添加行号和文件名标识。
- 保留所有#pragma编译器指令。

### @宏定义

- 展开所有的宏定义，完成字符常量替换。原则是先替换后计算，简单的字符替换。
- 在定义宏定义的时候如果有表达式，则需要用括号确定优先级，并且最外面也要有括号，防止替换后产生优先级问题

```c++
#define Mul(x,y) ++x*++y
  
void main()
{
int a = 1;
int b = 2;
int c = 3;
  
printf(“%d”,Mul(a+b,b+c));
}
```

- Mul(a+b,b+c)经过宏替换变成++a+b*++b+c，需要注意宏替换的原则，是不会凭空加括号的。
- 另外++优先级大于*，因此会先++a 和++b，然后a=2,b=3进行a+b*b+c=2+3*3+3=14
- 优先级（）>  ++ > * > +

### 条件编译

- 处理条件编译语句，通过是否具有某个宏来决定过滤掉哪些代码。
- 可以通过加#define，并通过#ifdef来判断，将某些具体模块包括进要编译的内容。
- 用于子程序前加#define DEBUG用于程序调试。
- 应对硬件的设置（机器类型等）。
- 条件编译功能if也可实现，但条件编译可以减少被编译语句，从而减少目标程序大小。

```c++
#ifdef 标识符
    程序段
#else
    程序段
#endif
```

如果标识符被#define，则选择编译

### do...while(0)

用于在宏定义中定义函数，防止替换后出现条件语句没有大括号包裹产生的else语句孤立的错误，也不能宏定义中简单的用大括号包裹

```c++
#define Foo(x) do{\
    statement one;\
    statement two;\
}while(0)
```

### extern "C"块的应用

```c++
#ifdef __cplusplus /* 如果采用了C++，如下代码使用C编译器 */
    extern "C" { /* 如果没有采用C++，顺序预编译 */
#endif
        /* 采用C编译器编译的C语言代码段 */
#ifdef __cplusplus /* 结束使用C编译器 */
    }
#endif
```

## 编译（Complication）

- 生成汇编代码

### 词法分析（扫描）

- 将源代码的字符序列分割成一系列记号
- 记号可分为：关键字，标识符，字面量（数字、字符串等），特殊记号（加号、等号等）

### 语法分析

- 生成语法树，使用上下文无关文法分析
- 可以确定运算符的优先级和含义

### 语义分析

- 语义分析器，仅完成对表达式层面的分析，不能了解这个语句是否真的有意义（静态语义）
- 静态语义分析：在编译阶段可以确定的语义，通常包括声明、类型匹配、类型转换
- 动态语义分析：在运行阶段出现的语义相关问题，比如将0作为除数，这个在静态语义分析是检测不出来的

### 中间语言生成

- 在源代码级别进行优化
- 比如（2+7）在编译期间就能被确定

### 目标代码生成与优化

- 将中间代码转换成目标机器码
- 不同的机器有不同的字长、寄存器、整数数据类型和浮点数数据类型

## 汇编（Assembly）

- 汇编阶段：将汇编文件翻译成可重定向目标文件；

## 链接（Linking）

- 各个源代码模块独立的被编译，然后将他们组装起来成为一个整体，组装的过程就是链接。
- 被链接的各个部分本本身就是二进制文件，所以在被链接时需要将所有目标文件的代码段拼接在一起，然后将所有对符号地址的引用加以修正。
- 全局变量和函数在最终运行时的绝对地址在链接的时候确定
- 地址和空间分配、符号决议、重定位等

### 静态链接

- 对函数库的链接放在编译时期完成，程序运行时不再需要函数库，函数库变为静态库
- 在编译时和静态库链接在一起成为完整的可执行程序。
- 静态库就是对多个目标文件（.o）文件的打包，通常静态链接的包名为lib****.a，静态链接所有被用到的目标文件都会复制到最终生成的可执行目标文件中。
- 这种方式的好处是在运行时，可执行目标文件已经完全装载完毕，只要按指令序执行即可，速度比较快。
- 静态链接器以一组可重定向目标文件为输入，生成一个完全链接的可执行目标文件作为输出。链接器主要完成以下两个任务：
- 符号解析：每个符号对应于一个函数、一个全局变量或一个静态变量，符号解析的目的是将每个符号引用与一个符号定义关联起来。
- 重定位：链接器通过把每个符号定义与一个内存位置关联起来，然后修改所有对这些符号的引用，使得它们指向这个内存位置。

#### 目标文件

- 可执行目标文件：可以直接在内存中执行；
- 可重定向目标文件：可与其它可重定向目标文件在链接阶段合并，创建一个可执行目标文件；
- 共享目标文件：这是一种特殊的可重定向目标文件，可以在运行时被动态加载进内存并链接；

#### 打包命令

```
gcc -c test1.c    // 生成test1.o
gcc -c test2.c    // 生成test2.c
ar cr libtest.a test1.o test2.o
```

首先编译得到test1.o和test2.o两个目标文件，之后通过ar命令将这两个文件打包为.a文件，文件名格式为lib + 静态库名 + .a后缀。在生成可执行文件需要使用到它的时候只需要在编译时加上即可。需要注意的是，使用静态库时加在最后的名字不是libtest.a，而是l + 静态库名。

```
gcc -o main main.c -ltest
```

### 动态链接

静态库有以下两个问题：

- 当静态库更新时那么整个程序都要重新进行链接；
- 对于 printf 这种标准函数库，如果每个程序都要有代码，这会极大浪费资源。
- 共享库是为了解决静态库的这两个问题而设计的，在 Linux 系统中通常用 .so 后缀来表示

- 库函数的链接载入放在了程序运行时期（动态链接库技术）
- 首先也是需要打包，打包成动态库，不过文件名格式为lib + 动态库名 + .so后缀。
- 动态库的打包不需要使用ar命令，gcc就可以完成，但要注意在编译时要加上-fPIC选项，打包时加上-shared选项。

```
gcc -fPIC -c test1.c 
gcc -fPIC -c test2.c
gcc -shared test1.o test2.o -o libtest.so
```

- 使用动态链接的用法也和静态链接相同。

```
gcc -o main main.c -ltest
```

如果仅仅像上面的步骤是没有办法正常使用库的，我们可以通过加-Lpath指定搜索库文件的目录（-L.表示当前目录），默认情况下会到环境变量LD_LIBRARY_PATH指定的目录下搜索库文件，默认情况是/usr/lib，我们可以将库文件拷贝到那个目录下再链接。

### @静态库和动态库优缺点。

#### 静态库

- 静态库在程序编译时会被连接到目标代码中，程序运行时将不再需要该静态库。

静态链接库的优点

- 代码装载速度快，执行速度略比动态链接库快；
- 只需保证在开发者的计算机中有正确的.LIB文件，在以二进制形式发布程序时不需考虑在用户的计算机上.LIB文件是否存在及版本问题，可避免DLL地狱等问题。

静态链接库的缺点

- 使用静态链接生成的可执行文件体积较大，包含相同的公共代码，造成浪费；
- 当某个库被多次引用到时，内存中会有多份副本，浪费资源。

#### 动态库

- 动态库在程序编译时并不会被连接到目标代码中，而是在程序运行是才被载入，因此在程序运行时还需要动态库存在，动态库运行时会先检查内存中是否已经有该库的拷贝，若有则共享拷贝，否则重新加载动态库（C语言的标准库就是动态库）。

动态链接库的优点

- (1) 更加节省内存并减少页面交换；
- (2) DLL文件与EXE文件独立，只要输出接口不变（即名称、参数、返回值类型和调用约定不变），更换DLL文件不会对EXE文件造成任何影响，因而极大地提高了可维护性和可扩展性；
- (3) 不同编程语言编写的程序只要按照函数调用约定就可以调用同一个DLL函数；
- 动态库更新很容易，当库发生变化时，如果接口没变只需要用新的动态库替换掉就可以了。但是如果是静态库的话就需要重新被编译。
- (4)适用于大规模的软件开发，使开发过程独立、耦合度小，便于不同开发者和开发组织之间进行开发和测试。

动态链接库的缺点

- 使用动态链接库的应用程序不是自完备的，它依赖的DLL模块也要存在，如果使用载入时动态链接，程序启动时发现DLL不存在，系统将终止程序并给出错误信息。而使用运行时动态链接，系统不会终止，但由于DLL中的导出函数不可用，程序会加载失败；
- 速度比静态链接慢。
- 当某个模块更新后，如果新模块与旧的模块不兼容，那么那些需要该模块才能运行的软件，统统撕掉。这在早期Windows中很常见。