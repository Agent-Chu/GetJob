# 目录

- [面向对象基础](#面向对象基础)
- [设计模式](#设计模式)

---

## 面向对象基础

### 字段or属性

字段用于存储类中需要的数据，通常是private；属性是一个或者一对方法，允许其他类访问，通常是public，有get和set，其中set有一个隐式参数value用于赋值。通常用get获取字段，set修改字段。

```c++
private int shoutNum = 3;
public int ShoutNum{
  get{
    return shoutNum;
  }
  set{
    shoutNum = value;
  }
}

cat.ShoutNum = 5;
```

### 封装

每个对象都包含它能做的操作的所有信息，不依赖别的对象完成自己的操作。

优点：

- 减少耦合：可以独立的开发、测试、优化、使用、修改
- 类内部可以自由修改
- 类有清晰的对外接口
- 减轻维护负担，不影响其他模块
- 方便性能评估，分模块测试性能
- 可重用性，模块可以独立使用，降低大型系统风险

```c++
public class Person {

    private String name;
    //虽然gender用的是int存储，但是外界看不到，在get方法中可以进行修改
    private int gender;
    //外界无法获得age，没有get方法，但是可以被类内的work方法使用
    private int age;

    public String getName() {
        return name;
    }

    public String getGender() {
        return gender == 0 ? "man" : "woman";
    }

    public void work() {
        if (18 <= age && age <= 50) {
            System.out.println(name + " is working very hard!");
        } else {
            System.out.println(name + " can't work any more!");
        }
    }
}
```

### 继承

继承是is-a关系，如果B是A，则说明B能继承A。父类-子类，基类-派生类，子类继承的同时也有自己的新特性，

当使用继承时，遵循里氏替换原则。类B继承类A时，除添加新的方法完成新增功能P2外，尽量不要重写父类A的方法，
     也尽量不要重载父类A的方法。

- 子类拥有父类的protected和public的属性和功能
- 子类有自己的属性和功能
- 子类可以重写父类方法

父类：

```c++
class Animal{
  public Animal(string name){
    this.name=name;
  }
  public Animal(){
    this.name="无名";
  }
}
```

子类：

```c++
class Cat:Animal{
  public Cat():base(){
  }
  public Cat(string name):base(name){
  }
}
```

用base关键字代表父类，子类的构造函数的重写由是否有同样的参数来判断

缺点：

- 破坏包装，父类实现的细节会暴漏给子类
- 增加耦合性，当需要对父类的代码进行修改时，必须考虑到对子类产生的影响。有时修改了一点点代码都有可能需要对打断程序进行重构。
- 继承是侵入性的。只要继承，就必须拥有父类的所有属性和方法。
- 降低了代码的灵活性。因为继承时，父类会对子类有一种约束。

继承应该遵循里氏替换原则，子类对象必须能够替换掉所有父类对象。

### 多态

不同对象可以执行相同动作，但是需要通过他们自己的代码来实现，子类以父类的身份出现，子类的实现方式是自己的，子类以父类的方式出现时，子类特有的属性和方法不能使用。

通过虚函数（virtual）和重写（override）实现：

```c++
class Animal{
  public virtual string Shout(){
    return "";
  }
}

class Cat:Animal{
  public override string Shout(){
    ....
  }
}
```

### 抽象类与接口

继承树的非叶子节点应该都是抽象类，叶子节点都是具体类

区别：

|抽象类|接口|
|---|---|
|可以给出一些成员的实现|不包含成员的实现|
|抽象成员函数可以在子类中部分实现|接口成员必须完全实现|
|一个类只能继承一个抽象类|一个类可以实现多个接口|
|抽象类是对类的抽象|接口是对某种行为的抽象|
|对一些相似的对象用抽象类|对一些相似的行为用接口|
|泛化子类公共的特点|预先定义|

### 集合

ArrayList就是动态数组，可以动态的增加和减少元素，实现了ICollection和IList接口，灵活的设置数组的大小

```c++
using System.Collections;

IList arraylist;
arraylist = new ArrayList();
//or ArrayList arraylist = new ArrayList();

List.Add(i);
```

- Add方法用于添加一个元素到当前列表的末尾
- AddRange方法用于添加一批元素到当前列表的末尾
- Remove方法用于删除一个元素，通过元素本身的引用来删除
- RemoveAt方法用于删除一个元素，通过索引值来删除
- RemoveRange用于删除一批元素，通过指定开始的索引和删除的数量来删除
- Insert用于添加一个元素到指定位置，列表后面的元素依次往后移动
- InsertRange用于从指定位置开始添加一批元素，列表后面的元素依次往后移动
- Clear方法用于清除现有所有的元素
- Contains方法用来查找某个对象在不在列表之中

### 泛型

指定数据类型

```c++
IList<Animal> arraylist;
arraylist = new ArrayList<Animal>();
```

[面向对象思想](https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%9D%E6%83%B3.md#solid)

## 设计模式

[设计模式](https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.md#2-%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82simple-factory)