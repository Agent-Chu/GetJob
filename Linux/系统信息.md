# 系统信息

## 进程查询：ps

- 查看某个时间点的进程信息
- 查看自己的进程

```sh
ps -l
```

- 查看系统所有进程

```sh
ps aux
```

- 查看特定的进程

```sh
ps aux | grep threadx
```

- 查看正在运行进程

```shell
# 常结合grep筛选信息(e.g, ps -ef | grep xxx)
ps -ef
```

- 以完整格式显示所有进程

```shell
# 常结合grep筛选信息
ps -ajx
```

- 查看进程树

```sh
pstree -A
```

## 进程监控：top

- 实时显示进程信息，比如1,5,15分钟内负载，运行、休眠、僵尸进程数，用户、内核程序占CPU百分比，存储信息等。
- top可以定位具体哪个进程CPU占用率高和内存使用率高。
- 两秒钟刷新一次

```sh
top -d 2
```

- 交互模式下键入M进程列表按内存使用大小降序排列，键入P进程列表按CPU使用大小降序排列
- %id表示CPU空闲率，过低表示可能存在CPU存在瓶颈
- %wa表示等待I/O的CPU时间百分比，过高则I/O存在瓶颈 > 用iostat进一步分析

### cpu占用100%排查

- 步骤一、找到最耗CPU的进程
  - 执行top -c ，显示进程运行信息列表
  - 键入P (大写p)，进程按照CPU使用率排序
  - 最耗CPU的进程PID为10765
- 步骤二：找到最耗CPU的线程
  - top -Hp 10765 ，显示一个进程的线程运行信息列表
  - 键入P (大写p)，线程按照CPU使用率排序
  - 进程10765内，最耗CPU的线程PID为10804
- 步骤三：将线程PID转化为16进制
  - printf “%x” 10804
  - 10804对应的16进制是0x2a34
  - 之所以要转化为16进制，是因为堆栈里，线程id是用16进制表示的。
- 步骤四：查看堆栈，找到线程在干嘛
  - jstack 10765 | grep ‘0x2a34’ -C5 --color
  - 打印进程堆栈
  - 通过线程id，过滤得到线程堆栈
  - 找到了耗CPU高的线程对应的线程名称“AsyncLogger-1”，以及看到了该线程正在执行代码的堆栈。

## 占用端口进程：lsof

- 查看占用某端口的进程
- mysql:3307
- ftp:20/21
- ssh:22
- telnet:23
- smtp:25
- dns:53
- http:80
- pop3:110
- https:443

```shell
lsof -i:53
```

- 查看某用户打开的文件

```shell
lsof -u inx
```

- 查看指定进程打开的文件

```shell
# -p(process)为进程，后接进程PID
lsof -p 12345
```

- 查看指定目录下被进程打开的文件

```shell
# 这里是"+d"，需要注意，使用"+D"递归目录
lsof +d /test
```

## 内存使用量：free

- 内存使用量

```shell
# 可获得内存及交换区的总量，已使用量，空闲量等信息
free
```

## 监控性能指标：sar

- 监控CPU负载

```shell
# 加上-q可以查看运行队列中进程数，系统上进程大小，平均负载等
# 这里"1"表示采样时间间隔是1秒，这里"2"表示采样次数为2
sar -q 1 2
```

- 监控CPU使用率

```shell
# 可以显示CPU使用情况
# 参数意义同上
sar -u 1 2
```

- 监控内存

```shell
# 可以显示内存使用情况
# 参数意义同上
sar -r 1 2
```

- 页面交换查询

```shell
# 可以查看是否发生大量页面交换，吞吐率大幅下降时可用
# 参数意义同上
sar -W 1 2
```