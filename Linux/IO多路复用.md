# I/O 多路复用

- select/poll/epoll 都是 I/O 多路复用的具体实现，select 出现的最早，之后是 poll，再是 epoll。

- 使用 select 或者 poll 等待数据，这个函数会轮询所有套接字，当某个套接字有数据到达，就通知用户进程
- 用户进程调用了select，整个进程会被阻塞，内核开始监视套接字
- 它可以让单个进程具有处理多个 I/O 事件的能力。又被称为 Event Driven I/O，即事件驱动 I/O。

缺点：

- 模型本身和阻塞IO区别不大，甚至更差，因为要使用两个系统调用 select 和 recvfrom

优点：

- 可以处理多个链接
- 如果一个 Web 服务器没有 I/O 复用，那么每一个 Socket 连接都需要创建一个线程去处理。如果同时有几万个连接，那么就需要创建相同数量的线程。相比于多进程和多线程技术，I/O 复用不需要进程线程创建和切换的开销，系统开销更小。

## select

- select 有三种类型的描述符类型：readset、writeset、exceptset，分别对应读、写、异常条件的描述符集合。

## select 和 poll 比较

- select 会修改描述符，而 poll 不会；
- select 的描述符类型(fd_set)使用数组实现，FD_SETSIZE 大小默认为 1024，因此默认只能监听 1024 个描述符。如果要监听更多描述符的话，需要修改 FD_SETSIZE 之后重新编译；而 poll 的描述符类型(pollfd)使用链表实现，没有描述符数量的限制；
- poll 提供了更多的事件类型，并且对描述符的重复利用上比 select 高。
- select 和 poll 每次调用都需要将全部描述符从应用进程缓冲区复制到内核缓冲区。
- select 和 poll 的返回结果中没有声明哪些描述符已经准备好，所以如果返回值大于 0 时，应用进程都需要使用轮询的方式来找到 I/O 完成的描述符。
- poll 在应付大文件的时候快
- 几乎所有的系统都支持 select，但是只有比较新的系统支持 poll。

## epoll及其优点

- epoll_ctl() 用于向内核注册新的描述符或者是改变某个文件描述符的状态。已注册的描述符在内核中会被维护在一棵红黑树上，通过回调函数内核会将 I/O 准备好的描述符加入到一个链表中管理，进程调用 epoll_wait() 便可以得到事件完成的描述符。
- epoll 只需要将描述符从进程缓冲区向内核缓冲区拷贝一次，并且进程不需要通过轮询来获得事件完成的描述符。
- epoll 仅适用于 Linux OS。select兼容性好
- epoll 没有描述符数量限制。select 最大上限是1024/2048，而 epoll 最大是最大可以打开文件的数目，一般远大于2048
- epoll 对多线程编程更有友好，一个线程调用了 epoll_wait() 另一个线程关闭了同一个描述符也不会产生像 select 和 poll 的不确定情况。
- epoll 的效率不随打开文件数目的增加而线性下降

## epoll工作模式

- epoll 的描述符事件有两种触发模式：LT（level trigger）（水平触发）和 ET（edge trigger）（边缘触发）。
- LT 模式：当 epoll_wait() 检测到采用LT的描述符事件到达时，将此事件通知进程，进程可以不立即处理该事件，下次调用 epoll_wait() 会再次通知进程。是默认的一种模式，并且同时支持 Blocking 和 No-Blocking。
- ET 模式：当 epoll_wait() 检测到采用ET的描述符事件到达时，将此事件通知进程，通知之后进程必须立即处理事件，下次再调用 epoll_wait() 时不会再得到事件到达的通知。
- ET 模式：很大程度上减少了 epoll 事件被重复触发的次数，因此效率要比 LT 模式高。只支持 No-Blocking，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。

## select epoll 区别

- select 的 timeout 参数精度为 1ns，而 poll 和 epoll 为 1ms，因此 select 更加适用于实时性要求比较高的场景，比如核反应堆的控制。
- epoll 没有描述符数量限制。select 最大上限是1024/2048，而 epoll 最大是最大可以打开文件的数目，一般远大于2048
- epoll 只运行在 Linux 平台上，select 可移植性更好，几乎被所有主流平台所支持。
- epoll 可以同时轮询大量的描述符，并且这些连接最好是长连接。如果需要同时监控小于 1000 个描述符，而且都是非常短暂的，就没有必要使用 epoll

## epoll数据结构epoll_event定义

```c++
typedef union epoll_data {
    void *ptr;
    int fd;
    __uint32_t u32;
    __uint64_t u64;
}epoll_data_t;
struct epoll_event {
    __uint32_t events; /* Epoll events */
    epoll_data_t data; /* User data variable */
};
```

- epoll_data是一个union结构体,可以保存很多类型的信息:fd,指针,等等.有了这个结构体,epoll很快定位，在一个大规模并发的服务器中,轮询IO是最耗时间的操作之一

## epoll 为什么速度快

- 调用epoll_ctl往里塞入百万个句柄时，epoll_wait仍然可以飞快的返回，并有效的将发生事件的句柄给我们用户。
- 这是由于我们在调用epoll_create时，内核除了帮我们在epoll文件系统里建了个file结点，在内核cache里建了个红黑树用于存储以后epoll_ctl传来的socket外，还会再建立一个list链表，用于存储准备就绪的事件，当epoll_wait调用时，仅仅观察这个list链表里有没有数据即可。有数据就返回，没有数据就sleep，等到timeout时间到后即使链表没数据也返回。而不需要像select那样需要在用户态去判断每个套接字上是否有事件发生。所以，epoll_wait非常高效。
- epoll_ctl() 用于向内核注册新的描述符或者是改变某个文件描述符的状态。已注册的描述符在内核中会被维护在一棵红黑树上，通过回调函数内核会将 I/O 准备好的描述符加入到准备就绪list链表中管理，进程调用 epoll_wait() 便可以得到事件完成的描述符。
　　
- 执行epoll_create时，创建了红黑树和就绪链表
- 执行epoll_ctl时，如果增加socket句柄，则检查在红黑树中是否存在，存在立即返回，不存在则添加到树干上，然后向内核注册回调函数，用于当中断事件来临时向准备就绪链表中插入数据。
- 执行epoll_wait时立刻返回准备就绪链表里的数据即可。

## 不同的线程或者进程在处理同一个SOCKET的事件

- epoll有两种触发的方式即LT（水平触发）和ET（边缘触发）两种，在前者，只要存在着事件就会不断的触发，直到处理完成，而后者只触发一次相同事件或者说只在从非触发到触发两个状态转换的时候儿才触发。
- 如果是多线程在处理，一个SOCKET事件到来，数据开始解析，这时候这个SOCKET又来了同样一个这样的事件，而你的数据解析尚未完成，那么程序会自动调度另外一个线程或者进程来处理新的事件，这造成一个很严重的问题，不同的线程或者进程在处理同一个SOCKET的事件，这会使程序的健壮性大降低而编程的复杂度大大增加，即使在ET模式下也有可能出现这种情况

解决方法：

- 第一种方法是在单独的线程或进程里解析数据，也就是说，接收数据的线程接收到数据后立刻将数据转移至另外的线程。

- 第二种方法 EPOLLONESHOT方法，如果对描述符socket注册了EPOLLONESHOT事件，那么操作系统最多触发其上注册的一个可读、可写或者异常事件，且只触发一次。想要下次再触发则必须使用epoll_ctl重置该描述符上注册的事件，包括EPOLLONESHOT 事件。