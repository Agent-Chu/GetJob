# 网络 I/O 模型

## IO两种操作

- 同步IO：必须等IO操作结束后，控制权才返回给用户进程
- 异步IO：无需等待IO操作结束，控制权返回给用户进程

## 网络通讯

- 输入操作：等待数据到达套接字接收缓冲区
- 输出操作：等待套接字发送缓冲区有足够的空间容纳将要发送过来的数据
- 服务器接受连接请求：等待新的客户端连接请求的到来
- 客户端发送连接请求：等待服务器回送客户发丝的 SYN 所对应的 ACK

一个输入操作通常包括两个阶段：

- 等待数据准备好
- 从内核向进程复制数据

对于一个套接字上的输入操作，第一步通常涉及等待数据从网络中到达。当所等待数据到达时，它被复制到内核中的某个缓冲区。第二步就是把数据从内核缓冲区复制到应用进程缓冲区。

## 四种网络 I/O 模型

- 阻塞式 I/O
- 非阻塞式 I/O
- I/O 复用（select 和 poll）
- 异步 I/O（AIO）

## IO模型的两个阶段

- wait for data：准备数据，等到足够的数据到来，进入系统内核
- copy data from kernel to user：将数据从系统内核拷贝到用户内存中

## 阻塞式 I/O

- 在等待数据和拷贝数据两个阶段，应用进程都被阻塞
- 直到数据复制到应用进程缓冲区中才返回。

- 在阻塞的过程中，其它程序还可以执行，因此阻塞不意味着整个操作系统都被阻塞。因为其他程序还可以执行，所以不消耗 CPU 时间，这种模型的 CPU 利用率效率会比较高。

recvfrom 用于接收 Socket 传来的数据，并复制到应用进程的缓冲区 buf 中。这里把 recvfrom() 当成系统调用。

```c
ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags, struct sockaddr *src_addr, socklen_t *addrlen);
```

## 非阻塞式 I/O

- 应用进程执行系统调用之后，内核返回一个错误码。
- 应用进程可以继续执行，但是需要不断的执行系统调用来获知 I/O 是否完成，这种方式称为轮询（polling）。
- 由于 CPU 要处理更多的系统调用，因此这种模型的 CPU 利用率是比较低的。

## I/O 多路复用

- select/poll/epoll 都是 I/O 多路复用的具体实现，select 出现的最早，之后是 poll，再是 epoll。

- 使用 select 或者 poll 等待数据，这个函数会轮询所有套接字，当某个套接字有数据到达，就通知用户进程
- 用户进程调用了select，整个进程会被阻塞，内核开始监视套接字
- 它可以让单个进程具有处理多个 I/O 事件的能力。又被称为 Event Driven I/O，即事件驱动 I/O。

缺点：

- 模型本身和阻塞IO区别不大，甚至更差，因为要使用两个系统调用 select 和 recvfrom

优点：

- 可以处理多个链接
- 如果一个 Web 服务器没有 I/O 复用，那么每一个 Socket 连接都需要创建一个线程去处理。如果同时有几万个连接，那么就需要创建相同数量的线程。相比于多进程和多线程技术，I/O 复用不需要进程线程创建和切换的开销，系统开销更小。

## 异步 I/O

- 应用进程执行 aio_read 系统调用会立即返回，应用进程可以继续执行，不会被阻塞，内核会在所有操作完成之后向应用进程发送通知信号。
- 进程收到通知后开始阻塞，开始拷贝数据

## I/O 模型比较

- 在拷贝数据阶段都会阻塞
- 同步 I/O：将数据从内核缓冲区复制到应用进程缓冲区的阶段，应用进程会阻塞。
- 异步 I/O：不会阻塞。
- 阻塞式 I/O、非阻塞式 I/O、I/O 复用 都是同步 I/O，它们的主要区别在第一个阶段。
- 非阻塞式 I/O 和异步 I/O 在第一阶段不会阻塞。

<div align="center"> <img src="pics/1492928105791_3.png"/> </div><br>