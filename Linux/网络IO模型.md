# 网络 I/O 模型

## IO两种操作

- 同步IO：必须等IO操作结束后，控制权才返回给用户进程
- 异步IO：无需等待IO操作结束，控制权返回给用户进程

## 网络通讯

- 输入操作：等待数据到达套接字接收缓冲区
- 输出操作：等待套接字发送缓冲区有足够的空间容纳将要发送过来的数据
- 服务器接受连接请求：等待新的客户端连接请求的到来
- 客户端发送连接请求：等待服务器回送客户发丝的 SYN 所对应的 ACK

## IO模型的两个阶段

- 等待数据准备好（wait for data），通常涉及等待数据从网络中到达
- 从内核向进程复制数据（copy data from kernel to user），就是把数据从内核缓冲区复制到应用进程缓冲区。

## 五种网络 I/O 模型

- 阻塞式 I/O
- 非阻塞式 I/O
- I/O 复用（select 和 poll）
- 信号驱动I/O（SIGIO）
- 异步 I/O（AIO）

## 阻塞式 I/O

- 在等待数据和拷贝数据两个阶段，应用进程都被阻塞
- 直到数据复制到应用进程缓冲区中才返回。

- 在阻塞的过程中，其它程序还可以执行，因此阻塞不意味着整个操作系统都被阻塞。因为其他程序还可以执行，所以不消耗 CPU 时间，这种模型的 CPU 利用率效率会比较高。

recvfrom 用于接收 Socket 传来的数据，并复制到应用进程的缓冲区 buf 中。这里把 recvfrom() 当成系统调用。

```c
ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags, struct sockaddr *src_addr, socklen_t *addrlen);
```

## 非阻塞式 I/O

- 应用进程执行系统调用之后，内核返回一个错误码。
- 应用进程可以继续执行，但是需要不断的执行系统调用来获知 I/O 是否完成，这种方式称为轮询（polling）。
- 由于 CPU 要处理更多的系统调用，因此这种模型的 CPU 利用率是比较低的。

## I/O 多路复用

- select/poll/epoll 都是 I/O 多路复用的具体实现，select 出现的最早，之后是 poll，再是 epoll。

- 使用 select 或者 poll 等待数据，这个函数会轮询所有套接字，当某个套接字有数据到达，就通知用户进程
- 用户进程调用了select，整个进程会被阻塞，内核开始监视套接字
- 它可以让单个进程具有处理多个 I/O 事件的能力。又被称为 Event Driven I/O，即事件驱动 I/O。

缺点：

- 模型本身和阻塞IO区别不大，甚至更差，因为要使用两个系统调用 select 和 recvfrom

优点：

- 可以处理多个链接
- 如果一个 Web 服务器没有 I/O 复用，那么每一个 Socket 连接都需要创建一个线程去处理。如果同时有几万个连接，那么就需要创建相同数量的线程。相比于多进程和多线程技术，I/O 复用不需要进程线程创建和切换的开销，系统开销更小。

## 信号驱动I/O（SIGIO）

- 让内核在描述字就绪时发送SIGIO信号通知我们
- 首先开启套接口的信号驱动I/O功能，并通过sigaction系统调用安装一个信号处理函数。该系统调用立即返回，我们的进程继续工作，也就是说它没有被阻塞。当数据报准备好读取时，内核就为该进程产生一个SIGIO信号。我们随后既可以在信号处理函数中调用recvfrom读取数据报，并通知主循环数据已准备好待处理，也可以立即通知主循环，让它读取数据报。
- 无论如何处理SIGIO信号，这种模型的优势在于等待数据报到达期间，进程不被阻塞。主循环可以继续执行，只要不时等待来自信号处理函数的通知：既可以是数据已准备好被处理，也可以是数据报已准备好被读取。

## 异步 I/O

- 应用进程执行 aio_read 系统调用会立即返回，应用进程可以继续执行，不会被阻塞，内核会在所有操作完成之后向应用进程发送通知信号。
- 进程收到通知后开始阻塞，开始拷贝数据

## I/O 模型比较

- 在拷贝数据阶段都会阻塞
- 同步 I/O：将数据从内核缓冲区复制到应用进程缓冲区的阶段，应用进程会阻塞。
- 异步 I/O：不会阻塞。
- 阻塞式 I/O、非阻塞式 I/O、I/O 复用 都是同步 I/O，它们的主要区别在第一个阶段。
- 非阻塞式 I/O 和异步 I/O 在第一阶段不会阻塞。

<div align="center"> <img src="pics/1492928105791_3.png"/> </div><br>