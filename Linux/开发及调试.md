# 开发及调试

## 调试工具：gdb

- 运行得不到正确结果可以通过gdb设置断点来查看每个中间变量值，以此来确定哪里出了问题。因为gdb调试内容较多，这里不详细说明。另外，gdb出了可以单步查看变量值，还可以分析coredump文件来排查错误。
    - 服务器端调试必备。
    - [详见](http://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/gdb.html)
    
## 查看依赖库：ldd

- 命令：ldd ./server

- 可以查看可执行文件server所需的所有动态库，动态库所在目录及其被映射到的虚拟地址空间。
    - 程序依赖库查询
    ```shell
    # ldd后接可执行文件
    # 第一列为程序依赖什么库，第二列为系统提供的与程序需要的库所对应的库，第三列为库加载的开始地址
    # 前两列可以判断系统提供的库和需要的库是否匹配，第三列可以知道当前库在进程地址空间中对应的开始位置

    ldd a.out
    ```

## 二进制文件分析：objdump
    - 反汇编，需要理解汇编语言
    - [详见](http://man.linuxde.net/objdump)

## ELF文件格式分析：readelf
    - 可以得到ELF文件各段内容，分析链接、符号表等需要用到
    - [详见](http://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/readelf.html)

## 跟踪进程中系统调用：strace
    - [详见](http://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/strace.html)

- 命令：strace ./server

- 上面已经提到TKeed server的CPU占用率为99%，那么问题通常一定是出在了死循环上。我们接下来在代码中找到死循环位置。因为程序中epoll_wait需要阻塞进程，我们怀疑是不是这里没有阻塞，这时就可以通过上面的方式运行server程序。此时可以打印出没次系统调用及其参数等，我们也可以加-o filename将系统调用信息保存下来。

## 跟踪进程栈：pstack
    - [详见](http://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/pstack.html#)

## 进程内存映射：pmap
    - 显示进程内存映射
    ```shell
    # -x显示扩展信息，后接进程pid
    # Address: 内存开始地址
    # 显示信息：
        Kbytes: 占用内存的字节数
        RSS: 保留内存的字节数
        Dirty: 脏页的字节数（包括共享和私有的）
        Mode: 内存的权限：read、write、execute、shared、private
        Mapping: 占用内存的文件、或[anon]（分配的内存）、或[stack]（堆栈）
        Device: 设备名 (major:minor)

    pmap -x 12345
    ```