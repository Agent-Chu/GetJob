# Zookeeper

## 基本概念

- ZooKeeper是一个开源的分布式协调服务系统
  - 1.统一配置管理
  - 2.统一命名服务
  - 3.Master选举
  - 4.分布式锁
  - 5.服务注册与推送
  - 6.集群管理
- 使用分布式系统就无法避免对节点管理的问题(需要实时感知节点的状态、对节点进行统一管理等等)，而由于这些问题处理起来可能相对麻烦和提高了系统的复杂性，ZooKeeper作为一个能够通用解决这些问题的中间件就应运而生了。

## 1.统一配置管理

- 比如我们现在有三个系统A、B、C，他们有三份配置，分别是ASystem.yml、BSystem.yml、CSystem.yml，然后，这三份配置又非常类似，很多的配置项几乎都一样。
- 此时，如果我们要改变其中一份配置项的信息，很可能其他两份都要改。并且，改变了配置项的信息很可能就要重启系统
- 于是，我们希望把ASystem.yml、BSystem.yml、CSystem.yml相同的配置项抽取出来成一份公用的配置common.yml，并且即便common.yml改了，也不需要系统A、B、C重启。
- 做法：我们可以将common.yml这份配置放在ZooKeeper的Znode节点中，系统A、B、C监听着这个Znode节点有无变更，如果变更了，及时响应。

## 2.统一命名服务

- 统一命名服务的理解其实跟域名一样，是我们为这某一部分的资源给它取一个名字，别人通过这个名字就可以拿到对应的资源。
- 比如说，现在我有一个域名www.java3y.com，但我这个域名下有多台机器：

    192.168.1.1
    192.168.1.2
    192.168.1.3
    192.168.1.4

- 别人访问www.java3y.com即可访问到我的机器，而不是通过IP去访问。

## 3.Master选举

- 动态选举Master的功能。(如果集群是主从架构模式下)
- Znode节点的类型是带顺序号的临时节点(EPHEMERAL_SEQUENTIAL)
- Zookeeper会每次选举最小编号的作为Master，如果Master挂了，自然对应的Znode节点就会删除。然后让新的最小编号作为Master，这样就可以实现动态选举的功能了。

## 4.分布式锁

- 创建一个锁目录 /locks
- 系统A、B、C都去访问/locks节点
- 当一个客户端需要获取锁时，在 /locks 下创建临时的且有序的子节点
(EPHEMERAL_SEQUENTIAL)，比如，系统A创建了id_000000节点，系统B创建了id_000002节点，系统C创建了id_000001节点。
- 接着，拿到/locks节点下的所有子节点(id_000000,id_000001,id_000002)，判断自己创建的是不是最小的那个节点
  - 如果是，则拿到锁。
  - 如果不是，则监听比自己要小1的节点变化
- 执行完业务代码后，释放锁，把创建的节点给删掉

## 6.集群管理

- 感知节点的动态新增或者删除
- 感知节点的上下线变化
- 以我们三个系统A、B、C为例，在ZooKeeper中创建临时节点即可：
只要系统A挂了，那/groupMember/A这个节点就会删除，通过监听groupMember下的子节点，系统B和C就能够感知到系统A已经挂了。(新增也是同理)

## 集群的角色

- ZooKeeper中包含Leader、Follower和Observer三个角色；
- 通过一次选举过程，被选举的机器节点被称为Leader，Leader机器为客户端提供读和写服务；
- Follower和Observer是集群中的其他机器节点，唯一的区别就是：Observer不参与Leader的选举过程，也不参与写操作的过半写成功策略。

## 节点类型

- Zookeeper 提供了一种树形结构级的命名空间，节点是树的节点
- 持久化节点（永久节点）（PERSISTENT）：不会因为会话结束或者超时而消失；
- 有序节点（PERSISTENT_SEQUENTIAL）：会在节点名的后面加一个数字后缀，并且是有序的，这种节点会根据当前已存在的节点数自动加 1，例如生成的有序节点为 /lock/node-0000000000，它的下一个有序节点则为 /lock/node-0000000001，以此类推。
- 临时节点（EPHEMERAL）：如果会话结束或者超时就会消失，客户端session超时这类节点就会被自动删除；
- 临时自动编号节点（EPHEMERAL_SEQUENTIAL）

## 监听器 Watcher

- 为一个节点注册监听器，在节点状态发生改变时，会给客户端发送消息。
  - 监听Znode节点的数据变化
  - 监听子节点的增减变化
- ZooKeeper允许用户在指定节点上注册一些Watcher，并且在一些特定事件触发的时候，ZooKeeper会通过事件通知到感兴趣的客户端上。

## Zookeeper 会话

- 会话就是一个客户端与服务器之间的一个TCP长连接。客户端和服务器的一切交互都是通过这个长连接进行的；
- 会话会在客户端与服务器断开链接后，如果经过了设点的sessionTimeout时间内没有重新链接后失效。
- 如果一个已经获得锁的会话超时了，因为创建的是临时节点，所以该会话对应的临时节点会被删除，其它会话就可以获得锁了。可以看到，Zookeeper 分布式锁不会出现数据库的唯一索引实现的分布式锁释放锁失败问题。

## Zookeeper 版本

- ZooKeeper为每一个ZNode节点维护一个叫做Stat的数据结构，在Stat中维护了节点相关的三个版本：
  - 当前ZNode的版本 version
  - 当前ZNode子节点的版本 cversion
  - 当前ZNode的ACL(Access Control Lists)版本 aversion

## Zookeeper ACL（Access Control Lists）控制权限

- CREATE：创建子节点的权限，针对子节点的权限控制。
- READ：获取节点数据和子节点列表的权限
- WRITE：跟新节点数据的权限
- DELETE：删除子节点的权限，针对子节点的权限控制。
- ADMIN：设置节点ACL的权限。

## Zookeeper 有几种部署模式？

- 单机模式，集群模式，伪集群模式

## Zookeeper 怎么保证主从节点的状态同步？

- Zookeeper的核心是原子广播机制，这个机制保证了各个server之间的同步。实现这个机制的协议叫做Zab协议。
- Zab协议有两种模式，它们分别是恢复模式和广播模式。
  - (1) 恢复模式，当服务启动或者在领导者崩溃后，Zab就进入了恢复模式，当领导者被选举出来，且大多数server完成了和leader的状态同步以后，恢复模式就结束了。状态同步保证了leader和server具有相同的系统状态。
  - (2) 广播模式，一旦Leader已经和多数的Follower进行了状态同步后，他就可以开始广播消息了，即进入广播状态。这时候当一个Server加入ZooKeeper服务中，它会在恢复模式下启动，发现Leader，并和Leader进行状态同步。待到同步结束，它也参与消息广播。ZooKeeper服务一直维持在Broadcast状态，直到Leader崩溃了或者Leader失去了大部分的Followers支持。

## Zookeeper 通知机制？

- 客户端在向 ZooKeeper 服务器注册 Watcher 的同时，会将 Watcher 对象存储在客户端的 WatchManager 中。
- 当ZooKeeper 服务器触发 Watcher 事件后，会向客户端发送通知，客户端线程从 WatchManager 的实现类中取出对应的 Watcher 对象来执行回调逻辑。

## 羊群效应

一个节点未获得锁，只需要监听自己的前一个子节点，这是因为如果监听所有的子节点，那么任意一个子节点状态改变，其它所有子节点都会收到通知（羊群效应），而我们只希望它的后一个子节点收到通知。