# RabbitMQ

## RabbitMQ介绍

- RabbitMQ是使用Erlang编写的一个开源的消息队列，本身支持很多的协议：AMQP，XMPP, SMTP, STOMP，也正因如此，它非常重量级，更适合于企业级的开发。同时实现了Broker构架，这意味着消息在发送给客户端时先在中心队列排队。对路由，负载均衡或者数据持久化都有很好的支持。
- AMQP的主要特征是面向消息、队列、路由（包括点对点和发布/订阅）、可靠性、安全。AMQP协议更多用在企业系统内，对数据一致性、稳定性和可靠性要求很高的场景，对性能和吞吐量的要求还在其次。

## rabbitmq 特点

- 可靠性（Reliability）RabbitMQ 使用一些机制来保证可靠性，如持久化、传输确认、发布确认。
- 灵活的路由（Flexible Routing）在消息进入队列之前，通过 Exchange 来路由消息的。对于典型的路由功能，RabbitMQ 已经提供了一些内置的 Exchange 来实现。针对更复杂的路由功能，可以将多个 Exchange 绑定在一起，也通过插件机制实现自己的 Exchange 。
- 消息集群（Clustering）多个 RabbitMQ 服务器可以组成一个集群，形成一个逻辑 Broker 。
- 高可用（Highly Available Queues）队列可以在集群中的机器上进行镜像，使得在部分节点出问题的情况下队列仍然可用。
- 多种协议（Multi-protocol）RabbitMQ 支持多种消息队列协议，比如 STOMP、MQTT 等等。
- 多语言客户端（Many Clients）RabbitMQ 几乎支持所有常用语言，比如 Java、.NET、Ruby 等等。
- 管理界面（Management UI）RabbitMQ 提供了一个易用的用户界面，使得用户可以监控和管理消息 Broker 的许多方面。
- 跟踪机制（Tracing）如果消息异常，RabbitMQ 提供了消息跟踪机制，使用者可以找出发生了什么。
- 插件机制（Plugin System）RabbitMQ 提供了许多插件，来从多方面进行扩展，也可以编写自己的插件。

## rabbitmq 角色

- Producer:消息生产者,就是投递消息的程序.
- Consumer:消息消费者,就是接受消息的程序.

## rabbitmq 重要组件

- Broker:它提供一种传输服务,它的角色就是维护一条从生产者到消费者的路线，保证数据能按照指定的方式进行传输,
- Exchange：消息交换机,它指定消息按什么规则,路由到哪个队列。
- Queue:消息的载体,每个消息都会被投到一个或多个队列。
- Binding:绑定，它的作用就是把exchange和queue按照路由规则绑定起来.
- Routing Key:路由关键字,exchange根据这个关键字进行消息投递。
- vhost:虚拟主机,一个broker里可以有多个vhost，用作不同用户的权限分离。
- Channel:消息通道,在客户端的每个连接里,可建立多个channel.

## rabbitmq 三种部署模式

- 1）单节点模式：最简单的情况，非集群模式，节点挂了，消息就不能用了。业务可能瘫痪，只能等待。
- 2）普通模式：默认的集群模式，某个节点挂了，该节点上的消息不能用，有影响的业务瘫痪，只能等待节点恢复重启可用（必须持久化消息情况下）。
- 3）镜像模式：把需要的队列做成镜像队列，存在于多个节点，属于RabbitMQ的HA方案

## rabbitmq 怎么避免消息丢失

- 1.消息持久化，RabbitMQ 的消息默认存放在内存上面，如果不特别声明设置，消息不会持久化保存到硬盘上面的，如果节点重启或者意外crash掉，消息就会丢失。
- 2.ACK确认机制，多个消费者同时收取消息，比如消息接收到一半的时候，一个消费者死掉了(逻辑复杂时间太长，超时了或者消费被停机或者网络断开链接)，如何保证消息不丢？这个使用就要使用Message acknowledgment 机制，就是消费端消费完成要通知服务端，服务端才把消息从内存删除。这样就解决了，及时一个消费者出了问题，没有同步消息给服务端，还有其他的消费端去消费，保证了消息不丢的case。
- 3.设置集群镜像模式
- 4.消息补偿机制，需要建立在消息要写入DB日志，发送日志，接受日志，两者的状态必须记录。然后根据DB日志记录check 消息发送消费是否成功，不成功，进行消息补偿措施，重新发送消息处理。

## rabbitmq 的消息是怎么发送的？

- （1）客户端连接到消息队列服务器，打开一个channel。
- （2）客户端声明一个exchange，并设置相关属性。
- （3）客户端声明一个queue，并设置相关属性。
- （4）客户端使用routing key，在exchange和queue之间建立好绑定关系。
- （5）客户端投递消息到exchange。

## 要保证消息持久化成功的条件有哪些？

- queue，exchange和Message都持久化；
- 引入RabbitMQ的mirrored-queue即镜像队列，这个相当于配置了副本，当master在此特殊时间内crash掉，可以自动切换到slave，这样有效的保障了HA,；

## rabbitmq 持久化有什么缺点？

- （1）如果消息的自动确认为true，那么在消息被接收以后，RabbitMQ就会删除该消息，假如消费端此时宕机，那么消息就会丢失。因此需要将消息设置为手动确认。
- （2）设置手动确认会出现另一个问题，如果消息已被成功处理，但在消息确认过程中出现问题，那么在消费端重启后，消息会重新被消费。
- （3）发送端为了保证消息会成功投递，一般会设定重试。如果消息发送至RabbitMQ之后，在RabbitMQ回复已成功接收消息过程中出现异常，那么发送端会重新发送该消息，从而造成消息重复发送。
- （4）RabbitMQ的消息磁盘写入，如果出现问题，也会造成消息丢失。

## rabbitmq 有几种广播类型？

- fanout: 所有bind到此exchange的queue都可以接收消息（纯广播，绑定到RabbitMQ的接受者都能收到消息）；
- direct: 通过routingKey和exchange决定的那个唯一的queue可以接收消息；
- topic:所有符合routingKey(此时可以是一个表达式)的routingKey所bind的queue可以接收消息；

## rabbitmq 怎么实现延迟消息队列？

- 第一步：给队列或者指定消息设置过期时间（TTL），过期后变成 死信
- 第二部：设置死信的转发规则（如果没有任何规则，则直接丢弃死信），从新消费

## rabbitmq 集群有什么用？

- 允许消费者和生产者在Rabbit节点崩溃的情况下继续运行；
- 通过增加节点来扩展Rabbit处理更多的消息，承载更多的业务量；

## rabbitmq 节点的类型有哪些？

- 内存节点，就是将所有数据放在内存
- 磁盘节点，将数据放在磁盘

## rabbitmq 集群搭建需要注意哪些问题？

## rabbitmq 每个节点是其他节点的完整拷贝吗？为什么？

不是，队列的完整信息只放在一个节点，其他节点存放的是该队列的指针

## rabbitmq 集群中唯一一个磁盘节点崩溃了会发生什么情况？

- 如果唯一的磁盘节点崩溃，集群是可以保持运行的，但不能更改任何东西。
- 不能创建队列
- 不能创建交换器
- 不能创建绑定
- 不能添加用户
- 不能更改权限
- 不能添加和删除集群几点

## rabbitmq 对集群节点停止顺序有要求吗？

- 启动顺序：磁盘节点 => 内存节点
- 关闭顺序：内存节点 => 磁盘节点
