### 给出一个非空的字符串，判断这个字符串是否是由它的一个子串进行多次首尾拼接构成的。
例如，"abcabcabc"满足条件，因为它是由"abc"首尾拼接而成的，而"abcab"则不满足条件。 

#include <iostream>
using namespace std;
int main()
{
    string str;
    cin>>str;
    int fPos = 0,rPos =1,sLen = 1;
    int len = str.size();
    for(;rPos < len ; rPos++ ){
        if(str[fPos] == str[rPos]){//如果匹配，则fPos++
            fPos++;
        }else{
            sLen =  rPos+1;//如果不匹配，则认为0~rPos之间为子串，其长度为rPos+1
            fPos = 0;
        }
        if(fPos == sLen && rPos != len -1){
            fPos = 0;//如果匹配到当前子串的结尾，则从子串开头匹配。
        }
    }
    if(fPos != sLen ){
        cout<<"false"<<endl;
    }else{
        cout<<str.substr(0,sLen)<<endl;
    }
    return 0;
}

### 给出一个正整数n，请给出所有的包含n个'('和n个')'的字符串，使得'('和')'可以完全匹配。
例如：
'(())()'，'()()()' 都是合法的；
'())()('是不合法的。
请按照__字典序__给出所有合法的字符串。 


LeetCode22原题。

思路可以参照：https://blog.csdn.net/zjc_game_coder/article/details/78520742
代码可以参照：http://www.cnblogs.com/grandyang/p/4444160.html

### 给出一个整数n，将n分解为至少两个整数之和，使得这些整数的乘积最大化，输出能够获得的最大的乘积。
例如：
2=1+1，输出1；
10=3+3+4，输出36。 

import java.util.Scanner;
public class Main {
    /*
     * 举例计算11,11=5+6,5*6=30,11=3+4+5,3*4*4=48,11=2+3+3+3,2*3*3*3=54,11=1
     */
    static int p(int num) {
        int maxMul = 1;
        //i表示分解为i个数的加法，这些数相差不超过1.在所有的分解法中选择乘积最大的。
        for (int i = 2; i < num; i++) {
            int rem = num % i;
            int quo = num / i;
            int mul = 1;
            // int j=1;
            for (int j = 1; j <= i - rem; j++)
                mul *= quo;
            for (int j = 1; j <= rem; j++)
                mul *= (quo + 1);
            if (mul > maxMul)
                maxMul = mul;
            else
                return maxMul;
        }
        return maxMul;
    }
    public static void main(String[] args) {
        // TODO Auto-generated method stub
//        int num=2;
//        num=10;
        Scanner scanner=new Scanner(System.in);
//        返回：从输入信息扫描的 int
        int num=scanner.nextInt();
        System.out.println(p( num));
         
    }
}

### 二叉树的最大路径。
### 给定一个二叉树，原地将它展开为链表
### 红黑树/旋转
### 二叉搜索树中第K小的元素
### 一个二叉树，每个节点除了有左右子节点外，还有指向父节点的引用。给出一个节点，返回它在二叉树中中序遍历的下一个节点。 
### 给定一颗二叉树，求其中root的最长路径。所谓路径是指，联通两个结点的最小边数
### 代码：输出二叉树从左侧看的结果 
### 二叉树从根到叶子的路径总和是否存在指定的值，很简单的问题。
### 一棵二叉树找到是否有一条路径（从根节点到子节点），节点值的和为N（leetcode原题）
### 求二叉树的两个节点的最近共同父节点
### 按层次遍历二叉树
```
void LevelOrder(TreeNode *root){
    std::queue<TreeNode *> q;
    TreeNode *front;
    if (root == NULL)
        return;
    q.push(root);
    while (!q.empty()) {
        front = q.front();
        q.pop();
        if (front->left)
            q.push(front->left);
        if (front->right)
            q.push(front->right);
        printf("%c ", front->data);
    }
}
```
### 给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值

### 冒泡的实现和优缺点

### 找出一从小到大排序数组中小于0的最大数的索引和大于0的最小数的索引，如果数组没排序怎么找

### 代码 两个str 最大公共子序列和子串
### int 4字节整数的海量数据，如何给出一个数，判断是否在这堆数据里？
### 给定数字字符串，用*分为六部分，每部分0~600，输出所有可能的结果
### 大文本数据（数T），统计每个字符串的频率
### 怎么判断链表有环，怎么找到环入口
### 怎么判断链表是否相交，找到相交点

### 手写求两个链表第一个交叉节点

 ### 两个升序数组，找出第k小的数字，
 这题没见过，先说了个最笨的方法，要求优化。想了一下，又说了一个用二分优化的，要求再优化，最后他提示了一下，想明白了写了代码
### 写LRU

### 查找两个链表的交叉节点

### 千万级别的数据量，实现队列FIFO，如何设计数据结构节省内存空间（数据+链表）


### 如何利用rand(1,8)实现随机生成1-5



### 合并两个有序数组



### 一个数组有1个数字出现了一次,其他数字出现了三次,请问不用map的情况如何找到这个只出现了一次的数（不会）

### 删除一个整数数组中value为50的数字，并且返回最终的长度

### 求数组的中位数。数组由一个升序数组翻转形成，如1 2 3 4 5 6 7可以从5处翻转，形成5 6 7 1 2 3 4，求5 6 7 1 2 3 4的中位数。要求时间复杂度低于O(n)。

### 给一个数组，定义X为某个区间的最小值乘上这个区间内所有元素的和，求最大的X。如数组为3 1 6 4 5，则最大的X=4*（6+4+5）=60

### 一个数组，每个位置的值对应下标。重新排列，要求对应位置上不能有同下标相同的值，即原先a[0]=0，重排后a[0]不可以等于0。输出总共有多少种重新排列的方法。


### 手写快排
### 手写堆排
### 已知出栈序列求所有的入栈序列（这题很有意思，当时只是写了列出所有的可能，后来想到这题和已知入栈序列求所有出栈序列是一样的）

### 合并两个有序链表。递归和非递归的实现。



### 给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。
当时我真的是很慌张！脑子里想的是我会做我会做！可是却是一片空白。深呼吸一下。用递归做了出来。 又问我除了递归怎么做？“那就遍历，每次都比较就行”
“那为什么不用遍历用递归呢？”“递归写起来简单啊！”

### 两个链表相加。{1->2->3} + {1->2->3} = 246. 



### 两个有序链表合并成一个有序
（代码有错，忘了写迭代）

### 一个链表，假设第一个节点我们定为下标为1，第二个为2，那么下标为奇数的结点是升序排序，偶数的结点是降序排序，如何让整个链表有序？（分离链表，合并两个有序链表）

### 假设我们有一个队列，可能存放几千万上亿的数据，我们应该如何设计这个队列？写出来看看？（提问：这个队列是只需要在头尾添加和删除吗？双向队列？答：是的）

### 一个二维矩阵，从左到右是升序，从上到下是降序，找一个数是否存在于矩阵中（类似于二叉查找树）

### 单链表的反转，不用递归的方法。

### 有序数组存在某个值，查找这个值的下标，有则输出，无则输出-1

### 写个二进制转十进制

### 手写“反转链表”算法？（迭代和递归）

### 给你一个数组，数组长度为 n。请找出数组中第k大的数

n, A[i] int 范围内

附件条件：不允许改变元素在数组中的位置。

一开始想都没想就先说了用partition的思路，面试官听了之后加了一个附加条件...就完全没思路了，最后问了提示：“给你一个数你能找到是数组的第几大吗？”，才想出来并实现

思路就是在int范围内取中位数，算出其在数组中是第几大元素，与k比较并不断二分