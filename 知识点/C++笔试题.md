# C++笔试题

## 多态

- 属性不存在重写，只有方法(非私有方法、非静态方法、非final方法) 才存在重写，才能发生多态；

## 变量及其作用范围

实例变量是类的成员变量

静态变量用关键字static声明

在方法体中定义的局部变量在该方法被执行时创建  错

局部变量在使用前可不用初始化 错

## 常成员函数声明

void func() const;

如果const放前面，则是修饰返回值的，所以要放在后面

## 计算变量占用内存大小

https://www.cnblogs.com/johnleo/p/struct_size.html

64位操作系统
char ：1个字节(固定)
*(即指针变量): 8个字节
short int : 2个字节(固定)
int： 4个字节(固定)
unsigned int : 4个字节(固定)
float: 4个字节(固定)
double: 8个字节(固定)
long: 8个字节
unsigned long: 8个字节(变化*其实就是寻址控件的地址长度数值)
long long: 8个字节(固定)

c++定义一个空的类CTest，CTest没有定义任何成员变量和成员函数，在32位机器上，以下结论正确的有：

对该类求sizeof，结果为1。因为默认有构造函数

给CTest添加构造函数，再对CTest求sizeof，结果为1.

给CTest添加虚函数，再对CTest求sizeof，结果为4.


内存对齐原则
1、  对于结构的各个成员，第一个成员位于偏移为0的位置，以后每个数据成员的偏移量必须是min(#pragma pack()指定的数，这个数据成员的自身长度) 的倍数。
2、  在数据成员完成各自对齐之后，结构(或联合)本身也要进行对齐，对齐将按照#pragma pack指定的数值和结构(或联合)最大数据成员长度中，比较小的那个进行。


## 宏定义与替换

#define Mul(x,y) ++x*++y
  
void main()
{
int a = 1;
int b = 2;
int c = 3;
  
printf(“%d”,Mul(a+b,b+c));
}

 Mul(a+b,b+c)经过宏替换变成++a+b*++b+c，需要注意宏替换的原则，是不会凭空加括号的。另外++优先级大于*，因此会先++a 和++b，然后a=2,b=3进行a+b*b+c=2+3*3+3=14 

 优先级（）>  ++ > * > +

 ### 指针和引用的区别
- 指针指向一块内存，它的内容是所指内存的地址；而引用则是某块内存的别名。
- 指针是一个实体，而引用仅是个别名；
- 引用只能在定义时被初始化一次，之后不可变；指针可变；引用“从一而终”，指针可以“见异思迁”；
- 引用没有const，指针有const，const的指针不可变；（具体指没有int& const a这种形式，而const int& a是有     的，  前者指引用本身即别名不可以改变，这是当然的，所以不需要这种形式，后者指引用所指的值不可以改变）
- 引用不能为空，指针可以为空；
- “sizeof 引用”得到的是所指向的变量(对象)的大小，而“sizeof 指针”得到的是指针本身的大小；
- 指针和引用的自增(++)运算意义不一样；
- 引用是类型安全的，而指针不是 (引用比指针多了类型检查
### 垃圾回收算法

- 1.标记-清除算法：该算法先标记，后清除，将所有需要回收的算法进行标记，然后清除；这种算法的缺点是：效率比较低；标记清除后会出现大量不连续的内存碎片，这些碎片太多可能会使存储大对象会触发GC回收，造成内存浪费以及时间的消耗。
- 2.复制算法：复制算法将可用的内存分成两份，每次使用其中一块，当这块回收之后把未回收的复制到另一块内存中，然后把使用的清除。这种算法运行简单，解决了标记-清除算法的碎片问题，但是这种算法代价过高，需要将可用内存缩小一半，对象存活率较高时，需要持续的复制工作，效率比较低。
- 3.标记整理算法：标记整理算法是针对复制算法在对象存活率较高时持续复制导致效率较低的缺点进行改进的，该算法是在标记-清除算法基础上，不直接清理，而是使存活对象往一端游走，然后清除一端边界以外的内存，这样既可以避免不连续空间出现，还可以避免对象存活率较高时的持续复制。这种算法可以避免100%对象存活的极端状况，因此老年代不能直接使用该算法。
- 4.分代收集算法：分代收集算法就是目前虚拟机使用的回收算法，它解决了标记整理不适用于老年代的问题，将内存分为各个年代，在不同年代使用不同的算法，从而使用最合适的算法，新生代存活率低，可以使用复制算法。而老年代对象存活率搞，没有额外空间对它进行分配担保，所以只能使用标记清除或者标记整理算法。

### C++的内存管理和回收的原理
- new delete

### 什么是面向对象

- 把数据及对数据的操作方法放在一起，作为一个相互依存的整体——对象

- 1、封装：隐藏对象的属性和实现细节，仅对外提供公共访问方式，将变化隔离，便于使用，提高复用性和安全性。
- 2、继承：提高代码复用性；继承是多态的前提。
- 3、多态：父类或接口定义的引用变量可以指向子类或具体实现类的实例对象。提高了程序的拓展性。

### 结构体大小
```
Struct  Node {
Char a;//偏移量为0
Int val;//偏移量为1，因为char的大小为1，但是偏移量必须是这个成员的整数倍，所以为4
Node *node;//偏移量为4，因为指针的大小为8，但是偏移量必须是这个成员的整数倍，所以为8
Char a;//偏移量为8，因为char的大小为1，但是偏移量必须是这个成员的整数倍，所以为16
};
```

### 什么是可重入

可重入函数主要用于多任务环境中，一个可重入的函数简单来说就是可以被中断的函数，也就是说，可以在这个函数执行的任何时刻中断它，转入OS调度下去执行另外一段代码，而返回控制时不会出现什么错误；而不可重入的函数由于使用了一些系统资源，比如全局变量区，中断向量表等，所以它如果被中断的话，可能会出现问题，这类函数是不能运行在多任务环境下的。

### 静态库动态库优缺点

- 静态库在程序编译时会被连接到目标代码中，程序运行时将不再需要该静态库。
- 动态库在程序编译时并不会被连接到目标代码中，而是在程序运行是才被载入，因此在程序运行时还需要动态库存在

静态链接库的优点

- (1) 代码装载速度快，执行速度略比动态链接库快；
- (2) 只需保证在开发者的计算机中有正确的.LIB文件，在以二进制形式发布程序时不需考虑在用户的计算机上.LIB文件是否存在及版本问题，可避免DLL地狱等问题。

动态链接库的优点

- (1) 更加节省内存并减少页面交换；
- (2) DLL文件与EXE文件独立，只要输出接口不变（即名称、参数、返回值类型和调用约定不变），更换DLL文件不会对EXE文件造成任何影响，因而极大地提高了可维护性和可扩展性；
- (3) 不同编程语言编写的程序只要按照函数调用约定就可以调用同一个DLL函数；
- (4)适用于大规模的软件开发，使开发过程独立、耦合度小，便于不同开发者和开发组织之间进行开发和测试。

不足之处

- (1) 使用静态链接生成的可执行文件体积较大，包含相同的公共代码，造成浪费；
- (2) 使用动态链接库的应用程序不是自完备的，它依赖的DLL模块也要存在，如果使用载入时动态链接，程序启动时发现DLL不存在，系统将终止程序并给出错误信息。而使用运行时动态链接，系统不会终止，但由于DLL中的导出函数不可用，程序会加载失败；速度比静态链接慢。当某个模块更新后，如果新模块与旧的模块不兼容，那么那些需要该模块才能运行的软件，统统撕掉。这在早期Windows中很常见。

### equals和==的区别
- equals:是用来比较两个对象内部的内容是否相等的。
- ==：是用来判断两个对象的地址是否相同，即是否是指相同一个对象。
- 如果没有重写equals时，是直接用==判断的
- 如果是基本类型和基本型封装，则仍然为比较内容。

### 编译是怎么一个过程呢？
- 词义分析
- 语义分析
- 语法分析
- 代码生成

### 一致性哈希
- 在解决分布式系统中负载均衡的问题时候可以使用Hash算法让固定的一部分请求落到同一台服务器上，这样每台服务器固定处理一部分请求（并维护这些请求的信息），起到负载均衡的作用。
- 但是普通的余数hash（hash(比如用户id)%服务器机器数）算法伸缩性很差，当新增或者下线服务器机器时候，用户id与服务器的映射关系会大量失效。一致性hash则利用hash环对其进行了改进。